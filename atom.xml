<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[I code it]]></title>
  <link href="http://abruzzi.github.com/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2013-10-11T23:15:15+05:30</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[bower as dependencies manager]]></title>
    <link href="http://abruzzi.github.com/2013/10/bower-as-dependencies-manager/"/>
    <updated>2013-10-09T16:38:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/bower-as-dependencies-manager</id>
    <content type="html"><![CDATA[<h3>Bower简介</h3>

<h4>Bower安装及简单配置</h4>

<p><a href="http://bower.io/">Bower</a>是一个基于Node.js的依赖管理工具，它是一个npm的包，因此安装十分简单，由于我们需要在所有项目中都可以使用bower，因此将其安装在全局目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g bower</span></code></pre></td></tr></table></div></figure>


<p>安装完成之后，可以通过<code>bower search</code>来搜索需要的包，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bower search underscore</span></code></pre></td></tr></table></div></figure>


<p>典型的应用场景可能会是这样的，新建一个项目目录，然后运行<code>bower init</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir -p listing
</span><span class='line'>$ cd listing
</span><span class='line'>$ bower init</span></code></pre></td></tr></table></div></figure>


<p>和Grunt类似，bower会问你一些问题，比如项目名称，项目入口点，作者信息之类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "name": "listing",
</span><span class='line'>  "version": "0.0.0",
</span><span class='line'>  "authors": [
</span><span class='line'>    "Qiu Juntao &lt;juntao.qiu@gmail.com&gt;"
</span><span class='line'>  ],
</span><span class='line'>  "main": "src/app.js",
</span><span class='line'>  "license": "MIT",
</span><span class='line'>  "ignore": [
</span><span class='line'>    "**/.*",
</span><span class='line'>    "node_modules",
</span><span class='line'>    "bower_components",
</span><span class='line'>    "test",
</span><span class='line'>    "tests"
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>比如我们需要安装jQuery和underscore.js，则很简单的运行<code>bower install</code>命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bower install jquery
</span><span class='line'>$ bower install underscore</span></code></pre></td></tr></table></div></figure>


<p>如果需要团队中的其他成员可以在本地恢复我们的环境，需要在bower.json中指定<code>dependencies</code>小节：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  "dependencies": {
</span><span class='line'>    "jquery": "~2.0.3",
</span><span class='line'>    "underscore": "~1.5.2"
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>所有的JavaScript包都被安装到了本地的<code>bower_components</code>目录下，如果有了bower.json文件，那么即使本地的<code>bower_components</code>目录不存在，或者其中的包内容过期了，那么很容易用<code>bower install</code>将其更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt的几个常用插件]]></title>
    <link href="http://abruzzi.github.com/2013/10/grunt-plugins/"/>
    <updated>2013-10-08T16:42:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/grunt-plugins</id>
    <content type="html"><![CDATA[<h3>Grunt的几个常用插件</h3>

<h4>grunt-karma 简介</h4>

<p><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a>是一个karma的Grunt插件，<a href="http://icodeit.org/2013/10/using-karma-as-the-javascript-test-runner/">上一篇文章</a>中已经介绍了karma的基本用法。这里简单介绍如何在Grunt中使用karma。</p>

<p>首先需要安装grunt-karma插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-karma --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中加载该插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-karma');</span></code></pre></td></tr></table></div></figure>


<p>在使用karma之前，需要生成一个karma的配置文件<code>karma.conf.js</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma init karma.conf.js</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中，加入初始化karma的参数，并指定，karma需要使用<code>karma.conf.js</code>文件作为配置来运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>  karma: {
</span><span class='line'>    unit: {
</span><span class='line'>      configFile: 'karma.conf.js'
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>大多数情况下，如果要把karma作为CI的一部分，应该启动单次运行模式:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>singleRun: true</span></code></pre></td></tr></table></div></figure>


<p>这样karma会启动浏览器，运行所有的测试用例，然后退出。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');
</span><span class='line'>grunt.loadNpmTasks('grunt-karma');
</span><span class='line'>
</span><span class='line'>grunt.registerTask('default', ['jshint', 'karma']);</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/10/grunt-karma-resized.png" alt="image" /></p>

<p>注意此处的default后边带了一个任务数组，其中每个任务会按照声明的顺序依次被执行。事实上此处的&#8217;default&#8217;是后边整个列表的一个别名(alias)。</p>

<h4>grunt-jshint / grunt-uglify / grunt-concat</h4>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>是一个用于JavaScript静态语法检查的工具，它会帮助开发者在进行较为严格的语法检查。</p>

<p>和其他的Grunt插件一样，它是以一个npm的包的形式发布的，因此安装非常容易:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-contrib-jshint --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中加载该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>即可，类似的还有：用以连接所有JavaScript源代码为一个独立文件的<a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a>，以及用以最小化JavaScript源码的<a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a>。</p>

<h4>自定义插件</h4>

<p><a href="https://github.com/gruntjs/grunt-init">grunt-init</a>是一个帮助开发人员快速搭建基于Grunt项目的工具，比如开发jQuery插件，Gruntfile，或者Grunt插件本身。安装方式很简单，我们需要在其他项目也用到grunt-init，因此安装在全局路径下<code>-g</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g grunt-init</span></code></pre></td></tr></table></div></figure>


<p>开发Grunt插件，我们需要一个基本的模板，将这个模板clone到home下的.grunt-init目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin</span></code></pre></td></tr></table></div></figure>


<p>然后新建一个目录，并在该目录下运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir beautify
</span><span class='line'>$ cd beautify
</span><span class='line'>$ grunt-init gruntplugin</span></code></pre></td></tr></table></div></figure>


<p>grunt-init会让你回答一些问题，比如插件名称，版本号，github链接等。之后，grunt-init会生成一个基本的模板，开发者只需要完成自己插件的逻辑代码即可。逻辑实现在<code>tasks/&lt;plugin-name&gt;.js</code>中即可。</p>

<p>完成后可以通过<code>npm publish</code>来发布，发布之后，你的插件就可以向上边提到的常用插件那样被其他的开发者使用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Karma运行JavaScript测试]]></title>
    <link href="http://abruzzi.github.com/2013/10/using-karma-as-the-javascript-test-runner/"/>
    <updated>2013-10-08T10:36:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/using-karma-as-the-javascript-test-runner</id>
    <content type="html"><![CDATA[<h3>Karma 简介</h3>

<p>Karma是一个JavaScript的测试运行器。事实上，Karma更是一个测试环境，使用Karma可以很方便的的运行测试(方便到你感觉不到它的实际存在)。</p>

<p>一般的TDD的开发流程为：</p>

<ol>
<li>编写测试(一个会失败的case)</li>
<li>运行测试，并看到这个测试失败</li>
<li>编写代码(足够让测试通过的代码)</li>
<li>运行测试，并看到测试通过</li>
<li>重构</li>
<li>运行测试，并看到测试通过</li>
</ol>


<p>然后<strong>如此循环</strong>，而在前端开发中，很长一段时间，这个流程受限于开发环境，比如添加了一个新的JavaScript源文件，开发者需要在HTML中引入相应地文件，以及响应的测试文件，然后刷新页面(有时候还需要清空浏览器缓存)。</p>

<p>在这个过程中，开发者真正关注的就是编写测试，运行测试，编写实现，重构等等，需要不断的重复这个过程。而不是关注如刷新页面，清空缓存，修改HTML对脚本的引用等武馆的工作。</p>

<p>Karma就是这样一个开发环境，开发者指定需要测试的脚本/测试文件，需要运行的浏览器等信息，Karma会在后台自动监控文件的修改，并启动一个浏览器与Karma的服务器连接，这样当源代码或者测试发生修改后，Karma会自动运行测试。</p>

<p>开发者可以指定不同的浏览器，甚至可以跨设备。由于Karma只是一个运行器，你可以使用项目中正在使用的测试框架如Jasmine，QUnit等，甚至可以自定义适配器来支持你自己的测试框架。</p>

<h3>运行Karma</h3>

<p>Karma需要一个配置文件来知道哪些文件需要被加载，需要被监控(当文件内容发生变化时，尝试运行测试)，这个配置文件可以通过Karma自带的参数来生成。</p>

<h4>基本使用</h4>

<p>Karma被实现为一个npm的包，所以可以通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g karma</span></code></pre></td></tr></table></div></figure>


<p>安装之后，可以生成karma需要的配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma init my.conf.js</span></code></pre></td></tr></table></div></figure>


<p>karma会让你回答一些问题，比如是哪种测试框架，哪些文件需要被测试，哪些浏览器需要被考虑等。生成的配置文件的一个片段是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// base path, that will be used to resolve files and exclude
</span><span class='line'>basePath = ''; 
</span><span class='line'>
</span><span class='line'>// list of files / patterns to load in the browser
</span><span class='line'>files = [ 
</span><span class='line'>  JASMINE,
</span><span class='line'>  JASMINE_ADAPTER,
</span><span class='line'>  'src/**/*.js',
</span><span class='line'>  'test/**/*spec.js'
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// web server port
</span><span class='line'>port = 9876;
</span><span class='line'>
</span><span class='line'>// browsers
</span><span class='line'>browsers = ['Chrome'];
</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong>更新</strong>
新的配置文件生成脚本会生成更加<strong>模块化</strong>的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.exports = function(config) {
</span><span class='line'>  config.set({
</span><span class='line'>  
</span><span class='line'>    frameworks: ['jasmine'],
</span><span class='line'>
</span><span class='line'>    files: [
</span><span class='line'>      'src/**/*.js',
</span><span class='line'>      'test/**/*spec.js'
</span><span class='line'>    ],
</span><span class='line'>
</span><span class='line'>    port: 9876,
</span><span class='line'>
</span><span class='line'>    browsers: ['Chrome'],
</span><span class='line'>
</span><span class='line'>    singleRun: true
</span><span class='line'>    
</span><span class='line'>  });
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>生成配置文件之后，可以通过命令来启动Karma服务器，同时指定使用<code>my.conf.js</code>文件作为配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma start my.conf.js</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/10/karma-run-resized.png" alt="image" /></p>

<h4>调试及其他</h4>

<p>很多时候，我们只想要运行某一个suite中的所有测试用例，而不是整个工程，比如在Jasmine中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("Controller User", function() {
</span><span class='line'>  it("add user", function() {});
</span><span class='line'>  it("search users", function() {});
</span><span class='line'>  it("delete user", function() {});
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>只需要将<code>describe</code>修改为<code>ddescribe</code>即可，类似的，如果只需要运行某一个测试用例，只需要将<code>it</code>修改为<code>iit</code>即可。</p>

<p>这在运行调试某个测试或者某段特定代码时非常好用。另外，Karma还提供了debugger功能，在测试用例中加入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debugger;</span></code></pre></td></tr></table></div></figure>


<p>即可。由于在运行时，karma实际上会启动一个真实地浏览器，所以可以在浏览器的developer-tool中进行实际的调试。需要注意的是，当进入调试模式时，需要启动developer-tool(在Karma启动的那个浏览器窗口中)。</p>

<p><img src="http://abruzzi.github.com/images/2013/10/karma-debug-resized.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Grunt作为构建工具(build tool)]]></title>
    <link href="http://abruzzi.github.com/2013/10/using-grunt-as-your-build-tool/"/>
    <updated>2013-10-07T18:14:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/using-grunt-as-your-build-tool</id>
    <content type="html"><![CDATA[<h3>Grunt简介</h3>

<p>Grunt是一个基于JavaScript的构建工具。和其他的构建工具类似，grunt主要用于一些将一些繁琐的工作自动化，比如运行测试，代码的静态检查，压缩JavaScript源代码等等。</p>

<h4>安装grunt-cli</h4>

<p>要在命令行运行grunt，需要安装grunt的命令行工具：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g grunt-cli</span></code></pre></td></tr></table></div></figure>


<p>grunt-cli本身并不会提供Grunt构建工具，而只是一个Grunt的调用器。<code>-g</code>参数表示将grunt-cli安装在全局的路径中，这样我们可以在不同的项目中使用grunt-cli，而由于grunt-cli本身只是一个调用器，所以对于不同的项目，真正运行的Grunt可以是不同的版本，而命令行的借口则完全一致。</p>

<p>grunt-cli提供的命令行可执行文件的名称为<code>grunt</code>，这个工具每次运行时都会检查当前目录下的Grunt。</p>

<h4>使用grunt-cli</h4>

<p>如果在一个既有的npm模块中，可以很容易的加入grunt的支持，只需要修改package.json，加入依赖，然后运行<code>npm install</code>来完成依赖的安装即可。</p>

<p>如果是一个新启动的项目，那么在项目中添加两个文件：package.json和Gruntfile。其中package.json用来定义当前项目是一个npm的模块，而Gruntfile用来定义具体的任务，以及加载Grunt的其他插件(Grunt提供丰富的插件，比如运行测试，代码静态检查等功能都是通过插件来完成的)</p>

<h4>package.json</h4>

<p>package.json定义了一个工程的元数据，这些数据被npm管理器来使用，npm本身提供了<code>init</code>参数可以很容易的生成一个package.json文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm init </span></code></pre></td></tr></table></div></figure>


<p>根据提示可以很容易的生成一个新的package.json</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "name": "chapter-testing",
</span><span class='line'>  "version": "0.0.0",
</span><span class='line'>  "description": "This is the demo for how to use grunt.js",
</span><span class='line'>  "main": "my.conf.js",
</span><span class='line'>  "directories": {
</span><span class='line'>    "test": "test"
</span><span class='line'>  },
</span><span class='line'>  "scripts": {
</span><span class='line'>    "test": "echo \"Error: no test specified\" && exit 1"
</span><span class='line'>  },
</span><span class='line'>  "author": "Juntao",
</span><span class='line'>  "license": "BSD-2-Clause"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，package.json文件中有一个<code>devDependencies</code>的小节，定义了本项目的外部依赖。</p>

<p>可以通过运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt --save-dev</span></code></pre></td></tr></table></div></figure>


<p>来为工程文件package.json添加<code>devDependencies</code>小节的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"devDependencies": {
</span><span class='line'>  "grunt": "~0.4.1"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该命令会为工程添加一条依赖关系，如果别人拿到这个文件，就可以在本地“复原”你的开发环境，以保证整个团队使用同样地<strong>库</strong>文件。</p>

<p>完成之后，该命令会在本地生成一个目录(如果没有的话)<code>node_modules</code>，其中包括了完成的Grunt的可执行文件，这时候在命令行运行grunt(由grunt-cli提供的命令行工具)，就会尝试在此目录中查找Grunt的可执行文件。</p>

<h4>Gruntfile</h4>

<p>要运行Grunt，还需要定义你自己的任务，默认的任务定义在Gruntfile中，Gruntfile有一定的格式。</p>

<p>所有的任务需要定义在一个函数中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.exports = function(grunt) {
</span><span class='line'>  // task defination
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>一般而言，使用Grunt会读取一些项目的信息(定义在package.json中)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    pkg: grunt.file.readJSON('package.json')
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>亦可以在这个时刻指定一些其他的插件的选项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    pkg: grunt.file.readJSON('package.json'),
</span><span class='line'>    jshint: {
</span><span class='line'>        all: ['Gruntfile.js', 'lib/**/*.js', 'test/**/*.js']
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>然后需要加载其他的插件(如果需要的话)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>最后，需要指定一个grunt的入口任务(<code>default</code>任务)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.registerTask('default', function() {
</span><span class='line'>  console.log("default task");
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>然后运行<code>grunt</code>，我们此处定义的default任务仅仅在控制台上打印一行字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grunt
</span><span class='line'>Running "default" task
</span><span class='line'>default task
</span><span class='line'>
</span><span class='line'>Done, without errors.</span></code></pre></td></tr></table></div></figure>


<h3>Grunt插件</h3>

<p>Grunt已经得到了很多的开源软件贡献者的支持，已经又众多的插件被开发出来。比如:</p>

<ol>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a></li>
</ol>


<p>等等，使用这些插件可以快速的为你的项目开发提供很多的便利，以grunt-jshint为例，
首先需要安装此插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-contrib-jshint --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在grunt.initConfig中指定jshint需要的参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    jshint: {
</span><span class='line'>        files: ['js/*.js'],
</span><span class='line'>        options: {
</span><span class='line'>            ignores: ['js/jquery*.js']
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>然后加载此插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>最后，可以将<code>jshint</code>加入到默认的任务中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.registerTask('default', ['jshint']);</span></code></pre></td></tr></table></div></figure>


<p>运行结果<code>可能</code>如下:</p>

<p><img src="http://abruzzi.github.com/images/2013/10/jshint.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Grape快速开发API]]></title>
    <link href="http://abruzzi.github.com/2013/08/quick-api-development-by-grape/"/>
    <updated>2013-08-04T10:29:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/08/quick-api-development-by-grape</id>
    <content type="html"><![CDATA[<h3>Grape简介</h3>

<p><a href="http://intridea.github.io/grape">Grape</a>是一个基于Rack的非常轻量级的框架，用于快速的开发API。一般来说，Rails对于单独的API来说，太过于重量级；而Sinatra虽然足够小巧，但是又没有为开发API提供足够的默认支持（如果从可控制性，灵活性上来说，Sinatra可能更好一些，但是如果有专门的更好用的工具，为什么不用呢？）。</p>

<p>安装非常简便：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install grape</span></code></pre></td></tr></table></div></figure>


<p>或者使用在自己的Gemfile中，与其他的gem一起搭建API:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem 'grape'</span></code></pre></td></tr></table></div></figure>


<h3>为既有系统添加API</h3>

<h4>简单一试</h4>

<p>之前的一篇介绍<a href="http://icodeit.org/2013/05/using-active-record-as-a-standalone-orm/">ActiveRecord在既有系统中使用</a>的文章中，我使用ActiveRecord为既有的数据库visitor中的三个表(visitor, listGroup, listGroupItem)建立了ruby对应的模型。现在我们可以为这些模型包装一组API，以方便客户端（消费者）可以通过web来访问。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module MySys
</span><span class='line'>    class API &lt; Grape::API
</span><span class='line'>        format :json
</span><span class='line'>
</span><span class='line'>        resource :visitors do
</span><span class='line'>
</span><span class='line'>            desc "get all visitor information"
</span><span class='line'>            get do
</span><span class='line'>                Visitor.limit(20)
</span><span class='line'>            end
</span><span class='line'>
</span><span class='line'>        end
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>首先，MySys::API扩展了Grape::API。<code>format</code>定义我们的API会产生JSON格式的输出，resource定义了这一组API是为资源visitors提供的，因此访问API的url为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/visitors/</span></code></pre></td></tr></table></div></figure>


<p>当然，grape提供一个很方便的设置prefix，可以使得API的路径更有意义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>format :json
</span><span class='line'>prefix "mysys"</span></code></pre></td></tr></table></div></figure>


<p>url则相应地变为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/mysys/visitors/</span></code></pre></td></tr></table></div></figure>


<h4>处理参数</h4>

<p>在对参数的处理上，grape也非常灵活，比如接上例，我们想要获取某一个具体的用户的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001</span></code></pre></td></tr></table></div></figure>


<p>我们可以添加一个新的endpoint：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "return a visitor"
</span><span class='line'>params do
</span><span class='line'>    requires :visitor_uid, :type =&gt; String, :desc =&gt; "visitor id"
</span><span class='line'>end
</span><span class='line'>route_param :visitor_uid do
</span><span class='line'>    get do
</span><span class='line'>        Visitor.find(params[:visitor_uid])
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>params中要求，需要一个类型为String的参数visitor_uid。然后在handler中，通过params来引用这个参数的值。</p>

<h4>助手函数(Helper)</h4>

<p>Grape允许开发者将编解码，权限校验等等的通用的操作分离出来，放入助手函数，这些Helper可以被所有的API使用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>helpers do
</span><span class='line'>    def generate_default_visitor(email, site) 
</span><span class='line'>        {
</span><span class='line'>            :visitor_uid =&gt; SecureRandom.hex,
</span><span class='line'>            :password_expiration =&gt; (Time.now + 60 * 60 * 24),
</span><span class='line'>            :last_used_timestamp =&gt; (Time.now - 60 * 60 * 24),
</span><span class='line'>            :visitor_login_id =&gt; email,
</span><span class='line'>            :site_name =&gt; site
</span><span class='line'>        }
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>使用上边定义的助手函数<code>generate_default_visitor</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "create a visitor"
</span><span class='line'>params do
</span><span class='line'>    requires :email, :type =&gt; String, :desc =&gt; "Email address"
</span><span class='line'>    requires :site, :type =&gt; String, :desc =&gt; "Site"
</span><span class='line'>end
</span><span class='line'>post do
</span><span class='line'>    attr = generate_default_visitor(params[:email], params[:site])
</span><span class='line'>    visitor = Visitor.new attr
</span><span class='line'>    visitor.visitor_uid = attr[:visitor_uid]
</span><span class='line'>    visitor.save
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<h3>对API进行测试</h3>

<p>通过Web测试API有非常多的方式，比如通过浏览器的插件(POSTMan)，RSpec，但是我最喜欢，也是最轻便的方式是通过命令行工具curl：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -H "Content-Type: application/json" -X POST -d "{\"email\":\"jtqiu@tw.com\", \"site\":\"mysys\"}" http://localhost:9292/visitors/</span></code></pre></td></tr></table></div></figure>


<p>命令行的程序curl是一个非常灵活，强大的工具，可以定制HTTP头信息，User Agent，支持所有的HTTP动词，最重要的是，在命令行很容易将工具们组合在一起，并完成自动化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rack it up]]></title>
    <link href="http://abruzzi.github.com/2013/08/rack-it-up/"/>
    <updated>2013-08-02T07:38:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/08/rack-it-up</id>
    <content type="html"><![CDATA[<h3>Rack it up (proc)</h3>

<p>一个最简单的rack应用程序可以是：一个简单的ruby对象，包含了一个call方法。这个call方法接受一个参数，并返回一个有三个元素的数组即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def call(env)
</span><span class='line'>  [200, {}, ["content"]]
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>其中参数env将被rack用作HTTP请求对象来传递进来，而函数的返回值与HTTP响应对应：分别为状态码，HTTP头信息以及响应内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逐步编写一个jQuery插件(todoify)]]></title>
    <link href="http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step/"/>
    <updated>2013-07-20T13:04:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step</id>
    <content type="html"><![CDATA[<h3>最终结果</h3>

<p>这篇文章将讨论如何编写一个简单的jQuery插件的基本步骤和实践，最后完成的时候，我们会得到一个管理todo的插件（而且还是一个比较灵活，易于定制的todo插件）。事实上，这个插件可以工作在所有与管理todo类似的应用场景中，比如gmail的搜索框中的token等，豆瓣读书里的tags管理等等。</p>

<p><img src="http://abruzzi.github.com/images/2013/07/todo-origin.resized.png" alt="默认设置" /></p>

<p>上例中HTML结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div id="container"&gt;
</span><span class='line'>    &lt;input type="text" id="input" /&gt;
</span><span class='line'>    &lt;div id="todos" /&gt;
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>下面的JavaScript代码将会找到id为<em>input</em>的输入框，并将它<strong>变为</strong>一个todolist的控制器，并将新加入的内容添加到id为<em>todos</em>的容器中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#input").todoify({
</span><span class='line'>  container: "#todos"
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>如果需要定制item的外观，可以定义模板并自定义渲染函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#thing-input").todoify({
</span><span class='line'>    container: "#thing-todos",
</span><span class='line'>    template: "&lt;section class='todoItem'&gt;&lt;header&gt;&lt;%= todo %&gt;&lt;/header&gt;&lt;a&gt;remove&lt;/a&gt;&lt;/section&gt;",
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>
</span><span class='line'>        cont.find("a").click(function(event){
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/07/todo-customized.resized.png" alt="Item定制" /></p>

<h3>jQuery插件基础知识</h3>

<h4>简单流程</h4>

<p>通常使用jQuery的流程是这样的：通过选择器选择出一个jQuery对象（集合），然后为这个对象应用一些预定义的函数，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$(".artile .title").mouseover(function(){
</span><span class='line'>  $(this).css({
</span><span class='line'>      "background-color": "red",
</span><span class='line'>      "color": "white"
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>我们如果要定义自己的插件，预期其被调用的方式和此处的<em>mouseover</em>并无二致。这需要将我们定义的函数attach到jQuery对象的fn属性上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$.fn.hltitle = function() {
</span><span class='line'>  this.mouseover(function(){
</span><span class='line'>      $(this).css({
</span><span class='line'>          "background-color": "red",
</span><span class='line'>          "color": "white"
</span><span class='line'>      })
</span><span class='line'>  })
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>$('.article .title').hltitle();</span></code></pre></td></tr></table></div></figure>


<p>jQuery的一个很明显的特点是其链式操作，即每次调用完成一个函数/插件之后仍然会返回jQuery对象本身，这个需要我们在插件函数的最后一行返回<em>this</em>。这样插件的使用者会像使用其他函数/插件一样很方便的将调用连起来。</p>

<p>另外一个问题是注意命名冲突（$是一个合法的标示符，而且被众多的JavaScript库在使用），所以可以通过匿名执行函数来避免：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>  $.fn.hltitle = function() {
</span><span class='line'>      //...
</span><span class='line'>  }
</span><span class='line'>}(jQuery));</span></code></pre></td></tr></table></div></figure>


<h4>需要注意的问题</h4>

<p>上面是一个最简单的插件定义，为了插件更加灵活，我们需要尽可能多的将配置项暴露给插件的用户，比如提供一些默认选项，如果用户不提供配置，则插件按照默认配置来工作，但是用户可以通过修改配置来定制插件的行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>  $.fn.hltitle = function(options) {
</span><span class='line'>      var defaults = {
</span><span class='line'>          "background-color": "red",
</span><span class='line'>          "color": "white"                
</span><span class='line'>      };
</span><span class='line'>      
</span><span class='line'>      var settings = $.extend(defaults, options);
</span><span class='line'>      
</span><span class='line'>      return this.mouseover(...);
</span><span class='line'>  }
</span><span class='line'>}(jQuery));
</span></code></pre></td></tr></table></div></figure>


<h3>Todoify</h3>

<p>我们的插件是一个遵循上述原则的简单插件，基本的步骤如下：</p>

<ul>
<li>将给定的input包装成一个jQuery对象</li>
<li>需要一个默认的放置todolist的容器元素</li>
<li>为input注册keypress事件（如果用户按Enter，则触发add事件，添加一个新条目到容器）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>    $.fn.todoify = function(options) {
</span><span class='line'>        var settings = $.extend({
</span><span class='line'>            container: "body",
</span><span class='line'>            template: "&lt;span class='todo-item'&gt;&lt;%= todo %&gt;&lt;/span&gt;",
</span><span class='line'>            renderItem: function(item) {
</span><span class='line'>              return $(_.template(this.template, {todo: item}));
</span><span class='line'>            }
</span><span class='line'>        }, options);
</span><span class='line'>
</span><span class='line'>        $(this).keypress(function(event){
</span><span class='line'>            if(event.keyCode == 13) {
</span><span class='line'>                var item = $(this).val();
</span><span class='line'>                $(settings.container).append(settings.renderItem(item));
</span><span class='line'>                $(this).val("").focus();
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return this;
</span><span class='line'>    }
</span><span class='line'>}(jQuery));</span></code></pre></td></tr></table></div></figure>


<p>此处为了防止创建众多的DOM元素，然后依次插入到正确地节点上，我使用了underscore.js的template，不过此处并非重点，略微一提。</p>

<p>如果用户想要更好地定制性，比如用户想要apply自己的class，定义自己的模板，或者注册新的事件（删除一条todo），显然我们需要更多的options：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var settings = $.extend({
</span><span class='line'>    data: [],
</span><span class='line'>    template: "&lt;div class='todo'&gt;&lt;h3&gt;&lt;%= todo %&gt;&lt;/h3&gt;&lt;span&gt;X&lt;/span&gt;&lt;/div&gt;",
</span><span class='line'>    container: "body",
</span><span class='line'>    renderTemplate: function(item) {
</span><span class='line'>        return $(_.template(this.template, {todo: item}));
</span><span class='line'>    },
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>        cont.find("span").click(function(event) {
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>}, options);</span></code></pre></td></tr></table></div></figure>


<p>这里定义了默认的close事件需要attach到span（定义在模板中）上，如果插件的用户需要自己绘制模板，并且注册事件，那么会像文章开头的那个实例一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#thing-input").todoify({
</span><span class='line'>    container: "#thing-todos",
</span><span class='line'>    template: "&lt;section class='todoItem'&gt;&lt;header&gt;&lt;%= todo %&gt;&lt;/header&gt;&lt;a&gt;remove&lt;/a&gt;&lt;/section&gt;",
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>
</span><span class='line'>        cont.find("a").click(function(event){
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h3>进一步改进</h3>

<p>目前，todoify还没有与后台进行任何的通信，如果可以和后台的RESTFul的API集成的话，这个插件将会有更多的使用场景。</p>

<p>简单来讲，只需要为插件提供更多选项，并提供回调函数即可，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#input").todoify({
</span><span class='line'>  restful: 'http://app/todos',
</span><span class='line'>  onadd: function(item){
</span><span class='line'>      //...
</span><span class='line'>  },
</span><span class='line'>  ondelete: function(item){
</span><span class='line'>      //...
</span><span class='line'>  }
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>然后加入一些ajax的调用即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Common Lisp中的宏(Macro)]]></title>
    <link href="http://abruzzi.github.com/2013/06/macro-in-common-lisp/"/>
    <updated>2013-06-15T11:12:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/06/macro-in-common-lisp</id>
    <content type="html"><![CDATA[<h4>Lisp与其他语言之区别</h4>

<p>函数式编程，前缀表达式，繁多的括号，奇怪的操作符等等，这些都足以让Lisp和其他编程语言看起来有很大的区别，但是这些区别并非本质上的差异。让Lisp和其他编程语言有本质区别的是它对<code>宏</code>的支持。</p>

<p>C语言中的，被称为<code>宏</code>的预编译系统自有其好处，但是和Lisp中的<code>宏</code>比起来，好比的Notepad和Vim或者Emacs之间的差异。</p>

<h4>数据与代码</h4>

<p>在Lisp中，数据和代码间的差异非常小，<a href="http://icodeit.org/2013/06/common-lisp-basic/">上一篇文章</a>简单讨论了<code>引用</code>的基本概念，其中对数据与代码的差异已经有所涉及。</p>

<h4>宏(Macro)</h4>

<p>简而言之，<code>宏</code>即替换，在Lisp中，可以通过程序生成代码(s-expr)，而这些代码又可以被执行（当然，需要是合法的s-expr）。这一点赋予了<code>宏</code>无限的可能性，比如定义一个新的语法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro only (condition &rest body)
</span><span class='line'>  `(if ,condition (progn ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>Lisp中函数macroexpand-1可以用来查看调用时<code>宏</code>是如何展开的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(only (&gt; x 10) (format t "big than 10")))   
</span><span class='line'>
</span><span class='line'>(IF (&gt; X 10)
</span><span class='line'>    (PROGN (FORMAT T "big than 10")))</span></code></pre></td></tr></table></div></figure>


<p>上例中，<code>(&gt; x 10)</code>被作为<code>condition</code>，而<code>(format t "big than 10")</code>作为<code>body</code>传递给了宏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(only (&gt; x 10) 
</span><span class='line'>  (format t "big than 10")
</span><span class='line'>  (format t "~%")))
</span><span class='line'>
</span><span class='line'>(IF (&gt; X 10)
</span><span class='line'>    (PROGN (FORMAT T "big than 10") (FORMAT T "~%")))</span></code></pre></td></tr></table></div></figure>


<p>使用<code>progn</code>是为了让剩余的多条语句(如果有的话)，逐条执行，并返回最后一条语句的值（正如在函数中那样）。</p>

<h4>可能的陷阱</h4>

<p><a href="http://icodeit.org/2013/06/common-lisp-basic/">上一篇文章</a>中讨论了迭代的通用方式<code>do</code>，虽然很通用，但是三段式的定义略显繁琐。</p>

<p>我们可以编写一个简单的宏<code>ntimes</code>，它接受一个数字参数N和一个代码块Block，并执行N次这个Block：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(ntimes 10 (format t "Hello, world~%"))</span></code></pre></td></tr></table></div></figure>


<p>将打印10次<code>Hello, world</code>，<code>宏</code>的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  `(do ((x 0 (1+ x)))
</span><span class='line'>       ((&gt;= x ,n))
</span><span class='line'>     ,@prog))</span></code></pre></td></tr></table></div></figure>


<p>但是这个宏在某些场景下不能如预期般的工作：比如当在使用<code>ntimes</code>的context中，本身有一个变量x，而在代码块Block中，尝试修改这个x，会发生什么呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(let ((x 10))
</span><span class='line'>    (ntimes 5
</span><span class='line'>       (format t "~a~%" x)))</span></code></pre></td></tr></table></div></figure>


<p>预期的执行结果为打印5次10，但是事实上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4</span></code></pre></td></tr></table></div></figure>


<p>这是因为<code>宏</code>的内部使用了同名的变量，而由于作用域的原因，外部的let被屏蔽了，事实上宏的设计者貌似无法避免这类事情的发生，因为使用者如何使用是不能预料的，Lisp提供了另一种解决方案(类似于UUID)，使用<code>gensym</code>，以避免这种情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (gensym)
</span><span class='line'>
</span><span class='line'>#:G778
</span><span class='line'>&gt; (gensym)
</span><span class='line'>
</span><span class='line'>#:G779</span></code></pre></td></tr></table></div></figure>


<p>函数<code>gensym</code>每次都会分配一个新的ID作为标示，因此宏的实现可以修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  (let ((g (gensym)))
</span><span class='line'>    `(do ((,g 0 (+ ,g 1)))
</span><span class='line'>         ((&gt;= ,g ,n))
</span><span class='line'>       ,@prog)))</span></code></pre></td></tr></table></div></figure>


<p>事实上，这个版本还是有一个隐藏的bug：这里我们预期的n是一个数字，而实际上使用者是可以传入一个表达式如：<code>(setf x (- x 1))</code>，而由于<code>do</code>的特性，迭代中每次都查看测试条件是否满足<code>(&gt;= ,g ,n)</code>，这会使得<code>(setf x (- x 1))</code>会被执行N次。也就是说，当数字N是一个有副作用的表达式时，我们的宏的行为是错误的，可以通过引入额外的临时变量来解决这个问题。</p>

<p>即在最开始的适合对N求值并赋值给一个临时变量，然后每次的测试都是基于这个临时变量而来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  (let ((g (gensym))
</span><span class='line'>        (h (gensym)))
</span><span class='line'>    `(let ((,h ,n))
</span><span class='line'>       (do ((,g 0 (+ ,g 1)))
</span><span class='line'>           ((&gt;= ,g ,h))
</span><span class='line'>         ,@prog))))</span></code></pre></td></tr></table></div></figure>


<h4>定义新的语法</h4>

<p>这一小节的一个例子是for循环的<code>宏</code>定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro for (var start stop &body body)
</span><span class='line'>  (let ((gstop (gensym)))
</span><span class='line'>    `(do ((,var ,start (1+ ,var))
</span><span class='line'>          (,gstop ,stop))
</span><span class='line'>         ((&gt; ,var ,gstop))
</span><span class='line'>       ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>这样，可以很方便的使用我们比较熟悉的for语句了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (for x 1 5
</span><span class='line'>     (print x))
</span><span class='line'>
</span><span class='line'>1 
</span><span class='line'>2 
</span><span class='line'>3 
</span><span class='line'>4 
</span><span class='line'>5 </span></code></pre></td></tr></table></div></figure>


<p>另一个有意思的例子是求平均值的<code>avg</code>宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro avg (&rest args)
</span><span class='line'>  `(/ (+ ,@args) ,(length args)))</span></code></pre></td></tr></table></div></figure>


<p>由于Lisp中采取前缀表达式，因此像<code>+</code>这种函数可以很方便的apply到一个列表上，如果是中缀表达式，则这种形式的抽象就变得非常复杂。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(avg 1 2 3 4 5 6 7 8 9 10))
</span><span class='line'>(/ (+ 1 2 3 4 5 6 7 8 9 10) 10)
</span><span class='line'>
</span><span class='line'>&gt; (avg 1 2 3 4 5 6 7 8 9 10)
</span><span class='line'>11/2</span></code></pre></td></tr></table></div></figure>


<hr />

<p>附：文中部分代码示例来源于《ANSI Common Lisp》一书。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[common lisp 里的一些基本概念]]></title>
    <link href="http://abruzzi.github.com/2013/06/common-lisp-basic/"/>
    <updated>2013-06-13T16:15:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/06/common-lisp-basic</id>
    <content type="html"><![CDATA[<h3>Common Lisp</h3>

<p>之前一直说JavaScript是一门被误解很深的语言，现在学习了一段时间Lisp后发现，Lisp才是！Lisp一直为人所诟病的是它虽然很强大，但是有点学院派，难当大用。但是读了七，八章<a href="http://book.douban.com/subject/6859720/">《Practical Common Lisp》</a>和几章<a href="http://book.douban.com/subject/1456906/">《ANSI Common Lisp》</a>之后发现，怎么就学院派了，其他编程语言能处理的，Lisp一样可以处理，其他语言处理不了的（或者很繁琐的，比如java中的循环，map之类），Lisp却能处理。</p>

<p>Lisp本质上是一个抽象语法树（AST）而已，但是又提供了一些操作这个AST的方法（比如强大的宏），这样很容易用Lisp开发出来一个新的DSL。用函数式编程的好处之一就是在编写完一个应用程序之后，通常还可以获得一个新的语言（于业务领域很匹配的语言）。</p>

<p><a href="http://zh.wikipedia.org/wiki/Common_Lisp">Common Lisp</a>本身是Lisp的一个方言，是有一个标准来定义，其目的是为了标准化众多的Lisp分支而定。</p>

<h4>sbcl环境</h4>

<p><a href="http://icodeit.org/2013/06/setup-lisp-development-env-on-mac/">上一篇文章</a>已经介绍了如何在Mac下配置Common Lisp的开发环境：</p>

<p><img src="http://abruzzi.github.com/images/2013/06/sbcl.resized.png" alt="image" /></p>

<h4>引用（quote）</h4>

<p>由于在Lisp中，数据和代码都是通过S-expr来表示，所以需要用一种标记法来告诉解释器：这个表达式表示数据/代码。这就是引用的作用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (+ 1 2 3 4 5)
</span><span class='line'>15
</span><span class='line'>
</span><span class='line'>&gt; '(+ 1 2 3 4 5)
</span><span class='line'>(+ 1 2 3 4 5)</span></code></pre></td></tr></table></div></figure>


<p>解释器会将s-expr的第一项作为函数(car)，而将后续的元素(cdr)作为参数传递给第一项来调用，并求值。可以通过引用（quote）来阻止解释器这样解释。</p>

<h4>反引号(`)</h4>

<p>与引用对应的，有一个反引号形式的引用(在键盘上1的左边)。一般的用法上，它与<code>quote</code>的含义一样，都是防止解释器解释被引用的列表。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;`(a b c)
</span><span class='line'>(a b c)
</span><span class='line'>
</span><span class='line'>&gt;`(a b (+ 1 2))
</span><span class='line'>(a b (+ 1 2))</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>但是，反引号引用的列表提供了重新启动求值的能力，这……，我的意思是，如上式中，如果想要将<code>(+1 2)</code>这个子列表求值，怎么做到呢？反引号引用提供了这个能力，用逗号(,)作为子列表的前缀即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;`(a b ,(+ 1 2))
</span><span class='line'>(a b 3)</span></code></pre></td></tr></table></div></figure>


<p>这个当然在此刻看起来毫无用处，或者感觉略有画蛇添足之嫌，但是在宏中，这个操作符却有很广泛的用途，这里有一个有意思的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun foo (x) 
</span><span class='line'>  (only (&gt; x 10) (format t "big than 10")))</span></code></pre></td></tr></table></div></figure>


<p>我们可以通过<code>if</code>来实现此处的only，当only之后的条件满足的话，就执行后续的所有语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro only (condition &rest body)
</span><span class='line'>  `(if ,condition (progn ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>此处可以看到，对于宏代码体中，有部分代码我们不需要引用，如(if, progn)，而另外一部分则需要解释器真实地去解释来获得值。另外，我们需要宏本身返回一个列表(被引用的列表)。</p>

<h4>通用的循环（do）</h4>

<p><code>do</code>是Lisp中通用的处理迭代的操作符，可以在其中创建局部变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do ((i 0 (1+ i)))
</span><span class='line'>    ((&gt;= i 4))
</span><span class='line'>  (print i))</span></code></pre></td></tr></table></div></figure>


<p><code>do</code>的格式比较复杂：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do (variable-definition*)
</span><span class='line'>  (end-test-form result-form*)
</span><span class='line'>  statement*)</span></code></pre></td></tr></table></div></figure>


<p>其中，变量声明部分的格式为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(variable init-form step-form)</span></code></pre></td></tr></table></div></figure>


<p>然后是测试，如果测试成功，有一个可选的返回值（上例中为nil），然后是statement部分，如果测试失败，则执行一次statement，然后通过step-from修改变量的值，测试，执行。</p>

<p>上例的代码会打印<strong>0-3</strong>的数字。<code>do</code>的另外一个功用是它支持多个变量并发的循环，这是(dolist, dotimes等无法完成的，所以在很多宏中，do是不二之选)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do ((n 0 (1+ n))
</span><span class='line'>     (cur 0 next)
</span><span class='line'>     (next 1 (+ cur next)))
</span><span class='line'>    ((= 10 n) cur))</span></code></pre></td></tr></table></div></figure>


<p>这个例子则没有statement部分，当n等于10这个测试条件成立后，返回cur当前的值。</p>

<h4>apply 和 funcall</h4>

<p><code>apply/call</code> 这两个函数当然是FP编程语言的必备了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (apply #'(lambda (x y) (+ x y)) '(3 4))
</span><span class='line'>7
</span><span class='line'>
</span><span class='line'>&gt; (funcall #'(lambda (x y) (+ x y)) 3 4)
</span><span class='line'>8</span></code></pre></td></tr></table></div></figure>


<p>注意这里的<code>#'</code>操作符，它表示对函数对象的引用，就像<code>'</code>是对list的引用一样。</p>

<h4>list的基本操作</h4>

<p>构造列表（cons），<code>cons</code>的作用是将两个对象结合成一个对象（这个新的对象由两部分组成），这两部分分别由<code>car</code>,<code>cdr</code>来引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (cons 'a nil)
</span><span class='line'>(a)
</span><span class='line'>
</span><span class='line'>&gt; (cons 'a (cons 'b nil))
</span><span class='line'>(a b)</span></code></pre></td></tr></table></div></figure>


<p>当然可以用更简洁的方式：使用list函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (list a b)
</span><span class='line'>(a b)</span></code></pre></td></tr></table></div></figure>


<p><code>car</code>, <code>cdr</code>的用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (setf x '(a b c (d e)))
</span><span class='line'>(a b c (d e))
</span><span class='line'>
</span><span class='line'>&gt; (car x)
</span><span class='line'>a
</span><span class='line'>
</span><span class='line'>&gt; (cdr x)
</span><span class='line'>(b c (d e))
</span></code></pre></td></tr></table></div></figure>


<p>有了<code>car</code>,<code>cdr</code>，对于既定的list，我们总是可以将其遍历（这在宏中非常有用）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac下搭建Common Lisp开发环境(Emacs)]]></title>
    <link href="http://abruzzi.github.com/2013/06/setup-lisp-development-env-on-mac/"/>
    <updated>2013-06-03T16:22:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/06/setup-lisp-development-env-on-mac</id>
    <content type="html"><![CDATA[<h4>Lisp编译器（解释器）</h4>

<p>首先需要一个Lisp的编译器，<a href="http://www.sbcl.org/platform-table.html">SBCL</a>是一个开源的实现，支持所有POSIX平台。你可以选择从源码编译，也可以下载二进制包。而由于使用mac，可以用强大的homebrew来安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install sbcl</span></code></pre></td></tr></table></div></figure>


<h5>简单使用</h5>

<p>使用<code>sbcl</code>启动交互环境，如果用lisp的术语来说，这是一个REPL(read–eval–print loop )。这个环境中就可以尝试Common Lisp编程了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sbcl
</span><span class='line'>
</span><span class='line'>This is SBCL 1.1.7.0-aeb9307, an implementation of ANSI Common Lisp.
</span><span class='line'>More information about SBCL is available at &lt;http://www.sbcl.org/&gt;.
</span><span class='line'>
</span><span class='line'>SBCL is free software, provided as is, with absolutely no warranty.
</span><span class='line'>It is mostly in the public domain; some portions are provided under
</span><span class='line'>BSD-style licenses.  See the CREDITS and COPYING files in the
</span><span class='line'>distribution for more information.
</span><span class='line'>
</span><span class='line'>* (+ 1 2 3 4 5 6)
</span><span class='line'>**21**
</span><span class='line'>
</span><span class='line'>* (quit)
</span><span class='line'>
</span><span class='line'>$</span></code></pre></td></tr></table></div></figure>


<p>但是这个环境对开发者不是非常友好，比如不支持上下键导航，不支持左右键，非常原始，可以使用Emacs来作为开发环境，当然如果你更喜欢vim（像我一样），也没有任何问题。不过这是一个很好的学习Emacs编辑环境的机会，可以尝试一下。</p>

<h4>Emacs + Slime</h4>

<p><a href="http://common-lisp.net/project/slime/">Slime</a>是一个Emacs下开发Common Lisp程序的一个插件，它本身就是由lisp写成的，下载之后是一个压缩包，将其解压缩到<code>~/.eamcs.d/</code>目录中即可。
然后在<code>~/.emacs</code>文件中添加下面的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>; slime setup
</span><span class='line'>(setq inferior-lisp-program "/usr/local/bin/sbcl")
</span><span class='line'>(add-to-list 'load-path "~/.emacs.d/slime/")
</span><span class='line'>(require 'slime)
</span><span class='line'>(slime-setup)</span></code></pre></td></tr></table></div></figure>


<h5>Emacs的“开发者”配置</h5>

<p>默认的eamcs界面比较简陋，我的vim使用的solarized主题，觉得配色非常合理，结果在github上发现了其对应的<a href="https://github.com/sellout/emacs-color-theme-solarized">emacs主题</a>。现在之后，同样解压在<code>~/.emacs.d/</code>目录中，然后在<code>~/.emacs</code>加上一下配置即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>; color theme setup 
</span><span class='line'>(add-to-list 'custom-theme-load-path "~/.emacs.d/emacs-color-theme-solarized/")
</span><span class='line'>(load-theme 'solarized-dark t)
</span><span class='line'>
</span><span class='line'>; hide the tool bar
</span><span class='line'>(tool-bar-mode -1)
</span><span class='line'>
</span><span class='line'>; set the font
</span><span class='line'>(set-face-attribute 'default nil :font "Monaco")
</span><span class='line'>(set-face-attribute 'default nil :height 170)
</span></code></pre></td></tr></table></div></figure>


<h4>效果图</h4>

<p><img src="http://abruzzi.github.com/images/2013/06/emacs.resized.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alfred简介及Alfred扩展编写]]></title>
    <link href="http://abruzzi.github.com/2013/05/create-a-alfred-extension-for-create-sinatra-project/"/>
    <updated>2013-05-18T20:04:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/create-a-alfred-extension-for-create-sinatra-project</id>
    <content type="html"><![CDATA[<h3>Alfred简介</h3>

<p><a href="http://www.alfredapp.com/">Alfred</a>是Mac下的一个小工具，可以极大的提高使用计算机的效率。Alfred提供非常丰富的功能集，比如：</p>

<ol>
<li>基本的文件/目录查找功能</li>
<li>应用程序加载器</li>
<li>快速的搜索（google，wikipedia）</li>
</ol>


<p><img src="http://abruzzi.github.com/images/2013/05/alfred-find.png" alt="使用Alfred搜索" /></p>

<h4>powerpack</h4>

<p>Alfred本身是免费的，但是一些高级的功能，如：</p>

<ol>
<li>自定义扩展（<strong>非常有用</strong>）</li>
<li>剪贴板栈/代码片段管理（<strong>非常有用</strong>）</li>
<li>iTunes控制</li>
<li>近期访过的文档</li>
</ol>


<p>提供在<a href="http://www.alfredapp.com/powerpack/">powerpack</a>中，这个功能是要收费的，不过个人觉得绝对的物超所值。这些功能可以极大的提高我对计算机的使用效率，而且剪贴板栈功能可以节省我很多的时间。</p>

<p><img src="http://abruzzi.github.com/images/2013/05/alfred-clipboard.png" alt="image" /></p>

<h3>扩展编写</h3>

<p>经常会使用<a href="http://www.sinatrarb.com/">sinatra</a>编写一些简单的Web应用程序，以用作一些showcase和应用程序的原型搭建。但是由于sinatra并不是一个框架，并不会像rails那样自动生成目录结构等，而每个sinatra应用的目录结构和文件依赖都非常相似，因此完全可以考虑将这个过程自动化。</p>

<p>基本思路是：</p>

<ol>
<li>定义一个目录结构的模板</li>
<li>每次开始一个sinatra工程时，将个模板目录拷贝到新的工程下</li>
<li>一些库依赖的下载（bundle install以及JavaScript库的下载）</li>
<li>在编辑器中打开这个新的目录</li>
</ol>


<h4>一个sinatra工程的原型</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pwd
</span><span class='line'>/Users/twer/develop/templates/sinatra
</span><span class='line'>
</span><span class='line'>$ tree -a
</span><span class='line'>.
</span><span class='line'>├── .rvmrc
</span><span class='line'>├── Gemfile
</span><span class='line'>├── app.rb
</span><span class='line'>├── config.ru
</span><span class='line'>├── public
</span><span class='line'>│   ├── css
</span><span class='line'>│   └── scripts
</span><span class='line'>│       ├── app.js
</span><span class='line'>│       └── libs
</span><span class='line'>└── views</span></code></pre></td></tr></table></div></figure>


<h4>Extension shell script</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># create the project folder
</span><span class='line'>cd ~/develop/ruby && mkdir -p {query} && cd {query}
</span><span class='line'>
</span><span class='line'># cp info to folder
</span><span class='line'>cp -R ~/develop/templates/sinatra/ .
</span><span class='line'>
</span><span class='line'># grab jquery
</span><span class='line'>curl http://code.jquery.com/jquery.js &gt; public/scripts/libs/jquery.js
</span><span class='line'>
</span><span class='line'># open the project
</span><span class='line'>/Applications/MacVim.app/Contents/MacOS/Vim -g .</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/05/sinatra-ext-result.png" alt="image" /></p>

<p>执行完之后，<code>~/develop/ruby</code>下会生成一个新的目录，即<code>note</code>，这个目录中即为一个可以直接开始开发sinatra应用的工作目录了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在既有数据库中使用ActiveRecord]]></title>
    <link href="http://abruzzi.github.com/2013/05/using-active-record-as-a-standalone-orm/"/>
    <updated>2013-05-18T14:56:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/using-active-record-as-a-standalone-orm</id>
    <content type="html"><![CDATA[<h3>ActiveRecord</h3>

<p>作为rails中的ORM(object relation-db mapping)框架，ActiveRecord在初次出现之时带给了人们以无限的惊喜和热情，也使得很多不堪忍受其他语言中粗糙的ORM框架的开发者转而投入rials的怀抱。而有很多的其他语言也在不断尝试模仿ActiveRecord，比如著名的php框架<a href="http://codeigniter.org.cn/">codeigniter</a>。</p>

<p>在rails的后期版本中，ActiveRecord可以作为一个独立的库来在rails之外使用，这对使用ruby进行其他数据库应用开发的用户来说非常方便。</p>

<h4>在新的项目中使用ActiveRecord</h4>

<p>如果在一个全新的rails应用程序中使用ActiveRecord，那么关于数据库方面的一切都可以托管给它，开发者在初期可能连一行代码都不需要编写就可以让程序“像模像样”的运行起来。</p>

<h4>在已有的数据库上使用ActiveRecord</h4>

<p>现实世界中，最可能遇到的问题是数据库已经存在了（毕竟，对于关系型数据库而言，修改schema的影响太大）。这时候，我们仍然可以使用ActiveRecord来方便的访问数据库，得到ruby对象，而跳过冗长且容易出错的数据库访问层。</p>

<h3>一个例子</h3>

<h4>数据库结构</h4>

<p>数据库中有一个访客表(visitor)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+-----------------------+--------------+-----+
</span><span class='line'>| Field                 | Type         | Key |
</span><span class='line'>+-----------------------+--------------+-----+
</span><span class='line'>| visitor_uid           | varchar(32)  | PRI |
</span><span class='line'>| visitor_login_id      | varchar(128) | MUL |
</span><span class='line'>| visitor_password      | varchar(32)  |     |
</span><span class='line'>| visitor_name          | varchar(100) |     |
</span><span class='line'>| created_timestamp     | timestamp    |     |
</span><span class='line'>| password_expiration   | timestamp    |     |
</span><span class='line'>| last_used_timestamp   | timestamp    | MUL |
</span><span class='line'>| visitor_alias         | varchar(128) | MUL |
</span><span class='line'>| visitor_password_hash | binary(64)   |     |
</span><span class='line'>+-----------------------+--------------+-----+</span></code></pre></td></tr></table></div></figure>


<p>有一个访客浏览过的<code>分组</code>表(list_group)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+------------------+---------------------+-----+
</span><span class='line'>| Field            | Type                | Key |
</span><span class='line'>+------------------+---------------------+-----+
</span><span class='line'>| list_group_id    | bigint(20) unsigned | PRI |
</span><span class='line'>| list_type        | varchar(32)         | MUL |
</span><span class='line'>| visitor_uid      | varchar(32)         | MUL |
</span><span class='line'>| list_name        | varchar(128)        |     |
</span><span class='line'>| create_timestamp | timestamp           |     |
</span><span class='line'>+------------------+---------------------+-----+</span></code></pre></td></tr></table></div></figure>


<p>每个<code>分组</code>中，都有一些条目，具体到每个条目(list_group_item)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+----------------------+---------------------+-----+
</span><span class='line'>| Field                | Type                | Key |
</span><span class='line'>+----------------------+---------------------+-----+
</span><span class='line'>| list_group_item_id   | bigint(20) unsigned | PRI |
</span><span class='line'>| list_group_id        | bigint(20) unsigned | MUL |
</span><span class='line'>| item_id              | varchar(128)        | MUL |
</span><span class='line'>| create_timestamp     | timestamp           |     |
</span><span class='line'>| last_use_timestamp   | timestamp           |     |
</span><span class='line'>| note                 | varchar(4000)       |     |
</span><span class='line'>+----------------------+---------------------+-----+</span></code></pre></td></tr></table></div></figure>


<p>三张表的关系如下：</p>

<p><img src="http://abruzzi.github.com/images/2013/05/active_record.png" alt="image" /></p>

<h4>示例程序的目录结构</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>├── Gemfile
</span><span class='line'>├── Gemfile.lock
</span><span class='line'>├── app.rb
</span><span class='line'>├── config
</span><span class='line'>│   └── database.yml
</span><span class='line'>├── debug.log
</span><span class='line'>└── model
</span><span class='line'>    ├── list_group.rb
</span><span class='line'>    ├── list_group_item.rb
</span><span class='line'>    └── visitor.rb</span></code></pre></td></tr></table></div></figure>


<h4>models</h4>

<p>使用ActiveRecord，只需要简单的在模块上声明模块见的关系即可：</p>

<p>visitor类的定义，读起来非常自然：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require 'active_record'
</span><span class='line'>
</span><span class='line'>class Visitor &lt; ActiveRecord::Base
</span><span class='line'>    has_many :groups, 
</span><span class='line'>        :class_name =&gt; 'ListGroup', 
</span><span class='line'>        :foreign_key =&gt; 'visitor_uid'
</span><span class='line'>
</span><span class='line'>    self.table_name  = 'visitor'
</span><span class='line'>    self.primary_key = 'visitor_uid'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>ListGroup类的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ListGroup &lt; ActiveRecord::Base
</span><span class='line'>    self.table_name  = 'list_group'
</span><span class='line'>    self.primary_key  = 'list_group_id'
</span><span class='line'>
</span><span class='line'>    has_many :items, 
</span><span class='line'>        :class_name =&gt; 'ListGroupItem', 
</span><span class='line'>        :foreign_key =&gt; 'list_group_id'
</span><span class='line'>
</span><span class='line'>    belongs_to :visitor, 
</span><span class='line'>        :class_name =&gt; 'Visitor', 
</span><span class='line'>        :foreign_key =&gt; 'visitor_uid'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>最后是ListGroupItem的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ListGroupItem &lt; ActiveRecord::Base
</span><span class='line'>    self.table_name = 'list_group_item'
</span><span class='line'>    self.primary_key = 'list_group_item_id'
</span><span class='line'>
</span><span class='line'>    belongs_to :list_group, 
</span><span class='line'>        :class_name =&gt; 'ListGroup', :foreign_key =&gt; 'list_group_id'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>这种比较复杂的层级关系在现实中经常见到，而大部分HelloWorld型的介绍又touch不到，因此就将代码全部列于此处，以便索引。</p>

<h4>使用这些model</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def main
</span><span class='line'>    attr = visitor_attr('juntao.qiu#thoughtworks.com')
</span><span class='line'>    visitor = Visitor.new attr
</span><span class='line'>    visitor.visitor_uid = attr[:visitor_uid]
</span><span class='line'>    visitor.save
</span><span class='line'>
</span><span class='line'>    visitors = Visitor.find(:all)
</span><span class='line'>    visitors.each do |visitor|
</span><span class='line'>        p visitor[:visitor_login_id]
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>这里即可任意的使用诸如new/save,find等ActiveRecord为我们包装起来的方法了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS中的before和after伪元素及其应用]]></title>
    <link href="http://abruzzi.github.com/2013/05/before-and-after-selector-in-css/"/>
    <updated>2013-05-16T15:29:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/before-and-after-selector-in-css</id>
    <content type="html"><![CDATA[<h3>before和after伪元素</h3>

<p>所谓伪元素，可以理解为浏览器为某元素附加的元素（根据名字，附加在这个元素之前/之后）。用来完成特定的效果，before/after需要和content属性一起使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.css-class:before {
</span><span class='line'>  content: " ";
</span><span class='line'>}
</span><span class='line'>.css-class:after {
</span><span class='line'>  content: " ";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过使用before/after伪元素，可以做一些很有意思的效果。<a href="http://css-tricks.com/pseudo-element-roundup/">这里</a>有一些有意思的示例。</p>

<h3>四个三角形</h3>

<p>页面上经常会遇到小三角形这种视觉元素，比如表示一个可以<strong>打开/关闭</strong>的开关（将不会频繁使用的元素隐藏起来，点击可以展开/收起），或者一个模拟消息盒子（纯CSS实现），最早的做法是使用一个小的图片来完成，但是这个事实上可以通过纯CSS来实现。</p>

<p>原理是利用block元素的<code>border</code>属性，当<code>border</code>的值很小的时候，<code>border</code>之间的连接处并无异常，但是当<code>border</code>较大，而元素本身的尺寸小于<code>border</code>自身时，则每一个<code>border</code>都会呈现为梯形，而当元素的<code>width</code>和<code>height</code>都为0时，就会看到一个正方形，而每个边都变成了一个三角形：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.container .color-box {
</span><span class='line'>  content: " ";
</span><span class='line'>  width: 0;
</span><span class='line'>  height: 0;
</span><span class='line'>  border: 10px solid transparent;
</span><span class='line'>  border-left-color: #00ff00;
</span><span class='line'>  border-right-color: #000000;
</span><span class='line'>  border-top-color: #ff0000;
</span><span class='line'>  border-bottom-color: #0000ff;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/05/color-box.png" alt="image" /></p>

<h3>小三角形</h3>

<p>这时候，如果将其他的三条边隐藏起来（通过将<code>border</code>的颜色置为透明）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.container .color-box {
</span><span class='line'>  content: " ";
</span><span class='line'>  width: 0;
</span><span class='line'>  height: 0;
</span><span class='line'>  border: 10px solid transparent;//朝下的三角形
</span><span class='line'>  border-top-color: #ff0000;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/05/triggle.png" alt="image" /></p>

<p>先将所有的边都设置为透明色，然后根据需要显示某一个边，来完成三角形的指向。</p>

<h3>一个普通的消息框</h3>

<p>一个普通的消息框，通过设置<code>box-shadow</code>和<code>border-radius</code>之后，可以变得比较“好看”，但是如果可以给这个消息框加上一个小的三角形（可以指向用户的头像等）。</p>

<p>HTML代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &lt;div class="container"&gt;
</span><span class='line'>      &lt;div class="chat-box"&gt;
</span><span class='line'>          &lt;p&gt;
</span><span class='line'>              Resque (pronounced like "rescue") is a Redis-backed library for creating background jobs, placing those jobs on multiple queues, and processing them later.
</span><span class='line'>          &lt;/p&gt;
</span><span class='line'>      &lt;/div&gt;
</span><span class='line'>  &lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>样式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.container .chat-box {
</span><span class='line'>  position: relative;
</span><span class='line'>  border: 1px solid #6b6b6b;
</span><span class='line'>  border-radius: 5px;
</span><span class='line'>  box-shadow: 1px 1px 4px #6b6b6b;
</span><span class='line'>  width: 300px;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>.container .chat-box p {
</span><span class='line'>  margin: 0;
</span><span class='line'>  padding: 10px;
</span><span class='line'>  font-size: 18px;
</span><span class='line'>  font-family: "Microsoft Yahei";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/05/box.png" alt="image" /></p>

<h3>更fancy的消息框</h3>

<p>先通过before伪元素，在消息框的底部加上一个小的三角形：</p>

<p><img src="http://abruzzi.github.com/images/2013/05/box-triggle-gray.png" alt="image" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.container .chat-box:after, 
</span><span class='line'>.container .chat-box:before {
</span><span class='line'>  position: absolute;
</span><span class='line'>  content: " ";
</span><span class='line'>  width: 0;
</span><span class='line'>  height: 0;
</span><span class='line'>  border: solid transparent;
</span><span class='line'>  top: 100%;
</span><span class='line'>  left: 62%;
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>.container .chat-box:before {
</span><span class='line'>  border-width: 10px;
</span><span class='line'>  border-top-color: #6b6b6b;
</span><span class='line'>  margin-left: -10px;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>UPDATE:</strong></p>

<hr />

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.container .chat-box:after {
</span><span class='line'>  border-width: 9px;
</span><span class='line'>  border-top-color: white;
</span><span class='line'>  margin-left: -9px;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>但是一个实心的灰色三角形比较难看，我们需要再改进一下，即通过在这个伪元素之上，再绘制一个白色（与消息框颜色相同）的伪元素，但是尺寸又小一个单位（单位与消息框本身的尺寸相同，这里为<code>1px</code>）。</p>

<p><img src="http://abruzzi.github.com/images/2013/05/box-triggle-both.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript核心概念及实践勘误表]]></title>
    <link href="http://abruzzi.github.com/2013/05/javascripthe-xin-gai-nian-ji-shi-jian-kan-wu-biao/"/>
    <updated>2013-05-16T11:29:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/javascripthe-xin-gai-nian-ji-shi-jian-kan-wu-biao</id>
    <content type="html"><![CDATA[<h3>《JavaScript核心概念及实践》勘误表</h3>

<p><a href="http://icodeit.org/jsccp/">JavaScript核心概念及实践</a>一书已经于2013年5月出版，由于时间原因以及作者的疏于检查，导致书中出现了一些错别字词等错误，现在将错误及更正列于此页，作者为对读者朋友带来的不便表示深深的歉意。</p>

<hr />

<p>第一章第12页</p>

<p>“则向控制台打印：goodbay” 应为 “则向控制台打印：<strong>goodbye</strong>”</p>

<hr />

<p>第二章第19页</p>

<p>“var y = x + &#8220;2&#8221;;// => 32” 注释中的数字32应为字符串类型 “var y = x + &#8220;2&#8221;;// => <strong>&#8220;32&#8221;</strong>”</p>

<hr />

<p>第三章第36页</p>

<p>“对函数customize(options)的调用 constomize” 应为 “<strong>customize</strong>”。</p>

<p>同一页，3.4小节
“反回给前端的仍然是 JSON 对象” 应为 “<strong>返回</strong>给前端的仍然是 JSON 对象”</p>

<hr />

<p><a href="http://book.douban.com/review/5960403/">这里有</a>一个非常仔细，质量很高的勘误表，由网友 @RednaxelaFX 整理。</p>

<hr />

<p>这个页面将维持更新，如果有新的错误被发现，我会第一时间更新书籍的电子版本，并在此页面上更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[proc in ruby]]></title>
    <link href="http://abruzzi.github.com/2013/05/proc-in-ruby/"/>
    <updated>2013-05-12T16:01:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/proc-in-ruby</id>
    <content type="html"><![CDATA[<h2>block in ruby</h2>

<p>block在ruby中，相当于JavaScript中的匿名函数，可以用来实现诸如高阶函数等。高阶函数最好用的一个特点就是它很好的将“动作”（action）本身抽象成了一个对象来传递。</p>

<p>block本身不是对象，但是可以被转换成Proc类的实例，然后以一种特别的方式执行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> &gt; proc = lambda {puts "hello, world"}
</span><span class='line'> =&gt; #&lt;Proc:0x007ff11284d068@(irb):8 (lambda)&gt; </span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; proc = lambda do
</span><span class='line'>&gt;  puts "hello, world"
</span><span class='line'>&gt; end</span></code></pre></td></tr></table></div></figure>


<p>从irb打印的信息可以看出，<code>&lt;Proc:0x007ff11284d068@(irb):8 (lambda)&gt;</code>是一个Proc类的实例用lambda生成的block对象，看起来像一个ruby中定义的函数/方法一样，但是执行的时候需要特别的调用方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; proc.call
</span><span class='line'>hello, world
</span><span class='line'> =&gt; nil</span></code></pre></td></tr></table></div></figure>


<p>如果需要参数，可以这样指定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; proc = lambda {|a, b| a + b}
</span><span class='line'> =&gt; #&lt;Proc:0x007ff114843d40@(irb):14 (lambda)&gt; 
</span><span class='line'>&gt; proc.call(1,2)
</span><span class='line'> =&gt; 3 
</span><span class='line'>&gt; proc.call("hello, ","world")
</span><span class='line'> =&gt; "hello, world" </span></code></pre></td></tr></table></div></figure>


<h2>proc自身</h2>

<p>ruby中大名鼎鼎的rack应用程序，本质上就只是负责调用一个block来获得结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rack_proc = lambda {|env| [200, {}, ["&lt;h1&gt;Hello, world&lt;/h1&gt;"]]}
</span><span class='line'>rack_proc.call({})</span></code></pre></td></tr></table></div></figure>


<p>也可以使用proc来创建一个Proc：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; x = proc {puts "hello, world"}
</span><span class='line'> =&gt; #&lt;Proc:0x007ff114851698@(irb):18&gt; 
</span><span class='line'>&gt; x.call
</span><span class='line'>hello, world
</span><span class='line'> =&gt; nil </span></code></pre></td></tr></table></div></figure>


<p>也可以将proc实例返回出来，然后提供给其他函数使用，需要注意的是那个call方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def adder(number)
</span><span class='line'>  proc {|x| x + number}
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>add15 = adder(15)
</span><span class='line'>add15.call(10) == 25
</span><span class='line'>
</span><span class='line'>add10 = adder(10)
</span><span class='line'>add10.call(10) == 20</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重阳宫奇遇记]]></title>
    <link href="http://abruzzi.github.com/2013/04/chongyang-palase/"/>
    <updated>2013-04-28T10:32:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/04/chongyang-palase</id>
    <content type="html"><![CDATA[<h3>重阳宫简介</h3>

<p>重阳宫为道教三大祖庭之一，位于陕西户县祖庵镇，是全真祖师王重阳修道之地。重阳宫本由王重阳的弟子（全真七子，详见《射雕英雄传》）修建，始于金代，名为“灵虚观”，元初改名“重阳宫”。后山碑林存有众多用以记录全真教祖师及全真七子生平事迹的石碑，如《全真教祖碑》，《重阳祖师仙迹碑》，也有全真教其他掌教如孙德彧等的撰文碑。除了金元的碑以外，宫中还有明清时代的刻字，如《重阳子王真人全真教祖碑》碑阴的“天下祖庭”四字，为明朝正统二年所刻。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/chongyang-01.resized.jpg" alt="全真祖庭" /></p>

<p>历史上由于年久失修，众多石碑层长散弃于露天，六、七十年代之后重修重阳宫，这些石碑被存入展厅，展厅有题名“重阳圣地”，其中大约有三十多通巨型金元石碑。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/outside.resized.jpg" alt="年久失修" /></p>

<h3>甘河镇遇仙</h3>

<p>四月末的长安，已经很热。由于我去的这天是周末，而且是给五一调休的周末，因此宫中游人很少。除了我之外还有几个附近学校的学生，虽然殿外天气非常好，水绿山青，鸟语花香，但是在殿内，古朴的石碑传出的若隐若无的古老的气息，众多的由赑屃驮着的近一丈的大石碑使得展厅的气氛稍显压抑，所以很快整个展厅就剩下我一个人了。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/bixis.resized.jpg" alt="碑林展厅" /></p>

<p>虽然殿外阳光明媚，但是触摸着这些实实在在的文物，让人彷佛有些穿越千年，回到宋末元初的感觉，这种感觉让人有种莫名的阴森。而碑文中不时闪现的诸如王重阳，丘处机，尹志平等人的名字更是和金庸笔下的众多人物相交错，穿越的感觉愈发强烈。</p>

<p>我信步走到一通石碑前，顺口默诵，看着王重阳在<strong>甘河镇遇仙</strong>一段，还在心中暗笑其故意装神弄鬼，但是当我转身到碑阴面，读到“天之道，损有余而补不足，是故虚胜实，不足胜有余”之时，不由得心头大震，接着向下看到“心死则神活，阳盛而阴消”之时，更是惊骇莫名。这通碑上分明记着宋末元初的武学秘籍《九阴真经》（详见《射雕英雄传》）。</p>

<p>我正待取出纸笔将这些内容抄录，忽觉殿内似乎多出一人来，我心头一震，以我的功力，竟然有人走到我身周三丈之内而不自知。我转过头去，只见一个道士站在重阳祖师画像碑旁，呆呆的出神。只听那老道口中喃喃有声：此碑为四绝碑之首，无梦令碑有不及也。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/wumengling.resized.jpg" alt="无梦令碑" /></p>

<p>我连忙走上前去，问道：“上仙，这厢有礼，刚才听到上仙谈及四绝碑，敢问何为四绝碑？”，道士略微沉吟，说道：“所谓四绝，乃重阳祖师画像碑，祖师亲笔《无梦令》碑，以及赵孟頫大小照碑，是也”。说罢，袖手而去，我略一迟疑，道士已仙踪不见。</p>

<p>我又走回遇仙碑后，将《九阴真经》默默铭记，出殿时已经是一个时辰之后了，刚到殿门口，忽见之前遇见的那位道士正在门口徘徊，似乎在找什么东西。我恭敬的询问，道士一脸疑惑，操着一口地道的关中腔说道：“我的手机咋莫见啦？我记得我拿出来了么，可放到办公室里了？”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图书封面故事]]></title>
    <link href="http://abruzzi.github.com/2013/04/book-cover-story/"/>
    <updated>2013-04-13T15:57:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/04/book-cover-story</id>
    <content type="html"><![CDATA[<h2>虎符</h2>

<p>虎符本是春秋战国时期，用以中央政权和地方军事力量之间的一种凭证，信物。一般分剖为两半，一半留在京师（右半边，古代以右为尊），另一半留在军队驻地。对方上要有军事行动，必须向中央申请，中央同意后，会派遣专人前往，为了防止有人冒充中央，假传圣旨，需要有一种凭证。</p>

<p>当然，仅仅虎符本身并不足以调动军队，同虎符一起的，还要有诏书，及中央排除的特使。虎符作为凭证，而诏书中有详细的其他信息，比如官员的任命，军队部署之类。</p>

<h3>杜虎符</h3>

<p>杜虎符为1973年在西安南郊出土的，年代大约为战国时期，但是应在秦朝统一六国之前。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/jscp-conver.jpg" alt="image" /></p>

<p>铭文为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>兵甲之符，右在君，左在杜，凡兴兵披甲，用五十人以上，必会君符，乃敢行之。燔燧之事，虽毋会符，行。</span></code></pre></td></tr></table></div></figure>


<p>虎符本身为铜铸，铭文的制作非常特殊：先刻以阴文，然后将金丝嵌入文字，再打磨光滑，因此虽历时久远，但是仍金光熠熠。</p>

<h3>阳陵虎符</h3>

<p>阳陵虎符相传在山东临城出土，由于铭文中有“皇帝”字样，时代当为秦统一六国之后。</p>

<p><img src="http://abruzzi.github.com/images/2013/04/yangling-tiger-seal.resized.jpg" alt="image" /></p>

<p>铭文为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>甲兵之符，右在皇帝，左在阳陵</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Turning to a designer]]></title>
    <link href="http://abruzzi.github.com/2013/03/turning-to-a-designer/"/>
    <updated>2013-03-26T22:46:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/03/turning-to-a-designer</id>
    <content type="html"><![CDATA[<h4>Hack design的建议</h4>

<p>首先，design无处不在，它的目的是提高产品使用者的效率和易用性的。它不是一个“运用之妙，存乎一心”的东西，它是一个实实在在可以通过学习来获得的能力（正如编程或者写作或者厨艺一样，当然，如果一个人把精力和心血放在编程上，同样可以将编程做成一个“运用之妙，存乎一心”的东西。）</p>

<p>什么是一个好的设计？下面是设计师Dieter Rams给出的10条原则：</p>

<ol>
<li>创新性</li>
<li>使产品有用</li>
<li>美学</li>
<li>使产品可以被理解</li>
<li>不那么引人注目</li>
<li>诚实的设计</li>
<li>可持久的</li>
<li>彻底，纯粹</li>
<li>尽量做小的设计</li>
<li>环境友好</li>
</ol>


<p><img src="http://abruzzi.github.com/images/2013/03/design-10-commandments.resized.png" alt="image" /></p>

<p>这里有<a href="http://startupsthisishowdesignworks.com/">原文的链接</a>，总而言之，设计不仅仅是一个web页面，一个海报，所有的产品都会有不同程度的设计包含在其中。</p>

<h4>Alex的建议</h4>

<p>想想你觉得“好看”的页面为什么好看，是字体，配色，背景色，布局还是其他？把这些记录下来，并在自己后续的设计中尝试使用。</p>

<p>多看一些优秀的设计，比如web页面，如果你发现上边有一些很感兴趣的特性，或者细节，比如这个菜单看着很漂亮，后者标签功能很炫，你可以用chrome的inspect来查看别人使用了什么样的HTML，又apply了那些CSS，做出了这样的效果。</p>

<p>如果在这个过程中，遇到一些没有见过的标签，或者标签的属性，那么去<a href="http://www.w3schools.com/">w3school</a>上查看一下这些标签/属性的含义，尽量使用这些Tag原始的意义（设计时的初衷）。</p>

<p>比如div，它是divider的缩写，本来是用来分割块的，那么就用它来做分割，比如p(paragraph)标签，用来分段，可以将文字放入其中。这些都是HTML标签的设计初衷，我们应该尽量遵循，在实现的时候，如果使用原始的标签很难实现，那么可以尝试一些比较trick的方式来绕过，但是毕竟并非正途。</p>

<p>最后，design和编程类似，你需要不断的练习，自己动手多尝试，在研究了别人的实现之后，自己最好做一个示例出来。</p>

<h4>其他人的建议</h4>

<p>最近读到的一篇写的<a href="http://somerandomdude.com/2012/01/10/transition-from-development-to-design/">非常好的文章</a>，作者也是一个有开发背景的设计师，因此有很多地方可以借鉴：</p>

<ol>
<li>在转向designer的同时，不要丢掉编程</li>
<li>按照一定的顺序来学习design（可用优先，性能优先）</li>
<li>设计一切见得到的东西</li>
<li>和其他人一起讨论设计，并聆听别人</li>
<li>尝试分享，尝试将自己的设计讲给别人</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Hack day]]></title>
    <link href="http://abruzzi.github.com/2013/03/guan-yu-hack-day/"/>
    <updated>2013-03-22T20:55:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/03/guan-yu-hack-day</id>
    <content type="html"><![CDATA[<h4>关于Hackday</h4>

<p>Hackday是一个技术活动，每三个月举行一次，每次正式时间为两天，每次的hackday都有一个主题，比如对某个业务模块的数据挖掘，关于某个模块的功能/执行效率的改进。</p>

<p>Hackday中的idea多是工作中接触到的痛点，但是又有一些挑战，很难在工作的时候将其完成，或者是一些有意思的主题，平时想做又不太合适（比如一些没有经过确认创新的点子）。</p>

<h4>Hackday 1st</h4>

<p>第一次Hackday是跟<a href="http://adams.co.tt/blog">Adam</a>一起做一个数据展现的idea，Adam是墨尔本Office里一个相当senior的咨询师，我们当时做的idea是根据系统中已有的数据信息，来做一些简单的数据分析，如：</p>

<ol>
<li>找出一个地区内的所有中介，看看哪些中介持有最多的房产资料</li>
<li>找出一个地区中，可以最快卖掉手中房产的中介</li>
</ol>


<p><img src="http://abruzzi.github.com/images/2013/03/hackday-agent-info.resized.png" alt="image" /></p>

<p>我们的应用使用sinatra作为服务器；由于数据库系统已经存在，所以ORM需要做的是将对象和已存在的数据表关联，因此功能强大且可以独立使用的ActiveRecord就成了首选；模板使用haml；UI框架风格使用了BootStrap。</p>

<p>搭建环境大概只用了1到1.5个小时，在整个开发过程中，我学习到了一个专业的敏捷开发的流程：</p>

<ol>
<li>划分大的目标，使之称为小的task</li>
<li>小步前进，做完一个功能之后，进行快速的review（首先有一个可以工作的版本）</li>
<li>如果发现有潜在的问题，进行重构，以方便下一个小的task</li>
</ol>


<p>两天之后，当一个可以工作，并且很容易扩展的应用程序真实的放在我们面前的时候，我觉得十分有意思，这当然不是因为build something本身的乐趣，而是我看到一种理论在实际的生活中可以工作（而且是以一种非常有意思的方式），这个过程让我对这种开发方式产生了很多新的认识。</p>

<h4>Hackday 2nd</h4>

<p>第二次的idea是一个基于google map的应用，比如某人的公司在A地，老婆的公司在B地，他们最喜欢的超市在C地，然后他们想找一个离这三个地方距离都很近的房子。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/hackday-neighborhood.resized.png" alt="image" /></p>

<p>同样也使用了Sinatra+haml+javascript。由于idea本身就是西安团队想出来的，所以这次的参与者都是西安office的，这样可以省去交流的成本，做起来肯快，但是问题也很严重，就是没有人做演示，别的团队也不清楚我们在干什么。</p>

<h4>Hackday 3rd</h4>

<p>经历了前两次，第三次的就非常official了，有story wall，有producer，有站会，有showcase，正好这段时间我们的一个客户designer在西安office出差，所以还设计了一些海报。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/hackday-rango-stories.resized.png" alt="image" /></p>

<p>有了专业的designer参与，应用程序的外观立马得到了改善，看起来非常有产品的感觉：</p>

<p><img src="http://abruzzi.github.com/images/2013/03/hackday-rango-homepage.resized.png" alt="image" /></p>

<p>这次本来计划开发离线版本，使用浏览器的localStorage，但是静态网页在iPad上无法工作。team快速的做出了调整，使用sinatra（又一次）搭建了服务器，然后将应用部署在cloud上。</p>

<h4>总结</h4>

<p>虽然每次的“成果”都不大，但是整个hack的过程都非常有意思，每次都可以使用前几次活动中好的工作方式，而前几次中做的不好的则可以进行改进，技术仅仅是其中的一个方面，与团队成员的协作，对自己信心的加强，通过创新来给客户带来价值，这一系列的，不那么明显的“成果”才是更重要的。</p>

<p>另一个“成果”是，我对轻量级的框架如<a href="http://www.sinatrarb.com/">sinatra</a>，引擎<a href="http://haml.info/">haml</a>等有了非常浓厚的兴趣，用这些工具可以快速的搭建用于showcase的应用程序，而且非常容易改进，非常适合小步迭代的开发方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cycling]]></title>
    <link href="http://abruzzi.github.com/2013/03/cycling/"/>
    <updated>2013-03-10T15:34:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/03/cycling</id>
    <content type="html"><![CDATA[<h3>昆明骑行</h3>

<h4>首次骑行</h4>

<p>从城西出发，骑到城北长虫山，到龙凤公墓集合，然后沿着小哨，大哨，最后从金殿后山返回。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-1st.resized.jpg" alt="image" /></p>

<p>整个路线大概80公里，山中时而风雨大作，时而阳光遍地，依稀记得中午休息时，山里某个农家乐里的带皮羊肉火锅滋味鲜美无比。</p>

<h4>东大花椒鸡</h4>

<p>云青青兮欲雨，水澹澹兮生烟。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-dongda-2.resized.jpg" alt="image" /></p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-dongda-chicken.resized.jpg" alt="image" /></p>

<h4>夜骑宝珠寺</h4>

<p>宝珠寺在昆明城西，寺在山脚下，整个骑行路线全是上坡，而且有好几公里的坡度巨大，算是一个骑行初级班和进阶班的分水岭。事实上，和同事骑行宝珠寺，从来没有去看过“宝珠寺”本身。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-baozhu.resized.jpg" alt="image" /></p>

<p>宝珠寺山顶附近有了泉，有很多人开车去山上打泉水。我们曾用脉动的瓶子装了些，但是终于没有敢喝。在夜间骑行感觉非常诡异，山中非常黑，只有一条灰白色的公路，偶尔有车子开过，会有一点光闪过，由于坡度非常陡峭，可以听到头顶上有下坡朋友在单车上高声呼啸而过。骑到高处，俯瞰城市，山坳里的昆明城尽收眼底。</p>

<p>从山上起下来之后，去城西的烧烤摊上点一些酒肉，和朋友们扯扯淡，然后再沿着空旷的街道返回。</p>

<h4>卧云山</h4>

<p>从宝珠寺顶一直往西北，过了筇竹寺，然后一路往西，骑到卧云山下吃午饭，貌似每个地方的花椒鸡都各有特色，这种蘸着花椒蘸水的吃饭比东大的好吃一些：</p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-woyun-chicken.resized.jpg" alt="image" /></p>

<p>到达卧云山顶，小转盘附近：</p>

<p><img src="http://abruzzi.github.com/images/2013/03/kunming-cycling-woyun.resized.jpg" alt="image" /></p>

<h3>西安骑行</h3>

<h4>沣峪口</h4>

<p>毫无疑问，西安骑行的经历是最糟糕的了：第一次是从南三环，沿太白南路往北，骑到老城墙，穿城而过，然后到北二环，再从城北骑回来；第二次路线和第一次差不多，不过是跟孙曼思一起，而且是和不过骑得更远，到了草滩附近；第三次是往南，跟孙曼思，还有三个同事，骑行沣峪口，恰遇极为严重的沙尘暴，当时PM2.5已经过千。</p>

<p><img src="http://abruzzi.github.com/images/2013/03/xian-cycling-3rd.resized.jpg" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
