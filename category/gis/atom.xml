<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GIS | I code it]]></title>
  <link href="http://abruzzi.github.com/category/gis/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2015-09-19T01:05:39+10:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[可视化你的足迹]]></title>
    <link href="http://abruzzi.github.com/2015/09/visualize-your-steps/"/>
    <updated>2015-09-18T13:36:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/09/visualize-your-steps</id>
    <content type="html"><![CDATA[<h3>可视化你的足迹</h3>

<p>数据可视化可以让读者以一种轻松的方式来消费数据，人类大脑在处理图形的速度是处理文本的<code>66,000</code>倍，这也是人们常常说的<code>一图胜千言</code>。在本文中，我们通过将日常中很容易收集到的数据，通过一系列的处理，并最终展现在地图上。这仅仅是GIS的一个很简单场景，但是我们可以看到，当空间数据和地图结合在一起时，可以在可视化上得到很好的效果，读者可以很容易从中获取信息。</p>

<p><img src="/images/2015/09/viz-steps-resized.png" alt="steps" /></p>

<p>我们在本文中会制作一个这样的地图，图中灰色的线是城市中的道路，小六边形表示照片拍摄地。颜色表示当时当地拍摄照片的密度，红色表示密集，黄色为稀疏。可以看到，我的活动区域主要集中在左下角，那是公司所在地和我的住处，:)</p>

<p>要展现数据，首先需要采集数据，不过这些已经在日常生活中被不自觉的被记录下来了：</p>

<h4>数据来源</h4>

<p>如果你开启了iPhone相机中的定位功能，拍照的时候，iPhone会自动把当前的地理信息写入到图片的元数据中，这样我们就可以使用这些数据来做进一步的分析了。</p>

<p>我在去年学习OpenLayers的时候已经玩过一些简单的<a href="http://icodeit.org/placesihavebeen">足迹可视化</a>，另外还有一篇<a href="http://www.infoq.com/cn/articles/visualization-of-the-global-seismic-system">全球地震信息的可视化</a>，但是仅仅是展示矢量信息，并没有深入，而且都是一些前端的JavaScript的代码。最近又在重新整理之前的GIS知识，重新把这个作为例子来练手。当然，这次会涉及一些<strong>地图编辑</strong>，<strong>空间计算</strong>的内容。</p>

<p>我的照片一般都通过Mac自带的Photos管理（前身iPhoto），手机里照片会定期同步上去。老版本的iPhoto用的是XML文件来存储照片的<a href="https://en.wikipedia.org/wiki/Exchangeable_image_file_format">EXIF数据</a>，新的Photos的实现里，数据被存储在了好几个SQLite数据库文件中，不过问题不大，我们只需要写一点Ruby代码就可以将数据转化为标准格式，这里使用GeoJSON，GeoJSON既可以方便人类阅读，也可以很方便的导入到PostGIS或者直接在客户端展现。</p>

<h3>实现步骤</h3>

<p>我们现在要绘制照片拍摄的密度图，大概需要这样一些步骤：</p>

<ol>
<li>抽取照片的EXIF信息（经度，纬度，创建时间等）</li>
<li>编写脚本将抽取出来的信息转换成通用格式（GeoJSON）</li>
<li>使用QGIS将这些点的集合导入为图层</li>
<li>插入一些由六边形组成的图层（设置合适的大小）</li>
<li>计算落在各个多边形中的点的个数，并生成新的图层heatmap</li>
<li>使用MapServer来渲染基本地图</li>
</ol>


<h4>数据抽取</h4>

<p>Mac上的Photos会将照片的元数据存储在一个SQLite3格式的数据库中，文件名为<code>Library.apdb</code>，通常位于这个位置<code>~/Pictures/Photos\ Library.photoslibrary/Database/apdb/Library.apdb</code>。这个文件可以通过<code>SQLite3</code>的客户端直接打开，不过由于可能有其他进程（Mac自己的）打开了该文件，所以会有锁文件，你可能需要先将这个文件拷贝到另外一个位置。</p>

<p>然后将表<code>RKVersion</code>中的部分信息导出即可，SQLite内置了很方便的导出功能，通过它提供的shell客户端<code>sqlite3</code>，将信息导出到csv文件中：</p>

<p><code>sh
sqlite&gt; .mode csv
sqlite&gt; .headers on
sqlite&gt; .output places-ive-been.csv
sqlite&gt; select datetime(imageDate+978307200, 'unixepoch', 'localtime') as imageDate, exifLatitude, exifLongitude from RKVersion where exifLatitude and exiflongitude;
sqlite&gt; .output stdout
</code></p>

<p>注意这里的日期，苹果的日期偏移和其他公司不同，始于2001年1月1日，所以要在<code>imageDate</code>之后加上这个<code>base</code>值，然后将文件以<code>.csv</code>的格式导出到<code>places-ive-been.csv</code>中，该文件包含3列：时间，纬度，精度。</p>

<p><code>sh
imageDate,exifLatitude,exifLongitude
"2012-10-25 16:34:01",34.19216667,108.87316667
"2012-10-28 14:45:53",35.1795,109.9275
"2012-10-28 14:45:45",35.1795,109.9275
"2012-10-25 16:34:04",34.19216667,108.87316667
"2012-10-19 23:01:05",34.19833333,108.86733333
...
</code></p>

<h4>转换为GeoJSON</h4>

<p>方便以后的转换起见，我们将这个文件转换成<code>GeoJSON</code>（其实很多客户端工具可以支持CSV的导入，不过<code>GeoJSON</code>更为标准一些）。</p>

<p>```ruby
require 'csv'
require 'json'</p>

<p>lines = CSV.open("places-ive-been.csv").readlines
keys = lines.delete lines.first</p>

<p>File.open("places-ive-been.json", 'w') do |f|</p>

<pre><code>data = lines.map do |row|
    {
        :type =&gt; "Feature",
        :geometry =&gt; {
          :type =&gt; "Point",
          :coordinates =&gt; [row[2].to_f, row[1].to_f]
        },
        :properties =&gt; {
          :created_at =&gt; row[0]
        }
    }
end

f.puts JSON.pretty_generate({
    :type =&gt; "FeatureCollection",
    :crs =&gt; {
      :type =&gt; "name",
      :properties =&gt; {
        :name =&gt; "EPSG:4326"
      }
    },
    :features =&gt; data
})
</code></pre>

<p>end
```</p>

<p>这段脚本可以将我们的<code>.csv</code>转换成标准的<code>geojson</code>格式，注意此处的空间投影使用的是<code>EPSG:4326</code>。</p>

<h4>导入为QGIS图层</h4>

<p><a href="http://www.qgis.org/en/site/">QGIS</a>是一个开源的GIS套件，包括桌面端的编辑器和服务器端，这里我们只是用器桌面端来进行图层的编辑。</p>

<p>将我们的<code>GeoJSON</code>导入之后，会看到这样的一个可视化的效果！</p>

<p><img src="/images/2015/09/points-resized.png" alt="points" /></p>

<p>我们还可以导入其他的地图图层，这样可以清楚的看到点所在的区域（国家地图图层可以在<a href="http://www.naturalearthdata.com/">此处下载</a>）：</p>

<p><img src="/images/2015/09/points-countries-resized.png" alt="points with countries" /></p>

<p>好了，有了基础数据之后，我们来作进一步的数据分析 -- 即生成密度图。首先使用QGIS的插件<code>MMQGIS</code>的<strong>生成多边形图层</strong>功能(Create -> Create Grid Layer)，为了处理速度，我们可以将地图放大到一定范围（我选择西安市，我在这里活动比较密集）。</p>

<p>选择六边形<code>hexagon</code>，并设置合适的大小（如果是<code>3857</code>参考系，即按照公里数来设置，会比较容易一些，如果是4326，则需要自己计算）。简而言之，需要保证每个格子都包含一些点，不至于太密，也不至于太稀疏。</p>

<p><img src="/images/2015/09/hexagon-resized.png" alt="hexagon" /></p>

<h4>计算密度</h4>

<p>QGIS提供了很多的数据分析功能，我们在这个例子中使用（Vector -> Analysis Tools -> Points in Polygon）工具，这个工具需要两个图层，一个是点集图层，一个是多边形图层。然后会将结果生成到一个新的图层中，我们可以将其命名为<code>places-ive-been-density.shp</code>，同时需要指定一个字段来存储统计出来的值（density）。</p>

<p>这个过程可能会花费一点时间，根据需要计算的点集合多边形的格式（也就是地图上的区域）。</p>

<p>完成之后会得到一个<code>Shapefile</code>（其实是一组，具体可以<a href="https://en.wikipedia.org/wiki/Shapefile">参看这里</a>）。其实在这个过程中，绝大多数多边形是不包含任何数据的，我们需要过滤掉这些多余的多边形，这样可以缩减绘制地图的时间。</p>

<p>我们可以将这个文件导入到PostGIS中进行简化：</p>

<p><code>sh
shp2pgsql -I -s 4326 data/places-ive-been/places-ive-been-3857-density.shp places_density |\
PGUSER=gis PGPASSWORD=gis  psql -h localhost -d playground
</code></p>

<p>这里的<code>shp2pgsql</code>命令是<a href="http://">GDAL工具包</a>提供的命令，用以将<code>Shapefile</code>导入到<code>PostGIS</code>中，你可以通过</p>

<p><code>sh
$ brew install gdal --with-postgresql
</code></p>

<p>来安装。</p>

<p>GDAL会提供很多的工具，比如用来转换各种数据格式，投影，查看信息等等。</p>

<p>导入之后，我们可以在PostGIS的客户端查看，编辑这些数据等。比如在过滤之前，</p>

<p><code>sql
select count(*) from places_density;
</code></p>

<p>我们导入的数据中有<code>103166</code>条记录：</p>

<p><code>sql
select count(*) from places_density where density IS NOT NULL;
</code></p>

<p>而过滤之后，我们仅剩下<code>749</code>条数据。</p>

<p>通过GDAL提供的另一个工具<code>ogr2ogr</code>可以方便的执行过滤，并生成新的<code>Shapefile</code>:</p>

<p><code>sh
$ ogr2ogr -f "ESRI Shapefile" data/places-ive-been/places_heatmap.shp \
PG:"host=localhost user=gis dbname=playground pass
word=gis" \
-sql "SELECT density, geom FROM places_density WHERE density IS NOT NULL;"
</code></p>

<p>这条命令可以得到一个新的文件，这个就是最终的用来绘制地图的文件了。</p>

<h4>绘制地图</h4>

<p>开源世界中有很多的工具可以完成地图的绘制，比如<a href="http://mapserver.org/">MapServer</a>，<a href="http://geoserver.org/">GeoServer</a>，<a href="http://mapnik.org/">Mapnik</a>等等。我们在这篇文章中使用MapServer来完成地图的绘制，MapServer的安装和配置虽然比较容易，但是也需要花费一些时间，所以我将其放到了<a href="https://github.com/abruzzi/mapserver-box">这个repo中</a>，你可以直接clone下来使用。（需要你在虚拟机中安装ansible来完成provision）。</p>

<p>MapServer的配置很简单，类似于一个XML，不过是自定义的格式：</p>

<p>```
MAP
  IMAGETYPE      PNG
  EXTENT         11859978.732852 3994742.227345 12753503.595559 4580388.268737
  SIZE           8000 6000
  SHAPEPATH      "/data/heatmap"
  IMAGECOLOR     255 255 255</p>

<p>  PROJECTION</p>

<pre><code>"init=epsg:3857"   ##required
</code></pre>

<p>  END</p>

<p>  LAYER # States polygon layer begins here</p>

<pre><code>NAME         heatmap
DATA         heatmap_3857
STATUS       default
TYPE         POLYGON

CLASS
  NAME "basic"
  STYLE
    COLOR        255 255 178
    OUTLINECOLOR 255 255 178
  END
END
</code></pre>

<p>  END</p>

<p>END
```</p>

<p>这些配置基本上都比较自解释，比如设置图片格式，图片大小，Shapefile的路径，图层的名称等，<strong>MapServer的文档在开源软件中来说，都算比较烂的</strong>，但是对于这些基本概念的解释还比较详尽，大家可以<a href="http://mapserver.org/documentation.html#documentation">去这里参考</a>。</p>

<p>这里我们定义了一个图层，每个Map中可以定义多个图层（我们完成的最终效果图就是西安市的道路图和照片拍摄密度图两个图层的叠加）。</p>

<p>这个配置绘制出来的地图是没有颜色差异的，全部都是<code>255 255 178</code>。不过MapServer的配置提供了很好的样式定义，比如我们可以定义这样的一些规则：</p>

<ol>
<li>如果密度为1，则设置颜色为淡黄</li>
<li>如果密度在1-2,则设置为比淡黄红一点的颜色</li>
<li>以此类推</li>
</ol>


<p>```
  LAYER</p>

<pre><code>NAME         heatmap
DATA         heatmap_3857
STATUS       default
TYPE         POLYGON
#CLASSITEM density

CLASS
  EXPRESSION ([density] = 1)
  STYLE
    COLOR        255 255 178
    OUTLINECOLOR 255 255 178
  END
END

CLASS
  EXPRESSION ([density] &gt; 1 AND [density] &lt;= 2)
  STYLE
    COLOR        254 204 92
    OUTLINECOLOR 254 204 92
  END
END

CLASS
  EXPRESSION ([density] &gt; 2 AND [density] &lt;= 3)
  STYLE
    COLOR        253 141 60
    OUTLINECOLOR 253 141 60
  END
END

CLASS
  EXPRESSION ([density] &gt; 3 AND [density] &lt;= 10)
  STYLE
    COLOR        240 59 32
    OUTLINECOLOR 240 59 32
  END
END

CLASS
  EXPRESSION ([density] &gt; 10 AND [density] &lt; 3438)
  STYLE
    COLOR        189 0 38
    OUTLINECOLOR 189 0 38
  END
END
</code></pre>

<p>  END
```</p>

<p>这样我们的地图展现出来就会比较有层次感，而且通过颜色的加深，也能体现<code>热图</code>本身的含义。</p>

<p>同样的原理，如果将那些自己创建的多边形替换为行政区域划分的多边形，则可以得到另外一种形式的<code>热图</code>：</p>

<p><img src="/images/2015/09/heatmap-in-shaanxi-resized.png" alt="shaanxi-heatmap" /></p>

<h3>总结</h3>

<p>我们通过使用一些开源工具（MapServer，QGis，PostGIS，GDAL等），构建出一个基于GIS的数据可视化框架。在这个stack上，我们可以很容易的将一些其他数据也通过可视化的方式展现出来（公用自行车站点分布，出租车分布等等）。MapServer可以发布标准的WMS服务，因此可以很好的和客户端框架集成，从而带来更加友好的用户体验。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建地图服务器（使用Mapnik）]]></title>
    <link href="http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik/"/>
    <updated>2014-04-12T14:07:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik</id>
    <content type="html"><![CDATA[<h4>渲染引擎Mapnik</h4>

<p><a href="http://icodeit.org/2014/04/intro-map-gis/">上一篇文章</a>中大概介绍了<a href="https://github.com/mapnik">Mapnik</a>，它是一个渲染引擎，一般开发中都会使用他的python的bind做开发。</p>

<p>Mapnik的文档写的比较详细，我们这里只是做一些必要的介绍，详细的细节可以参看Mapnik在<a href="https://github.com/mapnik/mapnik/wiki">Github上的文档</a>。</p>

<p>在Mac下，安装Mapnik十分容易，使用brew即可，注意我们在此处带上<code>--with-postgresql</code>选项，使得Mapnik可以通过PostGIS来访问数据库：</p>

<p><code>sh
brew install mapnik --with-postgresql
</code></p>

<p>安装完成之后，可以通过一个小的python脚本来测试：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(256, 256)
map.background = mapnik.Color('red')
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'red.png', 'png')
```</p>

<p>这段脚本可以在当前目录下生成一个红色的256x256的小图片。好了，有了渲染引擎，我们需要一些数据来进行渲染了。</p>

<h4>数据源</h4>

<p>最通用的数据格式为Shapefiles，目前有很多的免费地理信息供公共下载，我们可以从<a href="http://metro.teczno.com/">Metro的站点</a>上下载一些小的数据文件。</p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm2pgsql-shapefiles.zip
$ mkdir chengdu
$ cd chengdu
$ unzip chengdu.osm2pgsql-shapefiles.zip
</code>
这样就得到了一组文件：</p>

<p><code>
$ find . -name "*.shp"
./chengdu.osm-line.shp
./chengdu.osm-point.shp
./chengdu.osm-polygon.shp
</code></p>

<p>每一个shp文件都会对应几个其他类型的文件，比如投影信息，属性表等。仅仅查看shp的话，有表示所有点的文件chengdu.osm-line.shp，又表示所有线的chengdu.osm-line.shp，以及表示所有面（区域）的chengdu.osm-polygon.shp文件。</p>

<p>有了这些文件，我们就可以做一些测试了，比如我们首先加载所有的线条，并根据这些线条生成一个图层：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(800, 800)
map.background = mapnik.Color('#ffffff')</p>

<p>style = mapnik.Style()
rule = mapnik.Rule()</p>

<p>point_symbolizer = mapnik.PointSymbolizer()
rule.symbols.append(point_symbolizer)</p>

<p>style.rules.append(rule)</p>

<p>map.append_style('default', style)</p>

<p>ds_point = mapnik.Shapefile(file='chengdu.osm-point.shp')
point = mapnik.Layer('point')
point.datasource = ds_point
point.styles.append('default')</p>

<p>map.layers.append(point)
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'chengdu.png', 'png')
```</p>

<p>可以得到：</p>

<p><img src="/images/2014/04/chengdu-point.png" alt="points" /></p>

<p>这里介绍一下Mapnik中的一些概念：一个Map可以包含若干个层（Layer），每个层可以独立着色，即可以为每个层定制样式（Style），每个样式由若干个规则组成（Rule）。每个规则由是由若干个符号定制。</p>

<p><img src="/images/2014/04/chengdu-line.png" alt="lines" /></p>

<p>如果将两者重叠，则可以得到：</p>

<p><img src="/images/2014/04/chengdu-point-and-line.png" alt="lines" /></p>

<p>```python
polygon_symbolizer = mapnik.PolygonSymbolizer(mapnik.Color('#c8102e'))
polygon_rule.symbols.append(polygon_symbolizer)</p>

<p>ds_polygon = mapnik.Shapefile(file='chengdu.osm-polygon.shp')
polygon = mapnik.Layer('polygon')
polygon.datasource = ds_polygon
polygon.styles.append('polygon')</p>

<p>map.layers.append(polygon)
```</p>

<p><img src="/images/2014/04/chengdu-polygon.png" alt="image" /></p>

<p>将这三个层叠加在一起，会得到最终的结果：</p>

<p><img src="/images/2014/04/chengdu-point-and-line-and-polygon.png" alt="lines" /></p>

<h4>数据转化</h4>

<p>在进一步之前，我们需要将数据存储在数据库中。我们可以将shapefile通过转化存入到数据库中。PostGIS本身自带了一个用于此作用的工具：<code>shp2pgsql</code>。可以通过这个工具来先将shapefile导入到数据库中。也可以直接导入别的开放数据，比如很多OSM格式的数据源，我们此处仅仅简单的从别的数据源将OSM格式的数据下载并导入到PostGIS中。</p>

<p>创建数据库<code>chengdu</code>:</p>

<p>```sh
$ createdb chengdu -O gis -E UTF8 -e
CREATE DATABASE chengdu OWNER gis ENCODING 'UTF8';</p>

<p>$ psql -U gis -d chengdu
```</p>

<p>登陆PostGres，然后为数据库<code>chengdu</code>启动PostGIS扩展：</p>

<p><code>sql
-- Enable PostGIS (includes raster)
CREATE EXTENSION postgis;
-- Enable Topology
CREATE EXTENSION postgis_topology;
-- fuzzy matching needed for Tiger
CREATE EXTENSION fuzzystrmatch;
-- Enable US Tiger Geocoder
CREATE EXTENSION postgis_tiger_geocoder;
</code></p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm.bz2
$ bunzip2 -d chengdu.osm.bz2
$ osm2pgsql -U gis -d chengdu -s -S ./default.style chengdu.osm
</code></p>

<p>这个命令将chengdu.osm导入到了名称为<code>chengdu</code>的数据库中。</p>

<p>可以通过SQL命令查看其中的数据：</p>

<p><code>sql
select ST_Extent(ST_Transform(way,4326)) from planet_osm_roads;
</code></p>

<p>结果如下：</p>

<p>```</p>

<pre><code>                            st_extent                                 
</code></pre>

<hr />

<p> BOX(103.564165069794 30.3634139134986,104.554549945024 30.9869936005376)
(1 row)
```</p>

<h4>WMS服务器</h4>

<p>生成图片之后，我们还需要将这些图片切成瓦片，然后公开给外部以便使用。Mapnik提供了切图的功能，并且还提供一个实现了<a href="https://github.com/mapnik/OGCServer">WMS协议的服务器</a>，以便使用。</p>

<p>安装这个OGCServer服务器非常容易：</p>

<p><code>sh
$ git clone git@github.com:mapnik/OGCServer.git
$ cd OGCServer
$ sudo python setup.py install
</code></p>

<p>但是OGCServer的启动，需要一个配置XML配置文件，这个配置文件可以由Mapnik提供的工具集生成：</p>

<p><code>sh
$ svn co http://svn.openstreetmap.org/applications/rendering/mapnik/
</code></p>

<p>这个svn仓库中包含了众多的小工具，generate_xml.py用于生成Mapnik的样式文件，generate_image.py用于生成图片，generate_tiles.py用于生成众多的瓦片。</p>

<p>此处我们将使用<code>generate_xml.py</code>来创建一个地图样式文件，</p>

<p><code>sh
$ cd svn.openstreetmap.org/applications/rendering/mapnik/
$ ./generate_xml.py osm.xml chengdu.xml --dbname chengdu --user gis --accept-none
</code></p>

<p>generate_xml.py根据osm.xml作为模板，生成<code>chengdu.xml</code>。这个文件即可用于测试OGCServer：</p>

<p><code>sh
$ OGCServer chengdu.xml
Listening at 0.0.0.0:8000....
</code></p>

<p>然后在浏览器中查看：</p>

<p><img src="/images/2014/04/ogcserver-localhost-resized.png" alt="ogcserver" /></p>

<h4>使用OpenLayers测试</h4>

<p>有了一张图片，那么我们就需要有更多的图片组成的瓦片，这就需要使用引入GIS的前端利器OpenLayers了：</p>

<p>```
$(function() {</p>

<pre><code>var map, layer;
map = new OpenLayers.Map('map', {});

layer = new OpenLayers.Layer.WMS('Tile Cache', 
    'http://localhost:8000/?', {
        layers: '__all__',
        format: 'image/png'
    });

map.addLayer(layer);

if (!map.getCenter()) {
    map.zoomToMaxExtent();
}
</code></pre>

<p>});
```</p>

<p><img src="/images/2014/04/openlayers-chengdu-resized.png" alt="openlayers" /></p>

<p><img src="/images/2014/04/openlayers-chengdu-detail-resized.png" alt="openlayers" /></p>

<p>应该注意的是，此处在OpenLayers中使用了来自与OSM导入的数据，而并非Shapefile中的数据（Shapefile中仅有三个层次，point, line, polygon）。而OSM的数据则丰富的多。</p>
]]></content>
  </entry>
  
</feed>
