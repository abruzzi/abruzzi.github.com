<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2015-06-15T17:15:00+10:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我们真的缺前端工程师吗？]]></title>
    <link href="http://abruzzi.github.com/2015/06/do-we-really-short-for-front-end-developer/"/>
    <updated>2015-06-14T23:33:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/06/do-we-really-short-for-front-end-developer</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>这两天在好几个地方都看到了一篇关于<a href="http://chuansong.me/n/1369941">为什么整个互联网行业都缺前端工程师？</a>的文章，文章本身是去年的，中心思想是：其实我们并不缺前端工程师，我们缺的是优秀的前端工程师。我还是比较同意作者观点的，不过略有意犹未尽的感觉。于是我结合自己的经验，也来聊一下这个话题：<strong>我们真的缺前端工程师吗？</strong></p>

<p><code>
These walls are kind of funny like that. First you hate them, then you get used to them.Enough time passed, get so you depend on them. That’s institutionalising.
</code></p>

<p>传统软件公司划分开发者的方式下，在前端部门的程序员永远不会去读缓存数据部分的代码，设计师也不太可能去和开发坐在一起，开发也不知道软件最终软件会以何种方式部署在服务器上。</p>

<h3>什么是前端工程师</h3>

<p>我在招聘广告和办公室的一些对话中，听到了一个新的角色：UI Dev，事实上我在知乎上还回答过一个<a href="http://www.zhihu.com/question/30170650">关于ThoughtWorks的UI Dev的问题</a>。简而言之，UI Dev可以快速的把设计师的作品实现为HTML/CSS/JavaScript代码。</p>

<p><img src="/images/2015/06/website-development-resized.png" alt="front-end development" /></p>

<p>如果按照这个标准，我觉得UI Dev对自己的要求太低了。毕竟要学会HTML/CSS实现mockup并不困难，但是成为一名前端工程师则需要掌握更多的知识：</p>

<ul>
<li>会用PS来进行图片的处理（比如切图，微调等）</li>
<li>用HTML/CSS实现mockup（可能还有<a href="http://sass-lang.com/">SASS</a>/<a href="http://lesscss.org/">LESS</a>等工具）</li>
<li>熟悉JavaScript（比如前端的MVVM框架，客户端模板）</li>
<li>前端开发的工作流程（代码检查，精简化，模块化CSS，LiveReload，调试）</li>
<li>编写测试（静态检查，单元测试）</li>
<li>跨浏览器、跨设备的解决方法（不同分辨率，不同厂商）</li>
<li>会根据项目的特点选择不同的前端技术栈（移动端，Web站点，响应式设计等）</li>
</ul>


<p>在有了基础的HTML/CSS/JS技能之后，你会尝试做的更好：</p>

<ul>
<li>如何更高效的操作DOM</li>
<li>如何将CSS写的更加清晰易懂</li>
<li>如何编写更加易于维护的代码（更有意义的单元测试）</li>
<li>如何组织大型的项目结构，模块化，组件化等等</li>
</ul>


<p>这些要求事实上已经不那么容易做到了。它可能会花费你2到3年时间来完全掌握。但是2到3年之后，即便你已经成为了一个“合格的”前端工程师，这也还远远不够。在现实世界中，一个软件产品除了前端，还有非常广阔的空间，还有很多有趣的东西值得学习：</p>

<ul>
<li>HTTP协议本身（缓存，鉴权）</li>
<li>Web容器/HTTP服务器如何工作</li>
<li>无状态的Web应用的工作原理（如何让网站正确地运行在集群上）</li>
<li>动态，静态内容如何分离部署（反向代理配置）</li>
<li>安全机制如何配置</li>
<li>监控机制如何配置</li>
</ul>


<p>有了这些，也算是有点端到端的意思了。这时你也已经不是一个纯前端工程师了，系统中的大部分问题你都可以搞定，不过日常工作中可能更多的职责还是做前端的开发。但是这些还不够，软件除了交付之外，还有一些非功能性的需求：</p>

<ul>
<li>端到端测试（UI测试，比如<a href="http://www.seleniumhq.org/">selenium server</a>/web driver）</li>
<li>devops（比如数据库环境，测试服务器，CI服务器的自动化provision）</li>
<li>基本的UI设计原则（在某些页面确实的情况下，根据系统的已有UI做设计）</li>
<li>数据库性能优化</li>
<li>性能测试</li>
</ul>


<p><del>不过这些还只是我对于Web开发这个领域的总结。其他领域，比如大数据，机器学习，GIS，图像/视频处理等等。</del></p>

<p>这时候你看起来已经是一个全栈工程师了。最起码，你可以说你对软件开发中的大部分机制是如何工作的有了基本的了解。但是我想这离一个优秀的工程师还是有<strong>很大差距</strong>的。</p>

<p>我跟一位<a href="http://www.caicaiwan.com/">设计师同事</a>聊过这个问题：</p>

<p><code>
Dev眼中的世界是这样的，从墙上（物理的或者电子的）上找到一些卡片（story卡或者需求文档说明书），然后撸袖子开干，干的过程中有很多自以为是的理解，同样有一些自以为是的牛逼实践（TDD啊，自动化啊），最后功能做完，大功告成，然后接着做下一个卡片。传统的Dev，或者苦逼屌丝程序员的世界就是这样的：需求从哪儿来，不知道；做完之后谁来负责质量，不知道；最终上线的时候怎么发布，不知道；线上有问题了怎么办，不知道。
</code></p>

<p>以及</p>

<p><code>
在ThoughtWorks，Dev的工作有了很大的变化，一个最明显的变化是边界的模糊。比如很多项目都不设QA角色，所有人都对质量负责，都做测试，也有OPs角色，但是大部分非生产环境都是Dev自己发布。也就是说，软件/项目生命周期中的大部分实践我们都能涉足，而且可以带来改进，提升效率。但是这只是往下游（从开发，到测试，到部署，到运维），反过来看上游，比如需求从哪儿来，Dev还是不知道。这毫无疑问是一个令人沮丧的事实，因为这需求的产生才是核心，也就是我昨天跟你聊的：一个idea如何变成一个可视化的原型，然后进一步演进为项目原型？
</code></p>

<p>开发工作不应该仅仅局限在编码上，作为开发者/工程师，应该尽可能的多了解一些上下文：比如我们的项目最终是给谁用的，需求从何而来，项目是如何部署在线上的等等。</p>

<p><img src="/images/2015/06/software-life-cycle-resized.png" alt="software life cycle" /></p>

<p>简而言之，开发者视野应该放开开阔一些。不要将自己局限在某种角色上，不但不要局限在前端/后端开发上，压根就不要局限在开发这种角色本身上，你在系统中，可以是设计师，还可以是业务分析师。虽然不一定最终要你去转行做BA，或者UX，但是更广阔的视野可以使你更加高效的发挥自己的作用，也可以在和别的角色互动式，快速的了解上下文。</p>

<p>我所理解的，前端不一定要熟知所有这些知识和技能，但是<strong>一定不要认为自己做好了前端的一亩三分地就足够了</strong>，不要给自己设限。跨界会给你带来难以估量的好处，一个角色做久了，难免会产生一些盲点。这时候，换个视角，从其他角色的角度来看待你的工作，又会有很多新的发现。而且不仅如此，很可能你会发现之前很麻烦，很难搞定的事情，在新的方法/视角下变得很容易。</p>

<p>在ThoughtWorks，经常可以遇到非常优秀的跨界人才：比如做出心声（一个帮助聋哑人打电话的软件）的<a href="http://xuexiao.me">朱晨</a>，他的主要角色是用户体验设计师，为了开发心声这个软件专门学习了如何开发；比如西安办公室的大牛何飞，在学完了我上边提到Web领域的绝大部分技能之后，又开始学习各种底层算法；比如UX王倩蕾，<a href="http://www.caicaiwan.com/">唐婉莹</a>，也在积极的学习前端开发；同样UX角色的<a href="http://">刘海生</a>，又在向BA角色进发。</p>

<p>我是一个Dev，但是花了一些时间来学习界面设计，这里是我从设计到实现的两个小页面：</p>

<p><img src="/images/2015/06/ilearn-resized.png" alt="ilearn" /></p>

<p><img src="/images/2015/06/lightweight-resized.png" alt="lightweight" /></p>

<h3>我的故事</h3>

<h4>其实，我是一名后端开发</h4>

<p>工作之后，我在很长一段时间是专注于“非前端”的领域。和很多刚入行的新人一样，我对计算机能触及的几乎一切领域都感兴趣：语言解释器，人工智能（遗传算法，隐式马尔科夫模型，自动纠错，模式识别），嵌入式开发，图形处理，操作系统的进程调度，进程间通信，多线程模型，各种脚本语言（python，ruby，JavaScript等等），另外，日常开发流程中的一些工具的定制化也会花去我很多的时间，比如如何配置vim，写几个小脚本来和编辑器做集成等等。更别说那些令人一听就觉得激动的编程范式：面向对象，基于消息总线，函数式编程等等。如果你感兴趣，可以看看我<a href="http://abruzzi.iteye.com/">几年前的博客</a>。</p>

<p>我的上一家公司的产品是一个省级电网的收费/计费系统（电其实和我们在超市里购买的其他生活用品一样，也是一种商品）。我在那里工作了差不多两年，日常的开发方式就是ssh登陆到RHEL（Redhat Enterprise Linux）服务器上，用vim（当然有一堆的vim插件）开发C代码，调试器是gdb（对，就是那个很牛逼，但是对新手特别不友好的gdb）。</p>

<p>我们用C语言给Apache的httpd写了一个扩展module，大约相当于现在rack里的中间件，这个module要和后端的一个要复杂的多的模块通信，其中不但涉及网络通信，还有*nix管道，缓冲，并发等等考虑。在这两年里，我几乎没有碰过任何的Web界面上的东西（处理用php写了一两百行的页面之外）</p>

<p>在加入这家公司之前，我在一家用Java做报表的公司工作，技术栈为J2EE。其中有一些前端的工作，但是并不很多，而且说实话，我当时有些看不太上这些技术。HTML/CSS在我心目中的地位比线程池，语言解析等差远了，所以我也没有认真地去系统学习。</p>

<p>在加入ThoughtWorks之前，在“前端”方面，唯一算是比较擅长的也不过是写JavaScript，而且对于前端的MVVM框架，双向绑定，模块化等高级货都没听过。且不能论HTML/CSS的最佳实践，连根据设计稿做出一个静态页面的的能力也不具备。我之前有一点JSP/HTML经验，而CSS经验也并没有超出如何画一个细线表格的范畴。换句话说，我的前端（特别是HTML/CSS）是最近才学会的。</p>

<h4>ThoughtWorks的开发</h4>

<p>在ThoughtWorks，很多团队是按照feature团队来组建的。相对于传统的component团队（按部门划分，比如研发组，测试组，设计组等，每个组还有可能会再细分成如用户调研，流程设计，视觉设计等等），feature团队里配备了软件开发过程中需要的几乎所有角色：业务分析，测试工程师，开发工程师，设计师（设计师一般不会常驻），有的团队还有项目经理的角色。</p>

<p>在feature团队里，你可以很容易看到不同的角色是如何工作的，很多时候，开发会和设计师一起来调整颜色，排版，布局，也可能和测试一起编写自动化测试用例，showcase等。也就是说，角色之间的藩篱在淡化，而就开发这一种角色而言，对于前端/后端的区分也会显得非常模糊，因为需求划分之后的story（敏捷开发中的一个术语，其实就是需求的一种展现方式）是端到端的，比如一个商品列表展示的story，会包括</p>

<ul>
<li>数据库的表结构</li>
<li>访问数据库的<a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>部分，</li>
<li>使用ORM的业务逻辑service</li>
<li>响应客户端的controller（消费JSON或者XML的HTTP接口）</li>
<li>发送请求，处理响应的JavaScript代码</li>
<li>和设计稿一致的CSS样式</li>
</ul>


<p>而且在这个过程中还会涉及到一些外围的工具</p>

<ul>
<li>虚拟机环境准备</li>
<li>数据库连接</li>
<li>自动化测试（单元测试，集成测试，可能还有UI测试）</li>
<li>数据库迁移脚本</li>
</ul>


<p>在这个过程中，开发者需要掌握和开发过程相关的一切实践中的一切工具.</p>

<p>在我的<a href="http://www.thoughtworks.com/">ThoughtWorks</a>的第一个项目中，我是以Java开发工程师角色加入的，下项目的时候，我学会了自动化provision，<a href="https://cucumber.io/">cucumber</a>测试工具，Rails，<a href="https://gradle.org/">gradle</a>（没错，我之前用Java都是用IDE构建的，在Linux世界我用make），<a href="http://jasmine.github.io/2.0/introduction.html">jasmine</a>测试工具，<a href="http://backbonejs.org/">Backbone.js</a>，haml.js。</p>

<p>第二个项目的时候，我是以前端工程师角色加入，下项目的时候，我学会了nginx配置缓存、负载均衡服务器，<a href="http://gatling.io/">gatling</a>测试工具，Hadoop/Spark等的集群配置，还有一些和项目相关的<a href="http://icodeit.org/2014/04/intro-map-gis/">GIS（地理信息系统）</a>的技术栈，前后端分离策略等。</p>

<p>第三个项目我是以Java开发工程师角色加入的，下项目的时候，我学会了如何做性能测试，如何建立<a href="http://dashing.io/#setup">一个漂亮的Dashboard</a>（可以用来展现CI等），而且在业余时间系统的学习了CSS3和HTML5，将之前零敲碎打的那些知识串起来，这些总结做了几次内部培训后，还整理成了<a href="https://selfstore.io/products/348">一本电子书</a>。</p>

<p>第四个项目我又变成了一个前端工程师，但是这个项目有意思的地方是跟mobile相关，于是页面性能，体验又变成了一个重点，下项目的时候，我对无状态的Web应用，session的持久化，<a href="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details">CSS3的动画</a>，用Backbone.js组织多页面的方式等等又有了新的理解。</p>

<p>如果这些经历造成了你觉得我很牛的错觉，那我应该道歉。我觉得自己勉强可以算是个合格的程序员：对学习保持着热情，对解决问题保持着热情，仅此而已。在项目上，如果我发现了问题，我就想办法解决，如果属于知识欠缺，那我就会去学习。我还远远没有到达精通这些技术的地步，但是在工程实践领域，根据<a href="https://en.wikipedia.org/wiki/Pareto_principle">80/20原则</a>，这些粗浅的知识足以解决80%的问题，而另外的20%，我们才真正需要一个专家来帮忙。也就是说，团队里需要有一个能解决20%的问题的前端工程师，而其他的80%的前端工作，应该可以被其他所有的开发完成，对于后端开发也是一样。</p>

<p><del>尝试从系统级别去解决一个问题，而不是将问题抛给另外一个角色（后端工程师，UX或者QA）</del></p>

<h3>总结</h3>

<p>我们缺的从来都不是前端/后端工程师，而是<strong>工程师</strong>(或者那些会系统思考，并总是想着解决问题的人)。角色划分在大的机构内可能是有意义的，就像历史上工厂里，工人被分为车工，钳工，木工，电工。但是这种模式在软件开发中未必好用，<strong>具体而微</strong>的小团队可能更具竞争力。而在一个个的小团队中，再细分前端后端就显得比较滑稽了。团队中的每个成员都应该具备基本的端到端能力（不仅仅是开发，更应该是具有业务上下文，即每个人都清楚我们要交付的最终产品是什么，以及这个产品是如何帮助最终用户的），每个成员也都需要为最终的交付物负责，而不是为自己的职责负责。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ThoughtWorks我们做内部培训？]]></title>
    <link href="http://abruzzi.github.com/2015/01/how-we-do-training-in-thoughtworks/"/>
    <updated>2015-01-25T01:20:00+11:00</updated>
    <id>http://abruzzi.github.com/2015/01/how-we-do-training-in-thoughtworks</id>
    <content type="html"><![CDATA[<h3>ThoughtWorks内部培训</h3>

<p>对新人的培训是每个企业都绕不开的一个话题，企业当然想要每个新人都能直接独当一面，最好可以直接上项目贡献自己的价值。但是从经验来看，所有新人到一个新环境都需要学习很多不同的新东西（新技术，框架，语言，工作方式等等），而每个企业对于培训新人都有各种各样的策略，比如老人带新人，比如扔到项目上让新人自己学。</p>

<p>在ThoughtWorks，我们有着丰富的培训方式，有面向社招的，有面向毕业生的，有民间自发的，有官方组织的，有内部的，也有面向社区的。</p>

<h4>TWU</h4>

<p>TWU全称ThoughtWorks University，面向毕业生，入职之后的第一堂课。TWU的地点设在印度，之前在班加罗尔，后来改到了普内。每一期5周，学生们需要和和全球其他国家地区的同学一起，一般会尽量将各个地区的学生打乱安排，尽量让学生体会多元化的文化，培训内容设计公司文化，软件开发方法论，敏捷开发（Project SImulation）实践等，同时还需要保证学生有足够的代码练习机会。</p>

<p>我在2013年作为讲师参加了一起TWU，对我自己的帮助也非常大，在和来自不同地区的讲师一起备课，学习中学习到了很多的东西，之前似是而非的一些概念也得到了纠正。</p>

<p><img src="/images/2015/02/twu33-resized.png" alt="twu" /></p>

<h4>TWI</h4>

<p>TWI全称ThoughtWorks Immersion，面向有经验的社招同事，主要涉及的内容为公司文化（合作，沟通），专业服务（如何专业的解决客户的问题），软件开发流程，敏捷开发方法论等。</p>

<p>我在2012年时参加过TWI，并整理了几篇相关文章，可以参考<a href="http://icodeit.org/2012/08/thoughtworks-immersion-day-1/">这里</a>，<a href="http://icodeit.org/2012/08/thoughtworks-immersion-day-2/">这里</a>还有<a href="http://icodeit.org/2012/08/thoughtworks-immersion-day-3/">这里</a>。</p>

<p><img src="/images/2015/01/twi-resized.png" alt="twi" /></p>

<h4>Session</h4>

<p>Office局限在ThoughtWorks办公室之内，内容随意，参加不参加随意，可以随时加入或随时离开。虽然内容没有限制，但是大多数时候分享的都是技术主题。比如<code>自动化部署</code>，<code>自动测试</code>，<code>Spring 4</code>，<code>Ruby中的构建工具</code>等等。</p>

<p>Sessoin的形式是主讲者找一个自己感兴趣的主题，一个人讲，其他参与者听，鼓励互动。时间一般控制在一个小时以内，所以一般选择在中午饭的时候，有的session会给大家订饭，一边吃一边听。</p>

<p>虽然大部分Sessoin的主题是技术相关的，但是并不局限于此。比如旅游见闻，历史，财务，摄影等等，都可以分享，有时候这些趣味性的Session的参与者更多。</p>

<p><img src="/images/2015/01/session-resized.png" alt="session" /></p>

<h4>WorkShop</h4>

<p>Office之内，内容随意，以动手为主，讲解为辅。</p>

<ul>
<li>HTML/CSS</li>
<li>Testable JavaScript</li>
<li>设计工作坊</li>
<li>OO BootCamp</li>
<li>Ruby BootCamp</li>
</ul>


<p>一般来说，Workshop都会组成一个系列，通常会占用几天到几周不等。参与者需要带上电脑，在课堂上进行练习之外，课后还会有一些练习。</p>

<p><img src="/images/2015/01/workshop-resized.png" alt="" /></p>

<p><a href="http://icodeit.org/3-pages-in-3-weeks/">3周3页面</a>和<a href="http://icodeit.org/lwweb/">可测试的JavaScript</a>是我去年做的两个Workshop。由于Workshop会在下班后或者中午的休息时间，公司会为每个参与者订饭，以节省时间。</p>

<h4>郑大晔校</h4>

<p>面向刚刚得到offer的毕业生，在上项目之前，我们希望学生的基本技术达到特定的水平，因此设置了一系列的练习。包括</p>

<ul>
<li>编程基础</li>
<li>开发流程</li>
<li>工作方式</li>
<li>公司文化</li>
</ul>


<p>等等。郑大晔校的周期为每周一次，一次一天。涉及的内容会与大多数项目上的要求一致，比如西安office的Java/Ruby项目居多，我们的课程安排就会涉及到<code>Java/Ruby</code>方面。当然，各种软技能如工作方式也会在课程中涉及，尽量的寓教于乐。</p>

<p>每期郑大晔校大概会有10周，学生入职之后有的会直接去TWU，有的则会在项目上工作一段时间再去TWU。</p>

<p><img src="/images/2015/01/zhengda-resized.png" alt="" /></p>

<h4>组内培训</h4>

<p>各个组内自行组织，并不要求其他同事参加。比如某个项目需要一些<code>docker</code>的知识，或者需要<code>AngularJS</code>相关的培训，一方面是找自己组内的专家组织一次内部培训，，另一种是找办公室内相关的专家来进行培训，形式比较灵活。</p>

<ul>
<li>项目中已经在使用的技术</li>
<li>项目中将要使用的技术</li>
<li>请别的组的专家来咨询</li>
</ul>


<p><img src="/images/2015/01/group-resized.png" alt="group learn" /></p>

<h4>社区</h4>

<ul>
<li>OpenParty</li>
<li>Rails Girl</li>
</ul>


<p><img src="/images/2015/02/rails-girl-session-resized.png" alt="rails girl" /></p>

<h4>问题</h4>

<ul>
<li>谁当讲师</li>
<li>活动经费</li>
<li>内容如何持久化（人，内部知识分享系统）</li>
<li>如何保证效果（宽松）</li>
</ul>


<p>由于对任何的话题都没有限制，也没有对参与者的限制，因此任何人只要感兴趣都可以作为讲师。而又由于没有任何的强制措施，参与者和主讲者都凭着自己的热情来组织，这也算是比较独树一帜的事情。</p>

<p>而关于内容的持久化，更多的是为参与者打开一扇新的窗户，或者说洒下一些火星，而至于火星如何形成燎原之势，则完全在参与者自己的自觉。好多次和客户分享了我们的培训机制之后，被问到最多的问题是如何<code>强迫</code>参与者产生热情？</p>

<p>这个问题在ThoughtWorks不是问题，我们在一个人进入公司的最开始，也就是面试的时候，就考察了他的热情，如果在热情上有缺陷，则很可能会直接拒掉，免得破坏我们好不容易构建起来的学习氛围。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2014]]></title>
    <link href="http://abruzzi.github.com/2014/12/my-2014/"/>
    <updated>2014-12-27T23:56:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/12/my-2014</id>
    <content type="html"><![CDATA[<p>依照惯例，我每年在元旦时候都会写一篇回顾，总结过去，展望未来。不过很少跟上一年指定的<code>计划</code>真正去比较，一般都是列举一下这一年做的事情。</p>

<p>大致分下来，可以分为上半年和下半年两部分，这当然不是废话。因为上半年和下半年分别在两个完全不同的项目上工作。</p>

<h3>技术咨询项目</h3>

<p>上半年在一个国内咨询项目上，主要做的事情有（其实我是作为前端专家加入的，不过后来工作重心发生了改变）：</p>

<ol>
<li>GIS平台</li>
<li>大数据平台</li>
</ol>


<p>关于GIS最后的产出是一系列博客，而且还在<a href="http://www.infoq.com/cn/articles/visualization-of-the-global-seismic-system">InfoQ</a>上发表了一篇。</p>

<p><img src="/images/2014/04/openlayers-earthquake-resized.png" alt="earthquake" /></p>

<p>而后来我又根据我iPhone上照片的经纬度信息，汇总出了一个热力图（使用<a href="http://qgis.org/en/site/">QGis</a>）：</p>

<p><img src="/images/2014/12/places-resized.png" alt="heat map" /></p>

<p>大数据相关的所有东西都在<a href="https://gist.github.com/abruzzi">我的gist上</a>，还没有时间整理。</p>

<h3>硬件</h3>

<p>回到办公室之后，发现了硬件小组提供的一大堆有意思的工具和器件，包括<code>3D打印机</code>，<code>Arduino</code>的一些芯片等，为了纪念我的GIS项目，我还打印了一个瓦片：</p>

<p><img src="/images/2014/12/tile-resized.png" alt="tile" /></p>

<p>不断将我拖延了4年的机器小车组装了起来，而且还使用舵机，蓝牙，超声波等模块制作了一个实际的雷达：</p>

<p><img src="/images/2014/12/radar-resized.png" alt="radar" /></p>

<h3>Sessions &amp; Workshop</h3>

<p>5月底回到办公室后，我发现Office的气氛其实比我来的时候低落了很多，ThoughtWorks的感觉非常淡了。</p>

<p>一方面是新人太多，而来新的项目所在的11楼由于客户的关系（我自以为），同事们的积极性极低。一个最容易看到的信号就是Session变得很少，我尝试做一些改变。</p>

<p>分别做了一些关于自动化测试，JavaScript方面的Session和Workshop，下面是《可测试的JavaScript》的Workshop。这是我第一次组织比较大的，而且时间比较长的Workshop。</p>

<p><img src="/images/2014/12/testable-javascript-resized.png" alt="testable-javascript" /></p>

<p>有了上一次的Feedback，在年底的时候，我又组织了一次为期3周的Workshop，受众更是扩大到了各种角色，包括BA，UX，UIDev，QA等等。</p>

<p><img src="/images/2014/12/3-pages-resized.png" alt="3 pages" /></p>

<h3>写作</h3>

<p>今年的博客数量减少了，一个原因是我在编写我的第二本书<a href="http://icodeit.org/lwweb/">《轻量级Web应用开发》</a>，经过几个月的坚持和努力，这本书已经编写完成，应该会在明年(2015年)年初与读者见面。</p>

<p>另外，在休年假的时候（3周3页面之后），我将Workshop的内容做了整理，并加入了一些<code>设计</code>相关的内容，形成了一本电子书，名为<a href="http://juntao.gitbooks.io/3-web-designs-in-3-weeks/">《3 web designs in 3 weeks》</a>。</p>

<h3>其他</h3>

<p>我正在努力的向<code>UX</code>角色的转变，所谓<code>千里之行，始于足下</code>。我在休年假期间，买了一大堆UX相关的书籍。目前正在努力学习画画：</p>

<p><img src="/images/2014/12/drawing-resized.png" alt="两点透视" /></p>

<p>在今天的CST的创新课上，我们一起设想了几个场景，下面是我自己画的图：</p>

<p><img src="/images/2014/12/scenario-resized.png" alt="场景" /></p>

<p>最后是一张我自己设计的自己的名片：</p>

<p><img src="/images/2014/12/my-card-resized.png" alt="name card" /></p>

<p>希望来年可以在自己努力的路上看到一些成果吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从一个小例子学习TDD]]></title>
    <link href="http://abruzzi.github.com/2014/11/tdd-step-by-step/"/>
    <updated>2014-11-09T15:07:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/11/tdd-step-by-step</id>
    <content type="html"><![CDATA[<h3>示例的需求描述</h3>

<p>今天我们需要完成的需求是这样的：</p>

<p>对于一个给定的字符串，如果其中<code>元音</code>字母数目在整个字符串中的比例超过了30%，则将该<code>元音</code>字母替换成字符串<code>mommy</code>，额外的，在替换时，如果有连续的元音出现，则仅替换一次。</p>

<p>如果用<code>实例化需求</code>(<a href="http://specificationbyexample.com/">Specification by Example</a>)的方式来描述的话，需求可以转换成这样几条实例：</p>

<ol>
<li><code>hmm</code>经过处理之后，应该保持原状</li>
<li><code>she</code>经过处理之后，应该被替换为<code>shmommy</code></li>
<li><code>hear</code>经过处理之后，应该被替换为<code>hmommyr</code></li>
</ol>


<p>当然，也可以加入一些边界值的检测，比如包含数字，大小写混杂的场景来验证，不过我们暂时可以将这些场景抛开，而仅仅关注与TDD本身。</p>

<h4>为什么选择这个<code>奇怪的</code>例子</h4>

<p>我记得在学校的时候，最害怕看到的就是书上举的各种离<code>生活</code>很远的例子，比如国外的书籍经常举汽车的例子，有引擎，有面板，但是作为一个只是能看到街上跑的车的穷学生，实际无法理解其中的关联关系。</p>

<p>其实，另外一种令人不那么舒服的例子是那种纯粹为了示例而编写的例子，现实世界中可能永远都不可能见到这样的代码，比如我们今天用到的例子。</p>

<p>当然，这种纯粹的例子也有其存在的价值：在脱离开复杂的细节之后，尽量的让读者专注于某个方面，从而达到对某方面练习的目的。因为跟现实完全相关的例子往往会变得复杂，很容易让读者转而去考虑复杂性本身，而忽略了对实践/练习的思考。</p>

<h4>TDD步骤</h4>

<p>通常的描述中，<code>TDD</code>有三个步骤：</p>

<ol>
<li>先编写一个测试，由于此时没有任何实现，因此测试会失败</li>
<li>编写实现，以最快，最简单的方式，此时测试会通过</li>
<li>查看实现/测试，有没有改进的余地，如果有的话就用重构的方式来优化，并在重构之后保证测试通过</li>
</ol>


<p><img src="/images/2014/11/tdd.png" alt="tdd" /></p>

<p>它的好处显而易见：</p>

<ol>
<li>时时关注于实现功能，这样不会跑偏</li>
<li>每个功能都有测试覆盖，一旦改错，就会有测试失败</li>
<li>重构时更有信心，不用怕破坏掉已有的功能</li>
<li>测试即文档，而且是不会过期的文档，因为一旦实现变化，相关测试就会失败</li>
</ol>


<p>使用<code>TDD</code>，一个重要的实践是<code>测试先行</code>。其实在编写任何测试之前，更重要的一个步骤是<code>任务分解</code>(Tasking)。只有当任务分解到恰当的粒度，整个过程才可能变得比较顺畅。</p>

<p>回到我们的例子，我们在知道整个需求的前提下，如何进行任务分解呢？作为<code>实现优先</code>的程序员，很可能会考虑诸如空字符串，元音比例是否到达30%等功能。这当然没有孰是孰非的问题，不过当需求本身就很复杂的情况下，这种直接面向实现的方式可能会导致越走越偏，考虑的越来越复杂，而耗费了几个小时的设计之后发现没有任何的实际进度。</p>

<p>如果是采用<code>TDD</code>的方式，下面的方式是一种可能的任务分解：</p>

<ol>
<li>输入一个非元音字符，并预期返回字符本身</li>
<li>输入一个元音，并预期返回<code>mommy</code></li>
<li>输入一个元音超过30%的字符串，并预期元音被替换</li>
<li>输入一个元音超过30%，并且存在连续元音的字符串，并预期只被替换一次</li>
</ol>


<p>当然，这个任务分解可能并不是<code>最好的</code>，但是是一个比较清晰的分解。</p>

<h3>实践</h3>

<h4>第一个任务</h4>

<p>在本文中，我们将使用JavaScript来完成该功能的编写，测试框架采用了<a href="http://jasmine.github.io/2.0/introduction.html">Jasmine</a>，这里有一个<a href="https://github.com/abruzzi/tdd-boilerplate">模板项目</a>，使用它你可以快速的启动，并跟着本教程一起实践。</p>

<p>根据任务分解，我们编写的第一个测试是：</p>

<p>```js
describe("mommify", function() {</p>

<pre><code>it("should return h when given h", function() {
    var expected = "h";

    var result = mommify("h");

    expect(result).toEqual(expected);
});
</code></pre>

<p>});
```</p>

<p>这个测试中有三行代码，这也是一般测试的标准写法，简称<code>3A</code>：</p>

<ol>
<li>组织数据（Arrange）</li>
<li>执行需要被测的函数（Action）</li>
<li>验证结果（Assertion）</li>
</ol>


<p>运行这个测试，此时由于还没有实现代码，因此Jasmine会报告失败。接下来我们用最快速的方法来编写实现，就目前来看，最简单的方式就是：</p>

<p>```js
function mommify() {</p>

<pre><code>return "h";
</code></pre>

<p>}
```</p>

<p>可能有人觉得这种实现太过狡猾，但是从<code>TDD</code>的角度来说，它确实能够令测试通过。这时候，我们需要编写另外一个测试来<code>驱动</code>出正确的行为：</p>

<p>```js
it("should return m when given m", function() {</p>

<pre><code>var expected = "m";

var result = mommify("m");

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>这样，我们的实现就不能仅仅返回一个"h"了，就现在来看，最简单的方式是输入什么就返回什么：</p>

<p>```js
function mommify(word) {</p>

<pre><code>return word;
</code></pre>

<p>}
```</p>

<p>很好，这样我们的第一个<code>任务</code>已经完成了！我们已经经历了<code>失败-成功</code>的循环，这时候需要<code>review</code>一下代码，以保证代码是干净的：实现上来说，并没有可以优化的地方，但是我们发现两个测试用例其实测试的是同一件事情，因此可以删掉一个。</p>

<p>是的，测试代码也是代码，我们需要小心的维护它，以保证所有的代码都是干净的。</p>

<h4>第二个任务</h4>

<p>我们可以开始元音字母的子任务了，很容易想到的一个测试用例为：</p>

<p>```js
it("should return mommy when given a", function() {</p>

<pre><code>var expected = "mommy";

var result = mommify("a");

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>测试失败之后，能想到的最快速的方式是做一个简单的判断：</p>

<p>```js
function mommify(word) {</p>

<pre><code>if(word == "a") {
    return "mommy";
}
return word;
</code></pre>

<p>}
```</p>

<p>这样测试又会通过，接下来就是重复5个元音的场景，不过使用JavaScript可以很容易的将这5个场景归为一组：</p>

<p>```js
it("should return mommy when given a vowel", function() {</p>

<pre><code>var expected = "mommy";

["a", "e", "i", "o", "u"].forEach(function(word) {
    var result = mommify(word);
    expect(result).toEqual(expected);
});
</code></pre>

<p>});
```</p>

<p>而实现则对一个的会变成（记住，用最简单的方式）：</p>

<p>```js
function mommify(word) {</p>

<pre><code>if(word == "a" || word == "e" || word == "i" || word == "o" || word == "u") {
    return "mommy";
}
return word;
</code></pre>

<p>}
```</p>

<p>好了，测试通过了。又是进行重构的时间了，现在看看实现，简直不忍卒读，我们使用JavaScript的字符串的<code>indexOf</code>方法可以简化这段代码：</p>

<p>```js
function mommify(word) {</p>

<pre><code>if("aeiou".indedOf(word) &gt;= 0) {
    return "mommy";
}
return word;
</code></pre>

<p>}
```</p>

<p>好多了！我想你现在已经或多或少的体会到了<code>TDD</code>中<code>任务分解</code>的好处了：进度可以掌握，而且目标非常明确，每一步都有相应的产出。</p>

<h4>第三个任务</h4>

<p>和之前一样，我们还是从测试开始：</p>

<p>```js
it("should mommify if the vowels greater than 30%", function() {</p>

<pre><code>var expected = "shmommy";
var result = mommify("she");

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>现在有一点点挑战了，因为我们的实现上一直都是单一的字符串，现在有多个了，不过没有关系，我们先按照最简单的方式来实现就对了：</p>

<p>```js
function mommify(word) {</p>

<pre><code>var count = 0;
for(var i = 0; i &lt; word.length; i++) {
    if("aeiou".indexOf(word[i]) &gt;= 0) {
        count += 1;
    }
}

var str = "";

if(count/word.length &gt;= 0.30) {
    for(var i = 0; i &lt; word.length; i++) {
        if("aeiou".indexOf(word[i]) &gt;= 0) {
            str += "mommy";
        } else {
            str += word[i];
        }
    }
} else {
    str = word;
}

return str;
</code></pre>

<p>}
```</p>

<p>无论如何，测试通过了，我们首先计算了<code>元音</code>所占的比重，如果超过30%，则替换对应的字符，否则直接返回传入的字符串。</p>

<p>从现在来看，函数<code>mommify</code>中已经有了较多的逻辑，而且有一些重复的判断出现了（<code>"aeuio".indedOf</code>），是时候做一些重构了。</p>

<p>首先将相对独立的计算元音比重的部分抽取成一个函数：</p>

<p>```js
function countVowels(word) {</p>

<pre><code>var count = 0;

for(var i = 0; i &lt; word.length; i++) {
    if("aeiou".indexOf(word[i]) &gt;= 0) {
        count += 1;
    }
}

return count;
</code></pre>

<p>}
```</p>

<p>然后，将重复的<code>"aeiou".indexOf</code>部分抽取为一个独立函数：</p>

<p>```js
function isVowel(character) {</p>

<pre><code>return "aeiou".indexOf(character) &gt;= 0;
</code></pre>

<p>}
```</p>

<p>这样本来的代码就被简化成了：</p>

<p>```js
function mommify(word) {</p>

<pre><code>var count = countVowels(word);
var str = "";

if(count/word.length &gt;= 0.30) {
    for(var i = 0; i &lt; word.length; i++) {
        if(isVowel(word[i])) {
            str += "mommy";
        } else {
            str += word[i];
        }
    }
} else {
    str = word;
}

return str;
</code></pre>

<p>}
```</p>

<p>如果细细读下来，就会发现发现对于元音是否超过30%的判断比较突兀，这里确实了一个<code>业务概念</code>，就是说，此处的<code>if</code>判断并不表意，更好的写法是讲它抽取为一个函数：</p>

<p>```js
function shouldBeMommify(word) {</p>

<pre><code>var count = countVowels(word);
return count/word.length &gt;= 0.30;
</code></pre>

<p>}
```</p>

<p>并且，替换元音的部分，我们也可以从主函数中挪出来，得到一个小函数：</p>

<p>```js</p>

<p>function replace(word) {</p>

<pre><code>var str = "";

for(var i = 0; i &lt; word.length; i++) {
    if(isVowel(word[i])) {
        str += "mommy";
    } else {
        str += word[i];
    }
}

return str;
</code></pre>

<p>}
```</p>

<p>这样，主函数得到了进一步的简化：</p>

<p>```js
function mommify(word) {</p>

<pre><code>if(shouldBeMommify(word)) {
    return replace(word);
} else {
    return word;
}
</code></pre>

<p>}
```</p>

<p>太好了，现在<code>mommify</code>就更加清晰了，并且每个抽取出来的函数都有了更具意义的名字，更清晰的职责。</p>

<h4>第四个任务</h4>

<p>经过了第三步，相信你已经对如何进行<code>TDD</code>有了很好的认识，而且也更有信心进行下一个任务了。同样，我们需要先编写测试用例：</p>

<p>```js
it("should not mommify if there are vowels sequences", function() {</p>

<pre><code>var expected = "shmommyr";
var result = mommify("shear");

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>现在的问题关键是需要判断一个字符串中的前一个是否元音，由于我们之前已经做了足够的重构，现在需要修改的函数就变成了<code>replace</code>子函数，而不是主入口<code>mommify</code>了：</p>

<p>```js
function replace(word) {</p>

<pre><code>var str = "";

for(var i = 0; i &lt; word.length; i++) {
    if(isVowel(word[i])) {
        if(!isVowel(word[i-1])) {
            str += "mommy";
        } else {
            str += "";
        }
    } else {
        str += word[i];
    }
}

return str;
</code></pre>

<p>}
```</p>

<p>测试通过之后，我们可以大胆的进行重构，抽取新的函数<code>next</code>：</p>

<p>```js
function next(current, previous) {</p>

<pre><code>var next = "";

if(isVowel(current)) {
    if(!isVowel(previous)) {
        next = "mommy";
    }
} else {
    next = current;
}

return next;
</code></pre>

<p>}</p>

<p>function replace(word) {</p>

<pre><code>var str = "";

for(var i = 0; i &lt; word.length; i++) {
    str += next(word[i], word[i-1]);
}

return str;
</code></pre>

<p>}
```</p>

<p>最后，如果你想看完整的/最新的代码，可以<a href="https://github.com/abruzzi/mommifier">在github上</a>找到。</p>

<h4>结束（？）</h4>

<p>重构是一个永无止境的实践，你可以不断的抽取，简化，重组。比如上例中对于常量的使用，对于JavaScript中的for的使用等，都可以更进一步。但是你需要权衡，适可而止，如果不小心做的太过，则可能引起过渡设计：引入太过的概念，过于简化的接口等。</p>

<p><code>TDD</code>是一种容易付诸实践的开发方式，在小的，简单的例子上如此，在大的，复杂的场景下也是如此。它优美且高效的地方在于：不假设任何人可以一次就写出完善的应用，而是鼓励小步前进，快速反馈，快速迭代。而演化到最后，得到的往往就是孜孜以求的优美设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Yahoo pipes 服务做内容聚合 -- ThoughtWorks好声音]]></title>
    <link href="http://abruzzi.github.com/2014/01/use-yahoo-pipe-service-to-aggregate-blogs-you-care/"/>
    <updated>2014-01-01T19:48:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/01/use-yahoo-pipe-service-to-aggregate-blogs-you-care</id>
    <content type="html"><![CDATA[<h3>ThoughtWorks好声音</h3>

<p><a href="http://voice.thoughtworkers.org/">ThoughtWorks好声音</a>是一个聚合网站，内容来自众ThoughtWorker的博客，我们每周会汇聚一次，从众多的博客中挑选出一些P2(软件卓越)相关的主题，然后编为一辑，再分享出去。</p>

<p>但是从近100个博客中找P2相关的内容，这件事本身非常繁琐，如果每周都做这个重复劳动的话，那么软件卓越从何谈起呢？作为以解放人类为己任的程序员，我们绝对不能忍受纯体力的劳动。</p>

<h4>获取博客地址列表</h4>

<p>之前郑晔做了一个<a href="https://jinshuju.net/">金数据</a>的统计，请各位同事把自己的名字和博客地址登记在一个金数据的表单上：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/blog-colllecting.png" alt="image" /></p>

<p>接下来第一步就是把网页上的所有地址取下来，这一步很容易，从金数据的页面上用jQuery找到表格的第二列，然后将其中的文字取出来：</p>

<p>```js</p>

<p>$("table tr td:nth-child(2)").map(function(key, item) {</p>

<pre><code>return $(item).text().trim(); 
</code></pre>

<p>});</p>

<p>```</p>

<p>写到这里突发奇想，能不能用phantomjs去把这个动作自动化？</p>

<p>```js
page.open(url, function (status) {</p>

<pre><code>if (status !== 'success') {
    console.log('Unable to access network');
} else {
    page.injectJs('jquery.js');

    var links = page.evaluate(function() {
        return $("table tr td:nth-child(2)").map(function(key, value) {
            return $(value).text().trim();
        });
    });

    var results = underscore(links).filter(function(item) {
        return item.length &gt; 0; 
    }).map(function(item) {
        if(!new RegExp('^(https|http)').test(item)) {
            return "http://" + item;
        }
        return item;
    });
}
phantom.exit();
</code></pre>

<p>});</p>

<p>```</p>

<p>这样，results数组中就包含了所有的博客链接了，而且有的同事比较懒，提供的URL中不包含<code>http</code>，这段代码还顺手给这样的url添加了头尾。</p>

<p>然后<strong>第二步</strong>，我<strong>想象</strong>着应该再写个脚本，在这个数组中得每个url的后边加上诸如<code>rss</code>或者<code>atom.xml</code>之类的后缀，然后去获取每个博客的rss文件，然后根据这些信息做一些事情。吃午饭的过程中我还在想象这个工具分为几个模块，用什么样的语言来做开发等等细节。</p>

<p>吃完午饭，突然想起来之前熊杰貌似发过一个yahoo pipes生成的rss，我在邮件中翻出来之后，失望的发现我自己的博客都不在里边，想想熊杰貌似还在乌干达援助非洲人民，那就自己动手重新定义一个吧。</p>

<h4>Yahoo pipes 服务</h4>

<p><a href="http://pipes.yahoo.com/pipes/">Yahoo pipes</a>是一个用来定制聚合的服务，只需要定义好数据源(通常是rss/atom)，然后定义一些操作，比如排序，去重，联合等等。最后这个pipe会生成一个结果集，这些特性简直就是为我们这个需求定制的：</p>

<ol>
<li>将博客地址+'/rss' / 博客地址+'/atom.xml' 添加到一个个的fetcher上</li>
<li>将这些fetcher联合起来</li>
<li>将联合的结果排序(按照发表日期/更新日期)</li>
<li>生成最后的rss</li>
</ol>


<p>yahoo pipes提供的编辑器非常简单易用：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/single-pipe.png" alt="image" /></p>

<p>而且在编辑界面底下有一个预览界面：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/single-preview.png" alt="image" /></p>

<p>当然，当定义好完整的pipe之后，我们的ThoughtWorks好声音的源看起来是这样的：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/tvot-pipe-resized.png" alt="image" /></p>

<p>运行这个pipe之后，得到一个preview的界面：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/tvot-pipe-run-resized.png" alt="image" /></p>

<p>最后，可以将这个pipe公开发布，或者将这个pipe生成的rss订阅到阅读器中，比如<a href="http://www.vienna-rss.org/">vienna</a>:</p>

<p><img src="http://abruzzi.github.com/images/2014/01/vienna-resized.png" alt="image" /></p>

<p>然后就可以一目了然的看到最近有哪些ThoughtWorker更新了自己的博客，又有那些是P2相关的，可以<code>理论上</code>减轻我们编辑很多的工作量。</p>

<h4>结论</h4>

<p>手里是锤子的时候，看着周围的东西都像钉子。有时候，那些又酷又炫的技巧/工具可能并非必须。</p>
]]></content>
  </entry>
  
</feed>
