<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2016-01-10T01:17:48+11:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[穷人的持续集成与持续交付]]></title>
    <link href="http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1/"/>
    <updated>2016-01-09T23:34:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1</id>
    <content type="html"><![CDATA[<h1>基于免费服务的持续交付环境</h1>

<p>本文将使用一些免费的服务来为你的项目搭建<code>持续交付</code>平台，这些服务包括</p>

<ul>
<li>持续集成环境</li>
<li>持续部署环境</li>
<li>服务端应用托管</li>
</ul>


<p>以及一些可以用于本地开发使用的开源工具如：</p>

<ul>
<li><a href="https://github.com/abruzzi/node-build-monitor">基于Node的构建monitor</a></li>
<li><a href="https://toolbelt.heroku.com/">Heroku的命令行工具</a></li>
<li><a href="https://github.com/travis-ci/travis.rb">Travis CI的命令行工具</a></li>
</ul>


<p>除此之外，我们在过程中编写的脚本还可以用以本地构建，如果你的团队中正好已经有CI工具/CD工具，将这些脚本集成进去也是一件非常容易的事情。</p>

<p><img src="/images/2016/01/heroku-log-resized.png" alt="heroku real time log" /></p>

<h2>背景知识</h2>

<h3>软件的度量</h3>

<p>传统的管理方法论，在软件开发这个领域来说基本上是不工作的。软件项目的不确定性使得人们畏惧，管理者希望通过一些数字，指标来让自己感到某种虚幻的“掌控感”。软件行数，测试覆盖率，代码故障率等数字的名声基本上已经很糟了，经常有人拿来讽刺那些追求虚幻掌控感的“领导”。</p>

<p>但是有一个数字，即使最顽固的“自由主义者”也会认为是有意义的，那就是周期时间（cycle time）。简而言之，就是一个需求从产生到最终上线所需要的时间。其中包括了需求分析，设计，编码，测试，部署，运维等活动，可能还会包含后续的监控。</p>

<p>其实不论是瀑布模型，还是迭代开发的方式，或者其他的方法论，周期时间的缩短都是至关重要的。而具体到周期内，单纯的开发时间变长或者测试时间变长都无关紧要。比如项目A的开发时间是测试时间的2倍，项目B则恰恰反过来，这并不能说A做的比B好，真正有意义的是A的周期时间是否比B更短。</p>

<p>单纯改善项目过程中的某一个阶段的时间，可能并不能达到预期的目的。局部优化并不一定会带来全局的优化。换言之，<strong>通过某些策略来提高软件测试的效率未必能减少周期时间！</strong>。</p>

<h3>持续交付</h3>

<p>传统情况下，企业要进行软件开发，从用户研究到产品上线，其中会花费数月，甚至数年（我的一位印度同事给我聊起过，他的上家公司做产品，从版本启动到版本上线需要整整两年时间！）。而且一旦软件需求发生变更，又有需要数月才能将变更发布上线。除了为变更提交代码外，还有很多额外的回归测试，发布计划，运维部门的进度等等。而市场机会千变万化，在特定的时间窗口中，企业的竞争者可能早已发布并占领了相当大的市场份额。</p>

<p>在软件工程领域，人们提出了持续交付（continuous delivery）的概念，它旨在减少周期时间，强调在任何时刻软件都处于可发布状态。采用这种实践，我们可以频繁，快速，安全的将需求的变化发布出来，交由真实世界的用户来使用，在为用户带来价值的同时，我们也可以快速，持续的得到反馈，并激励新的变化产生（新的商业创新，新的模式等）。</p>

<p>持续交付包含了自动化构建，自动化测试以及自动化部署等过程，持续改进开发流程中的问题，并促进开发人员，测试人员，运维人员之间的协作，团队可以在分钟级别将变更发布上线。</p>

<h3>持续交付相关技术及实践</h3>

<ul>
<li>版本控制（配置管理）</li>
<li>持续集成CI</li>
<li>自动化测试</li>
<li>构建工具及构建脚本</li>
<li>部署流水线</li>
</ul>


<p>团队通过版本控制来进行协作，所有的代码会在持续集成环境中编译，代码静态检查/分析，自动化测试（还可能产生报告等）。除此之外，CI还还需要有自动化验收测试，自动化回归测试等。</p>

<p>持续交付则更进一步，它将环境准备，持续集成，自动化部署等放在了一起。通过全自动（有些过程可以设置为手动，比如发布到产品环境）的方式，使得软件可以一键发布。如果上线后发现严重defect，还支持一键回滚的机制（其实就是将之前的一个稳定版本做一次发布，由于发布流程已经经过千锤百炼，所以发布本身就变得非常轻松，安全）</p>

<h2>实例</h2>

<p>我在<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">《前后端分离了，然后呢？》</a>这篇文章中，提到了一个叫做<code>bookmarks</code>的应用，这个应用是一个前后端分离的非常彻底的应用。</p>

<p>我们这里会再次使用这个应用作为实例，并采用不同的两个免费服务（<a href="https://travis-ci.org">travis-ci</a>和<a href="https://snap-ci.com">snap-ci</a>）来完成<code>持续部署</code>环境的搭建。</p>

<h3>服务器端</h3>

<p><code>bookmarks-server</code>是一个基于<code>spring-boot</code>的纯粹的<code>API</code>，它可以被打包成一个<code>jar</code>包，然后通过命令行启动运行。在本文中，我们我们将会将这个server部署到<a href="https://dashboard.heroku.com/">heroku</a>平台上。</p>

<p>首先需要定义一个<code>Procfile</code>，这个是我们应用的入口，<code>heroku</code>根据这个文件来明确以何种方式来启动我们的应用：</p>

<p><code>
web: java -Dserver.port=$PORT -jar build/libs/bookmarks-server-0.1.0.jar --spring.profiles.active=staging
</code></p>

<p>由于我们在本地使用的使用<code>mysql</code>，而<code>heroku</code>默认的是<code>postgres</code>数据库，因此需要在<code>application.yml</code>中额外配置</p>

<p>```yml
spring:
  profiles: staging</p>

<p>  datasource:</p>

<pre><code>driverClassName: org.postgresql.Driver
url: ${JDBC_DATABASE_URL}
username: ${DATABASE_USER}
password: ${DATABASE_PASS}
</code></pre>

<p>  jpa:</p>

<pre><code>database_platform: org.hibernate.dialect.PostgreSQLDialect
hibernate:
  ddl-auto: update
</code></pre>

<p>```</p>

<p>有了这些配置后，我们需要创建一个<code>heroku</code>应用：</p>

<p><code>sh
$ heroku create
Created http://quiet-atoll-8237.herokuapp.com/ | git@heroku.com:quiet-atoll-8237.git
</code></p>

<p>创建之后，我们可以在界面上对这个应用进行一些配置（当然，也可以通过命令行，具体参看<code>heroku help</code>）。为了支持数据库，需要为我们的应用添加一个<code>postgres</code>的AddOn。添加之后，<code>heroku</code>会为我们提供一个<code>postgres</code>的连接地址，格式大概是这样：</p>

<p><code>
postgres://username:password@host:port/database
</code></p>

<p>然后我们需要在<code>Heroku</code>的配置界面中配置一些环境变量：</p>

<p><img src="/images/2016/01/heroku-config-resized.png" alt="heroku env config" /></p>

<p>这样，当应用部署到<code>Heroku</code>上之后，我们的应用就可以读到这些配置了（注意<code>application.yml</code>中的环境变量<code>JDBC_DATABASE_URL</code>）。</p>

<h4>搭建持续集成环境</h4>

<p>持续集成环境，这里我们选用最简单的<code>travis-ci</code>，它可以很容易的与<code>github</code>集成。</p>

<ul>
<li>在项目X中定义一个<code>.travis.yml</code>的文件</li>
<li>将你的代码push到github上</li>
<li>绑定github帐号到<code>travis</code></li>
<li>在<code>travis</code>中启用项目X</li>
</ul>


<p>这个<code>.travis.yml</code>因项目而异，我们这里的项目是<code>spring-boot</code>，所以只需要指定<code>java</code>即可：</p>

<p><code>yml
language: java
</code></p>

<p>如果是<code>java</code>项目，并且项目中有<code>build.gradle</code>，<code>travis-ci</code>会自动执行<code>gradle check</code>任务。</p>

<h4>自动化部署</h4>

<p>当CI运行成功之后，我们需要<code>travis-ci</code>帮我们将应用程序发布到<code>heroku</code>上，这时候需要做一些修改。最简单的方式是直接安装<code>travis-ci</code>的命令行工具到本地：</p>

<p><code>sh
$ gem install travis -v 1.8.0 --no-rdoc --no-ri
</code></p>

<p>然后通过<code>heroku</code>的<code>auth:token</code>命令获得<code>heroku</code>的token，在加密并写入<code>.travis.yml</code>：</p>

<p>```sh
$ heroku auth:token
00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067</p>

<p>$ travis encrypt 00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067 --add
```</p>

<p>当然可以合并为一条命令：</p>

<p><code>sh
$ travis encrypt $(heroku auth:token) --add
</code></p>

<p>将加密过的token存入<code>.travis.yml</code>文件。最后的结果大致如下：</p>

<p>```yml
language: java
deploy:
  provider: heroku
  api_key:</p>

<pre><code>secure: ...
</code></pre>

<p>  app: quiet-atoll-8237
```</p>

<p>注意此处的<code>app</code>，正是我们的App的名字。另外，还需要给<code>build.gradle</code>添加一个名叫<code>stage</code>的task，<code>travis</code>在deploy时需要这个<code>task</code>：</p>

<p>```groovy
task stage {</p>

<pre><code>dependsOn build
</code></pre>

<p>}
```</p>

<p><img src="/images/2016/01/travis-deploy-resized.png" alt="travis deploy" /></p>

<p>这样，我们只需要在本地的一个提交，一切都会自动化起来：</p>

<ul>
<li>travis会执行<code>gradle check</code></li>
<li><code>gradle check</code>会编译并运行自动化测试</li>
<li><code>travis</code>会部署应用到<code>heroku</code>上</li>
<li><code>heroku</code>会自动重启服务</li>
</ul>


<p>我们可以在本地进行简单的测试（注意此处我们的<code>staging</code>环境的URL）：</p>

<p>```sh
$ curl https://quiet-atoll-8237.herokuapp.com/api/feeds -s | jq .
[
  {</p>

<pre><code>"id": 1,
"url": "http://icodeit.org/2016/01/how-to-summarize-privious-project/",
"title": "如何持久化你的项目经历",
"author": "icodit.org",
"summary": "通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。",
"publishDate": "2016-01-07"
</code></pre>

<p>  },
  {</p>

<pre><code>"id": 2,
"url": "http://icodeit.org/2015/11/get-started-with-reflux/",
"title": "你为什么应该试一试Reflux？",
"author": "icodit.org",
"summary": "React在设计之初就只关注在View本身上，其余部分如数据的获取，事件处理等，全然不在考虑之内。",
"publishDate": "2016-01-09"
</code></pre>

<p>  }
]
```</p>

<p>完整的<a href="https://github.com/abruzzi/bookmarks-server">代码在这里</a>。</p>

<h2>其他</h2>

<h3>CI monitor</h3>

<p><a href="https://github.com/abruzzi/node-build-monitor">node-build-monitor</a>是一个非常容易配置，使用的CI monitor，我们只需要进行简单地配置，就可以将<code>travis</code>的状态可视化出来</p>

<p>```json
{
  "monitor": {</p>

<pre><code>"interval": 2000,
"numberOfBuilds": 12,
"debug": true
</code></pre>

<p>  },
  "services": [</p>

<pre><code>{
  "name": "Travis",
  "configuration": {
    "slug": "abruzzi/bookmarks-server"
  }
}
</code></pre>

<p>  ]
}
```</p>

<p>不过这个工具会在有网络异常时自动终止，我们可以通过一个简单的脚本来在它终止时自动重启：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>until node app/app.js
do</p>

<pre><code>echo "restarting..."
</code></pre>

<p>done
```</p>

<p><img src="/images/2016/01/ci-monitor-resized.png" alt="CI Monitor" /></p>

<h2>小结</h2>

<p>通过<code>travis</code>和<code>heroku</code>这样的免费服务，我们就可以轻松的将自己的项目做到持续集成+持续交付。我们后端的服务相对来说是比较容易的，但是涉及到一个前后端分离的架构，如何做到静态内容的托管，打包，部署，并和后端API集成起来，我会在下一篇文章中详细解释。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何持久化你的项目经历]]></title>
    <link href="http://abruzzi.github.com/2016/01/how-to-summarize-privious-project/"/>
    <updated>2016-01-05T12:44:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/how-to-summarize-privious-project</id>
    <content type="html"><![CDATA[<h1>下项目之后</h1>

<p>通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。这里面既有终于摆脱了厌烦了的<code>技术栈</code>的解脱感，也有对新项目/新技术的向往，可能还有些在旧项目中做的不太满意的事情，可以在新项目重头再来的期望。</p>

<p>可能有点老生常谈了，不过这里我想说说下项目后如何做总结的事儿。对上一个项目的总结，其重要程度可能要远远超过你的想象。我是在2014年初，在一个客户现场的一个会议室和一位同事谈我的Annual Review的时候，才意识到这个问题的。</p>

<p>Annual Review会回顾我们过去一年的项目经历，有哪些方面的进步，同时也会展望未来的计划。但是这其中有几个问题：第一个问题是以年为单位的Review粒度太粗，有些经历已经淡忘，也有人可能一年会换好几个项目；第二个问题是对于大多数人来说，展望未来是一件比较容易的事儿，每个人或多或少都会有一些计划（比如学会前端的某些技术，尝试一些DevOps方面的工作，或者了解一下大数据等等）；但是对于回顾过去，我们其实并不擅长；最后一个问题是即使做了回顾，回顾的层次非常浅，作用并不大。</p>

<p>说到回顾过去，更多时候我们关注的是从项目中学到了什么样的新技术，这种浅层次的回忆和记流水帐是容易的，但是对于我们的成长并不会有太大的收益。真正会为帮助我们在将来的项目中做决策，甚至会影响我们学习效率，解决问题能力的是：<code>深度回顾</code>。</p>

<h2>深度回顾练习</h2>

<p>深度回顾可以帮助我们梳理知识，将实际的案例归纳总结为实际可用的知识。要获得这种能力，需要做一些针对性的练习。根据我自己的经验，这些练习大约可以归为3类，难度依次增加。</p>

<h3>项目上的直接经验</h3>

<p>这个练习比较简单，就是问问自己：“<strong>我在项目里学到了什么？</strong>”</p>

<p>要回答这个问题是很容易的，项目中用到的技术如模板引擎，前端框架，自动化测试套件，build工具等等，总结这些内容的过程，对于我们的PS来说都是“自动”发生的，几乎不需要付出额外的efforts。这些回顾、总结可以帮助我们成为一个“熟手”，即当下一次遇到相同或者类似的场景时，我们可以很容易直接应用这些经验。</p>

<p>更进一步，再问问自己在项目中的其他收获。比如客户关系处理的经历，团队建设的经验，甚至是写英文邮件的技巧等等方面，看看做的有没有问题，有没有提升的可能？</p>

<p>人类最牛逼的技能是：可以审视自己的行为。也就是站在旁观者的角度来看待自己的行为，随波逐流式的在各种琐事中沉浮事实上无法得到提升的。可以经常性的将自己置身事外，以一个旁观者的角度来审视自己做过的事情。并从中找出做得好的地方和不足的地方，然后自己给过去的自己一些建议，并记录下来。这些刻意的练习会帮助你养成回顾，从经验中学习的习惯，而这个习惯正是一个人区别于另一个人的绝对“捷径”。</p>

<h3>练习讲故事</h3>

<p>这个练习是，假想你遇到了一个同一个办公室的同事，他对你刚做完的这个项目很感兴趣，你来给他描述一下这个项目。描述的内容包括但不限于这些方面：</p>

<ul>
<li>项目的背景介绍</li>
<li>该项目以何种方式，为那些用户，带来了什么样的价值？（business model是什么）</li>
<li>该项目的实际用户数量是什么级别？</li>
<li>项目的部署，运维是如何操作的？</li>
<li>项目的监控是怎样做的？</li>
<li>当遇到系统故障，项目组是如何反应的？</li>
</ul>


<p>能把一件事情描述清楚是一件非常了不起的能力。我见过很多的程序员，写起代码来好不含糊，但是却很难将一件简单的事情讲清楚。我们当然要提防那些夸夸其谈，华而不实的“嘴子”，但是也至少得要求自己做到清晰，准确的将自己经历过的事情描述清楚。</p>

<p>描述项目背景需要至少需要交代这样一些内容：客户是谁，最终的消费者是谁，项目以何种方式运作（离岸交付，本地，onsite，咨询，培训等），我们<strong>帮助客户为消费者带来了什么样的价值</strong>。客户的商业模式是什么，在我们周围有哪些类似的项目。</p>

<p><img src="/images/2016/01/bmcanvas-basic-model-resized.jpg" alt="business canvas" /></p>

<p>即使在技术方面，也有很多被Dev忽略掉的信息，比如项目在产品环境中如何部署，数据中心建在何处，客户如何运维、监控等。实际的发布周期如何，发布流程如何，客户的内部论坛上都会有很多的这样的信息，但是很少有人关注。从一个项目roll off的时候，这些信息即使做不到了若指掌，至少也能描述清楚，否则难免有些“入宝山而空回”的遗憾。</p>

<h3>回顾项目中的挑战</h3>

<p>从简单的CRUD系统，到复杂的分布式计算，从企业内部的管理系统，到支持高并发、要求实时处理的交易平台，每个项目都会遇到一些挑战。除了技术上的挑战之外，还有陈旧而无文档的代码库，复杂的业务场景，不配和的客户接口人等等。挑战无处不在，那么作为项目中的一员，你是如何应对这些挑战的呢？最后又是如何解决的？</p>

<p>现实世界是一个充满了trade off的世界，我们需要做种种权衡，代码测试覆盖率和交付压力，性能和客户能负担的机器实例数量，框架A和框架B的优劣等等。我们在采取这个方案的时候，只能舍弃其他方案，由于谁也无法在事先准确预料采取某个方案一定是对的，那么在一个失败的方案背后，其实也是一个很好的教训，至少可以为未来的决策提供帮助。</p>

<ul>
<li>遇到的最大的挑战是什么？</li>
<li>这个挑战是如何被解决的？</li>
<li>如果有机会重做，你会如何考虑？</li>
</ul>


<h3>其他练习</h3>

<p>这里列出了一些我常用的，辅助性的练习。它们可以帮助你更好的梳理项目上学到的技能、知识，并且转换成你自己的知识。这些练习未必一定要等到项目结束之后才做，事实上它们都可以应用在日常的工作中。</p>

<ul>
<li>记笔记</li>
<li>写博客</li>
<li>在办公室内演讲</li>
<li>去社区贡献话题</li>
</ul>


<p>很多人都会记笔记，但只有一小部分的人在记录之后会持续翻阅。很多人会使用Evernote/印象笔记之类的工具将一些临时的想法，问题的思路，知识点的细节等记录下来，但是仅仅记录是不够的，笔记需要不断的检索、整理、提炼、修正、总结和归纳。在不断的加工之后，这些笔记可能会得到沉淀，并升华形成一些更有意义的内容（比如个人博客，或者可以发表到InfoQ/IBM DeveloperWorks平台上的文章等）。</p>

<p>除了记录笔记之外，写博客也是一种很好的总结形式。通过将素材不断充实、整理、完善，最终形成一个可供别人直接消费的文章，不但可以锻炼到总结能力，还可以很好的提升表达能力，而且可以帮助你将已有的知识体系化。如果你的博客写成了系列，也很容易通过Gitbook等将其发布为一本电子书，从而影响更多人（说不定还可以赚点咖啡钱）。</p>

<p>写博客/电子书，终究是书面形式的。事实上一个人可以很容易的通过文字将自己的实际情况隐藏起来。举个极端的例子：如果有足够的动机（比如公司的KPI要求），即使不熟悉某种语言/工具，仅仅通过Google，一个人也可以通过这种“作弊”的方式写出一篇“专家级”的文章。但是对于演讲这种面对面的形式，则基本上无法作弊，从而也更具有挑战性。另一方面，对于一个新的知识、技能，自己掌握是一回事儿，要讲出来让别人也能听懂，并从中收益，则完全是另外一回事儿。作为咨询师，语言表达（包括书面和演讲）能力的重要性勿庸赘言。整理知识，并归纳为演讲，会帮助你将体系化后的知识更好的表达出来。</p>

<p>在办公室里讲session有一定的挑战，但受众毕竟是“自己人”，压力相对会小一些（比如在ThoughtWorks，我们非常鼓励员工为其他人讲session，具体可以参看<a href="http://icodeit.org/2015/01/how-we-do-training-in-thoughtworks/">我的这篇文章</a>）。要在社区中演讲则要面临更大的挑战，通过将话题不断锤炼，不断归纳，最终形成可以在社区分享的话题，则不但可以提高内容的质量，也可以更好的锻炼表达能力和临场应变能力。</p>

<p><img src="/images/2016/01/xian-resized.jpg" alt="xian community" /></p>

<p>不过归根结底，这些活动的重要输入还是对之前项目中的知识、经历的深度回顾。</p>

<h2>总结</h2>

<p>从项目上下来之后，需要深入思考并总结之前的经验，这种深入思考会帮助你建立比较完整的知识体系，也可以让你在下一项目中更加得心应手，举一反三。如果只是蜻蜓点水般的“经历”了若干个项目，而不进行深入的总结和思考，相当于把相同的项目用不同的技术栈做了很多遍一样，那和我们平时所痛恨的重复代码又有什么不同呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2015]]></title>
    <link href="http://abruzzi.github.com/2016/01/my-2015/"/>
    <updated>2016-01-02T19:54:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/my-2015</id>
    <content type="html"><![CDATA[<h1>2015年总结</h1>

<p>2015年在不经意间就过去了。又是一年。按照惯例，我会在年末回顾一下这一年自己的进步，收获以及一些感慨（牢骚）。然后对来年做一点展望，看看什么地方可以做的更好。</p>

<h2>项目经历</h2>

<p>今年基本上经历了三个项目，性质也都不一样：</p>

<ul>
<li>海外交付</li>
<li>国内交付</li>
<li>国内售前</li>
</ul>


<p>3月前的项目以及没有什么印象了，依稀觉得项目上的所有实践都是“错”的，可能由于太过与荒诞，所以大脑自行将这段抹去了。</p>

<p>4月到6月在深圳的一个国内交付项目上，交付压力还挺大。不过也是在这个项目上，非常直接的体会到了其他角色的不容易。无论是客户的接口人，客户的项目经理，客户的领导，我们的开发，我们的UX，项目经理，还有交付的lead，所有人都不容易。</p>

<p><a href="http://icodeit.org/2015/07/is-project-manager-a-fool/">《项目经理是大傻逼吗》</a>这篇文章就是为了纪念这个项目，或者说是被这个项目驱动出来的。</p>

<p>6月之后回到办公室，在一个海外交付项目上。说是一个项目，中间其实换了6，7个不同的工作内容（出钱的是同一个客户而已）。总之一片混乱，所幸我们在10月前就结束了和这个客户的合作。这个项目事实上除了锻炼项目上人的耐心外，基本毫无益处。甚至对于很多毕业生来说，是深刻的伤害。</p>

<p>10月之后，我难得的在beach上待了下来，而且一待就是3个月。中间在一个联合国的项目上工作了2周，然后就是为另外一个咨询项目准备了几周方案。当然，闲是不可能闲着的。在beach上，如果不出意外，肯定会比项目上更忙！比如打黑工啊，内部什么系统的改进啊，总是有好多事情。</p>

<p>由于有一些本地的项目机会，而我又不在具体项目上，就来做这个售前的角色。帮助客户梳理需求，分析问题，设计方案，计算工作量等等。但是这个过程往往循环往复，一轮接着一轮，在合同确认之前，需要很多次讨论和交流。这应该不会是我自己的一个方向，在项目上写代码，培养新人，分享自己的学习所得，和他人一起进步，是我自己比较有热情的方向。</p>

<h2>技术方面</h2>

<p>在海外交付项目上，乏善足陈，项目中用到的也是非常厚重，已经至少10年的技术。通常来看，这样的大组织，没有人对要做的事情真正关心。好不容易遇到一个特别靠谱的人，结果我们的项目又结束了。国内项目上倒是有很多有意思的东西：</p>

<ul>
<li>如何在前端代码中很好的使用MVC</li>
<li>流畅的前端开发模式</li>
<li>如何做前端的测试</li>
</ul>


<p>上面这三点，我希望可以找时间整理出一本电子书，可以让没有<code>工程级</code>做过项目的前端工程师能有一个参考。</p>

<p>另一方面，由于项目的压力，和项目人员的特殊性（开发就俩人，一个做前端，一个做后端，要集成就pair一下），所以很多实践都没有应用，比如结对，自动化测试等，做的都不够好。虽然我们很推崇，强调CI/CD的实践，但是当和客户的后端系统集成时，就各种悲剧。</p>

<p>联合国的项目上，技术栈比较新颖，上一家的技术人员使用了他们当时能找到的所有酷炫的新技术，并用在了项目中，然后他们公司被收购。留给我们的在今年来看，依然是<a href="http://icodeit.org/2015/11/get-started-with-reflux/">比较新的</a>：</p>

<ul>
<li>React</li>
<li>Reflux</li>
<li>ES6</li>
<li>mocha/chai</li>
</ul>


<p>而在国内售前，基本上没有写过一行代码，更多是更高层次（高不一定是好哦）的工作。确认需求，估算工作量，确定方案（前后端测试，开发方式，部署策略，自动化测试等等）。</p>

<p>2016年，我希望可以多学习一些具体的编程知识，比如：</p>

<ul>
<li>mongodb</li>
<li>数据分析，数据挖掘</li>
<li>容器技术如docker</li>
</ul>


<h2>书籍</h2>

<p>今年读了一些技术方面的书，更多的则是一些非技术类的。《自私的基因》是在2012年11月去墨尔本时，在广州白云机场买的，路上10个小时，读了几页。直到2015年才又拿起来，读了两章左右，基本上颠覆了我之前建立的对“进化论”的认识。</p>

<p>另外读了一些科普类的，比如《哲学家在干了些什么》，《上帝掷骰子吗》等，又扫了一次盲。再就是一些佛教相关的书籍，《西藏生死书》，《能断：金刚经》，《正见》等，人生观和价值观得到了刷新。</p>

<p>技术类的，主要是一些与具体技术关系不太大的，比如《恰如其分的软件架构》，《企业级应用架构模式》，《发布！》，《实例化需求》，《持续发布》之类。</p>

<p>虽然竣工于2014年，但是我的一本著作和一本译作都是2015年才发布出来，那就算作2015年的吧：</p>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B012R5A1NQ">《轻量级Web应用开发》</a></li>
<li><a href="http://www.amazon.cn/dp/B015317A94">《7周7Web框架》</a></li>
</ul>


<h2>社区</h2>

<p>今年在深圳的时候，有幸和ThoughtWorks的首席科学家<code>马丁.福勒</code>在同一次活动中作为讲师。</p>

<p><img src="/images/2016/01/shenzhen-resized.jpg" alt="shenzhen" /></p>

<p>回到西安之后，在本地社区中还讲过一个<code>前端工程师需要掌握的技能列表</code>的session</p>

<p><img src="/images/2016/01/xian-resized.jpg" alt="xian" /></p>

<p>2016年希望可以做一些更加深入的topic，以及一些更有意思，可以帮助到更多已经<code>在路上</code>的工程师们。</p>

<h2>People Development</h2>

<p>这个不知道如何翻译了，但是确实做了一些具体的事情：</p>

<ul>
<li>给我的sponsee们安排了读书会</li>
<li>组织了一次《编写可维护的JavaScript》的workshop</li>
<li>组织sponsee来做一个side project</li>
<li>组织《Web开发实战》的workshop</li>
</ul>


<p>我自己总结出来了一套组织workshop的方式，其实很简单：</p>

<ol>
<li>做好计划，做好课表，做好课件</li>
<li>找学员，同时从学员里找出<code>有基础，而且有意愿接着run workshop的人</code></li>
<li>讲课，收集feedback，并改进课表，课件</li>
<li>将run workshop的任务传递给那些<code>有基础，而且有意愿接着run workshop的人</code></li>
</ol>


<p>2016年希望可以找到更多的<code>候选人</code>，并帮助他们成为更好的讲师，教练。</p>

<h2>总的感悟</h2>

<p>总体的感觉是很忙，各种事情千头万绪，没有了清晰的一个vision，也没有了指导，自身的发展方向也变得模糊起来。一部分原因可能是压力的方向变了，在项目上的单一的压力下总是可以找出一些事情来的，但是在项目之外，各种可见不可见的压力都慢慢浮现。对于这些隐形的，不可见的，但是又可以感受到的压力，需要认真思索对策，然后想办法搞定。</p>

<p>学习上有点“半瓶醋”的感觉，很多技术都接触了，但是不见得深入。缺乏空杯心态，这个是2016年希望自己能改进的地方。另一方面，希望在一个IT系统的架构层面有一些积累，以便在考虑项目的问题时，能够更加全面，而不至于陷入细节，只见树木，不见森林。</p>

<p>2016，当然还会很忙，只是希望忙的过程中可以多一些快乐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目经理是大傻B吗？]]></title>
    <link href="http://abruzzi.github.com/2015/07/is-project-manager-a-fool/"/>
    <updated>2015-07-07T23:18:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/07/is-project-manager-a-fool</id>
    <content type="html"><![CDATA[<h3>一些背景故事</h3>

<p>坊间流传着很多关于PM（Project Manager，项目经理）的笑话，在这些不无刻薄的笑话中，PM往往被描述成一个盲目的承诺客户需求变更，不了解实际情况而又喜欢指手画脚的专门坑开发的家伙。毋庸置疑，这些笑话当然是那些聪明的<strong>开发</strong>发明的（不过你得承认，在很多团队，这些笑话其实是实实在在每天都在发生着的）。</p>

<p>在智力工作中，对于开发的实际进度，开发速率等问题，具体着手做的人永远比在背后指手画脚的人更有发言权。软件开发正是一项智力活动，优秀的软件无法通过人力的堆积而产生。一个关于PM的经典的讽刺是：PM就是那些指望着9个女人在1个月内生出1个小孩的二货。从传统的意义上来说，这个笑话还真是一针见血。</p>

<p><img src="/images/2015/07/keep-calm-i-m-the-project-manager-resized.png" alt="project manager, 来源:http://sd.keepcalm-o-matic.co.uk/i/keep-calm-i-m-the-project-manager.png" /></p>

<p>我记得在加入ThoughtWorks不久的时候，私底下经常听到这种论调：PM基本就是项目上被人鄙视（当然大家不会表现的那么明显就是了）的角色，基本上负责<strong>团队建设</strong>去哪儿这种杂事儿就行了，团队的其他人员可以高度自治，并不需要被管理，项目就会如预期般按时交付。</p>

<p>这些论调在某些情况下可能是对的。但是如果在国内项目的这个上下文里，没有一个专业的PM来协助项目，控制需求，划定项目范围，与客户谈判等等，没有任何一个项目是可以真正成功交付的，指望<em>高度自治</em>的开发们来完成项目？咱们还是现实一些吧。</p>

<p>一个悲剧的事实是，开发人员往往都恃才傲物，有时还会带着一幅要来拯救世界的心态来做项目，这事实上和客户的期望，以及PM的期望是有很大出入的。在项目启动之初，PM会面临重重困难：首先，团队里的每个人都不好管，而且每个人都认为自己不需要被管理（当然这种想法在大部分时候都是错误的）；其次，PM需要和客户快速建立信任，并推动项目进入正轨；最后，往往留给PM自己的时间也非常有限，他们也需要学习大量的项目相关的上下文（业务上下文，人员关系，资源协调等）。</p>

<h3>除了催进度，PM平时还干点啥？</h3>

<p>本质上开说，PM其实就是一个轮询器：识别所有的项目风险，然后不断跟进。项目风险可能是技术风险，比如某个技术上压根搞不定的问题。也可能资源风险，比如人手不够，或者开发者很多，但是没有足够的设计师协助，这些风险都会导致项目无法按照时间交付。一个客观事实是，所有项目都会变化，做完售前到需求分析结束之后，需求可能会发生巨大变化，如果还按照报价来做项目很可能会<strong>亏本</strong>。</p>

<p>PM的一个重要职责就是在项目之初将项目范围定下来，这个范围的划分非常依赖经验：划得少了团队得天天加班，累得跟狗一样，然后才能保证交付（据我的经验，虽然项目一般不会天天加班，但是总会有一些攻关，打补丁的事儿，最后还是会累成狗），划得多了客户不买单，意思是就这个小功能你要做两个月，绝对不行。PM需要协调这些不一致，还需要和销售，客户等方面不断谈判，写方案，排计划，简而言之，也是累跟狗一样（而且潜在的，还可能被那些天真幼稚的开发坑 — 开发经常会高估自己的开发速度，反正我还没遇到过低估的，你见过吗？）。</p>

<p>我们每天看到的PM干的最多的事情就是：元芳，那个接口怎么样了？什么时候能做完，有什么blocker？李柯，昨天说的代理的事情怎么样了？小波，高保真什么时候出？何方，我们周三下午要showcase，麻烦你订一下会议室吧……</p>

<p><img src="/images/2015/07/pm-resized.png" alt="pm" /></p>

<h3>除了写代码，Dev平时还干点啥？</h3>

<p>如果脱离开PM的角度，做为一个孤傲的开发，时常会觉得PM为什么老是问我进度，是不是怀疑我的能力？为什么监视我的工作？相信我，其实他才不想监视你。但是你设想一下：如果你不参与代码编写，每天只是看旁边的哥们写，你如何知道他实际的进度呢？而且众所周知，开发很难准确的更新自己的工作进度，而且遇到问题也很少积极主动的报告，通常都会自己埋头尝试解决。那么，轮询显然是一种成本最低，反馈最快的方法。</p>

<p>不主动更新进度是另外一个大问题，不过这个得单独说。关于更新进度，典型的的场景是：早上站会的时候，开发目光呆滞的盯着某个卡片，努力回忆其中的验收条件以及自己的当前进度，如果恰好脑海中的技术细节和卡片的描述在某个点上匹配了，他会迅速的告诉你，目前进展良好，今天上午应该就可以做完。开发在更新进度时，不是盲目乐观，就是跳进太细节的地方进行讨论，最后讨论的结果就是：跟没更新一样，除了浪费了10分钟时间。但是别忘了，PM会在15分钟之后再来轮询一次。</p>

<p>PM每周都需要汇总很多数字，比如本迭代完成的点数，剩余的点数，总体进度如何，有没有人有请假计划，遇到什么blocker，每个blocker的具体原因，每个风险点的最终日期是何时，等等等等。他肯定不能记住这些数字，所以可能一天之内向你询问数次。</p>

<h3>PM的其他职责/技能</h3>

<p>上边说到的其实只是描述PM的辛苦，而最微妙，最考验PM的是其“察言观色”的技能。这绝对是一个工作经验在10年之内完全无法获得的技能（而且是在中国的项目上工作10年）。比如，在showcase的时候，有个客户说，嗯，挺好，整个流程就是这样的，后续你们的UI是不是还会美化？如果你遇到这个情况，请问，这个客户是什么意思？</p>

<p>如果你能回答上这个问题（而不是提出问题），那说明你还离PM差十万八千里。成熟的PM会先判断，问这个问题的人是什么角色，以及他在系统中的话语权如何，还有其他人就此问题的反应如何等等因素，然后找到一个合适的答案。</p>

<p>PM另一个绝技是扯皮（不是贬义），开发会花一个下午（我是说10分钟）去跟客户讨论需求的范围吗？或者会为5个人天来讨价还价吗？我想开发大概会说，尼玛，找其他供应商吧，老子不伺候了。</p>

<p>一个项目的成功，需要多方合作，这里说的合作并不局限在甲方和乙方之间，即使乙方的团队之中，也需要很紧密的合作。比如项目经理和开发，设计师之间的合作。如果仅仅从开发的角度来看，PM有时候看起来就是和客户站在一起来整开发的一样，比如催进度，过分保守的估算人天（导致团队加班赶工）。PM需要释放团队中的负面情绪，保证团队士气，还需要他做一些开发不屑于做的琐碎的事情。</p>

<h3>设身处地，替他人着想</h3>

<p>本质来来说，每个项目都是一次生意。在去掉那些繁杂的流程和形式之后，做一个项目和你去菜市场买菜其实并无二致。举个例子，根据传统，软件开发界特别喜欢找建筑行业做类比，我也找个建筑方面例子。装修房子的时候，我们会要求施工方提供图纸（水电改造，基本设计等），按期交付（确定工期），同时会界定项目范围（比如刷墙，贴地砖，吊顶，封阳台等等），会要求工人按时来上班，正常出勤，认真工作，直到项目结束。过程中我们还会讨价还价，比如捎带着把栏杆拆除，捎带着敲掉一面隔离墙等等。在过程中，我们还会敲敲地砖，检查过门石，检查吊顶，测试水电等等。作为甲方，这些活动相信没有人会觉得过分。</p>

<p>但是一旦我们做乙方，也就是施工方的时候，情况就全变了。比如客户要求打卡，有人会觉得不爽，客户要求代码review，有人会觉得不爽，要求代码有设计文档，有人会觉得不爽，要求设计有多个备选方案，有人会觉得不爽。大多数情况下，这都是虚无缥缈的虚荣在作祟，这种情况所在多有，不过还不致命。一旦涉及到讨价还价（不是商务上的讨价还价，而是和客户就工作量达不成一致，或者就某个技术方案达不成一致之后），开发全部歇菜，一言不合，转身就走，压根不具备讨价换件的能力，这样还怎么做生意啊？设身处地想一下，如果你是甲方，当提出了一些合理的要求（比如需要一方提供验收标准，通过验收测试等），结果施工方还一脸的“我不跟你说了，你就是以大傻B”，你能乐意吗？</p>

<h3>如何合作？</h3>

<p>说了这么多，这两种角色在同一个项目上要如何合作呢？我想，作为开发来说，有这样几点可能：</p>

<p>首先，理解PM的工作。在很多时候，开发会有莫名其妙的优越感（其实每个角色都会有了，比如销售看不上技术人员，技术Lead看不上PM等等），主要原因其实是<strong>坐井观天</strong>，对其他角色的辛苦和工作不清楚。然后错误的认为别人的工作都很low。</p>

<p>之前听一个同事讲过一个小session，里面有一点我印象非常深刻：不要因为一个人<strong>不会某个技术</strong>而鄙视他。就好比你不应该因为不会弹钢琴，而被一个会弹钢琴的人鄙视一样。道理很简单，但是开发在长期的“宅”生涯或者坐井观天中，进化出了这种非理性的观点：如果一个人连vim（此处的vim可以换成任何其他技术）都不会，就压根不足以谈人生。</p>

<p>其次，学习如何报告进度。PM催你的根本原因是进度不明确，如果每一个潜在的风险都清楚的显示着进度，而且有明确的负责人，PM就会降低轮询的频率。这需要开发经过刻苦的练习才能达到：</p>

<ul>
<li>站会前自己花3分钟整理一下昨天做的工作</li>
<li>根据story的验收条件（最好有和BA/QA一起的讨论需求），进行合理的任务划分（tasking技能）</li>
<li>可以借助便签纸等工具，帮助自己明确进度（划分了5个子任务，昨天完成了3个，那么可以粗略的估计为60%）</li>
</ul>


<p><img src="/images/2015/07/tasking-resized.png" alt="tasking" /></p>

<p>再次，合理估算。有些时候，新人（来自于传统管理环境的新人）可能会误以为PM是一个管理的角色，或者处于某些考虑会在PM询问进度时做出一些错误的回答。比如PM在迭代启动会议上是问这个迭代我们有没有可能做完所有计划内的任务，作为一个负责任的开发，你需要在第一时间指出那些“非理性”的期望，以便PM进行更加准确的计划。</p>

<ul>
<li>明确告诉PM，有哪些需求是不可能按时交付的，PM会根据实际情况来重新定计划，并和客户确认</li>
<li>明确告诉PM一些可能的风险，<strong>团队整体</strong>对交付负责，而不是PM，或者开发</li>
</ul>


<p>按照经验，项目从来就不会按照计划进行，在做好一个粗略的计划之后，PM的职责更多的是进行动态调整。所以团队内部至少需要保持信息的流通，虽然可能短期来看可能会影响开发速度，但是从整体上来看，可以减少很多不必要的浪费。</p>

<p>简而言之，要站在别人的角度考虑问题：<strong>如果换做是你，你会怎么做？</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们真的缺前端工程师吗？]]></title>
    <link href="http://abruzzi.github.com/2015/06/do-we-really-short-for-front-end-developer/"/>
    <updated>2015-06-14T23:33:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/06/do-we-really-short-for-front-end-developer</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>这两天在好几个地方都看到了一篇关于<a href="http://chuansong.me/n/1369941">为什么整个互联网行业都缺前端工程师？</a>的文章，文章本身是去年的，中心思想是：其实我们并不缺前端工程师，我们缺的是优秀的前端工程师。我还是比较同意作者观点的，不过略有意犹未尽的感觉。于是我结合自己的经验，也来聊一下这个话题：<strong>我们真的缺前端工程师吗？</strong></p>

<p><code>
These walls are kind of funny like that. First you hate them, then you get used to them.Enough time passed, get so you depend on them. That’s institutionalising.
</code></p>

<p>传统软件公司划分开发者的方式下，在前端部门的程序员永远不会去读缓存数据部分的代码，设计师也不太可能去和开发坐在一起，开发也不知道软件最终软件会以何种方式部署在服务器上。</p>

<h3>什么是“前端”工程师</h3>

<p>我在招聘广告和办公室的一些对话中，听到了一个新的角色：UI Dev，事实上我在知乎上还回答过一个<a href="http://www.zhihu.com/question/30170650">关于ThoughtWorks的UI Dev的问题</a>。简而言之，UI Dev可以快速的把设计师的作品实现为HTML/CSS/JavaScript代码。</p>

<p><img src="/images/2015/06/website-development-resized.png" alt="front-end development" /></p>

<p>如果按照这个标准，我觉得UI Dev对自己的要求太低了。毕竟要学会HTML/CSS实现mockup并不困难，但是成为一名前端工程师则需要掌握更多的知识：</p>

<ul>
<li>会用PS来进行图片的处理（比如切图，微调等）</li>
<li>用HTML/CSS实现mockup（可能还有<a href="http://sass-lang.com/">SASS</a>/<a href="http://lesscss.org/">LESS</a>等工具）</li>
<li>熟悉JavaScript（比如前端的MVVM框架，客户端模板）</li>
<li>前端开发的工作流程（代码检查，精简化，模块化CSS，LiveReload，调试）</li>
<li>编写测试（静态检查，单元测试）</li>
<li>跨浏览器、跨设备的解决方法（不同分辨率，不同厂商）</li>
<li>会根据项目的特点选择不同的前端技术栈（移动端，Web站点，响应式设计等）</li>
</ul>


<p>在有了基础的HTML/CSS/JS技能之后，你会尝试做的更好：</p>

<ul>
<li>如何更高效的操作DOM</li>
<li>如何将CSS写的更加清晰易懂</li>
<li>如何编写更加易于维护的代码（更有意义的单元测试）</li>
<li>如何组织大型的项目结构，模块化，组件化等等</li>
</ul>


<p>这些要求事实上已经不那么容易做到了。它可能会花费你2到3年时间来完全掌握。但是2到3年之后，即便你已经成为了一个“合格的”前端工程师，这也还远远不够。在现实世界中，一个软件产品除了前端，还有非常广阔的空间，还有很多有趣的东西值得学习：</p>

<ul>
<li>HTTP协议本身（缓存，鉴权）</li>
<li>Web容器/HTTP服务器如何工作</li>
<li>无状态的Web应用的工作原理（如何让网站正确地运行在集群上）</li>
<li>动态，静态内容如何分离部署（反向代理配置）</li>
<li>安全机制如何配置</li>
<li>监控机制如何配置</li>
</ul>


<p>有了这些，也算是有点端到端的意思了。这时你也已经不是一个“纯前端”工程师了，系统中的大部分问题你都可以搞定，不过日常工作中可能更多的职责还是做前端的开发。但是这些还不够，软件除了交付之外，还有一些非功能性的需求：</p>

<ul>
<li>端到端测试（UI测试，比如<a href="http://www.seleniumhq.org/">selenium server</a>/web driver）</li>
<li>devops（比如数据库环境，测试服务器，CI服务器的自动化provision）</li>
<li>基本的UI设计原则（在某些页面确实的情况下，根据系统的已有UI做设计）</li>
<li>数据库性能优化</li>
<li>性能测试</li>
</ul>


<p><del>不过这些还只是我对于Web开发这个领域的总结。其他领域，比如大数据，机器学习，GIS，图像/视频处理等等。</del></p>

<p>这时候，你才能算是一个严格意义上的“前端”工程师。不从系统的角度来思考，不真正做一些后端开发/配置，并不能算是前端工程师，或者可以被称为<em>偏前端</em>工程师（partial frontend developer）。但是即使称为上边这样的“前端工程师”，我想这离一个优秀的工程师还是有<strong>很大差距</strong>的。</p>

<p>我跟一位<a href="http://www.caicaiwan.com/">设计师同事</a>聊过这个问题：</p>

<p><code>
Dev眼中的世界是这样的，从墙上（物理的或者电子的）上找到一些卡片（story卡或者需求文档说明书），然后撸袖子开干，干的过程中有很多自以为是的理解，同样有一些自以为是的牛逼实践（TDD啊，自动化啊），最后功能做完，大功告成，然后接着做下一个卡片。传统的Dev，或者苦逼屌丝程序员的世界就是这样的：需求从哪儿来，不知道；做完之后谁来负责质量，不知道；最终上线的时候怎么发布，不知道；线上有问题了怎么办，不知道。
</code></p>

<p>以及</p>

<p><code>
在ThoughtWorks，Dev的工作有了很大的变化，一个最明显的变化是边界的模糊。比如很多项目都不设QA角色，所有人都对质量负责，都做测试，也有OPs角色，但是大部分非生产环境都是Dev自己发布。也就是说，软件/项目生命周期中的大部分实践我们都能涉足，而且可以带来改进，提升效率。但是这只是往下游（从开发，到测试，到部署，到运维），反过来看上游，比如需求从哪儿来，Dev还是不知道。这毫无疑问是一个令人沮丧的事实，因为这需求的产生才是核心，也就是我昨天跟你聊的：一个idea如何变成一个可视化的原型，然后进一步演进为项目原型？
</code></p>

<p>开发工作不应该仅仅局限在编码上，作为开发者/工程师，应该尽可能的多了解一些上下文：比如我们的项目最终是给谁用的，需求从何而来，项目是如何部署在线上的等等。</p>

<p><img src="/images/2015/06/software-life-cycle-resized.png" alt="software life cycle" /></p>

<p>简而言之，开发者视野应该放开开阔一些。不要将自己局限在某种角色上，不但不要局限在前端/后端开发上，压根就不要局限在开发这种角色本身上，你在系统中，可以是设计师，还可以是业务分析师。虽然不一定最终要你去转行做BA，或者UX，但是更广阔的视野可以使你更加高效的发挥自己的作用，也可以在和别的角色互动式，快速的了解上下文。</p>

<p>我所理解的，前端不一定要熟知所有这些知识和技能，但是<strong>一定不要认为自己做好了前端的一亩三分地就足够了</strong>，不要给自己设限。跨界会给你带来难以估量的好处，一个角色做久了，难免会产生一些盲点。这时候，换个视角，从其他角色的角度来看待你的工作，又会有很多新的发现。而且不仅如此，很可能你会发现之前很麻烦，很难搞定的事情，在新的方法/视角下变得很容易。</p>

<h3>我的故事</h3>

<h4>其实，我是一名后端开发</h4>

<p>工作之后，我在很长一段时间是专注于“非前端”的领域。和很多刚入行的新人一样，我对计算机能触及的几乎一切领域都感兴趣：语言解释器，人工智能（遗传算法，隐式马尔科夫模型，自动纠错，模式识别），嵌入式开发，图形处理，操作系统的进程调度，进程间通信，多线程模型，各种脚本语言（python，ruby，JavaScript等等），另外，日常开发流程中的一些工具的定制化也会花去我很多的时间，比如如何配置vim，写几个小脚本来和编辑器做集成等等。更别说那些令人一听就觉得激动的编程范式：面向对象，基于消息总线，函数式编程等等。如果你感兴趣，可以看看我<a href="http://abruzzi.iteye.com/">几年前的博客</a>。</p>

<p>我的上一家公司的产品是一个省级电网的收费/计费系统（电其实和我们在超市里购买的其他生活用品一样，也是一种商品）。我在那里工作了差不多两年，日常的开发方式就是ssh登陆到RHEL（Redhat Enterprise Linux）服务器上，用vim（当然有一堆的vim插件）开发C代码，调试器是gdb（对，就是那个很牛逼，但是对新手特别不友好的gdb）。</p>

<p>我们用C语言给Apache的httpd写了一个扩展module，大约相当于现在rack里的中间件，这个module要和后端的一个要复杂的多的模块通信，其中不但涉及网络通信，还有*nix管道，缓冲，并发等等考虑。在这两年里，我几乎没有碰过任何的Web界面上的东西（除了用php写了一两百行的页面之外）。</p>

<p>在加入这家公司之前，我在一家用Java做报表的公司工作，技术栈为J2EE。其中有一些前端的工作，但是并不很多，而且说实话，我当时有些看不太上这些技术。HTML/CSS在我心目中的地位比线程池，语言解析等差远了，所以我也没有认真地去系统学习。</p>

<p>在加入ThoughtWorks之前，在“前端”方面，唯一算是比较擅长的也不过是写JavaScript，而且对于前端的MVVM框架，双向绑定，模块化等高级货都没听过。且不能论HTML/CSS的最佳实践，连根据设计稿做出一个静态页面的的能力也不具备。我之前有一点JSP/HTML经验，而CSS经验也并没有超出如何画一个细线表格的范畴。换句话说，我的前端（特别是HTML/CSS）是最近才学会的。</p>

<h4>ThoughtWorks的开发</h4>

<p>在ThoughtWorks，很多团队是按照feature团队来组建的。相对于传统的component团队（按部门划分，比如研发组，测试组，设计组等，每个组还有可能会再细分成如用户调研，流程设计，视觉设计等等），feature团队里配备了软件开发过程中需要的几乎所有角色：业务分析，测试工程师，开发工程师，设计师（设计师一般不会常驻），有的团队还有项目经理的角色。</p>

<p>在feature团队里，你可以很容易看到不同的角色是如何工作的，很多时候，开发会和设计师一起来调整颜色，排版，布局，也可能和测试一起编写自动化测试用例，showcase等。也就是说，角色之间的藩篱在淡化，而就开发这一种角色而言，对于前端/后端的区分也会显得非常模糊，因为需求划分之后的story（敏捷开发中的一个术语，其实就是需求的一种展现方式）是端到端的，比如一个商品列表展示的story，会包括</p>

<ul>
<li>数据库的表结构</li>
<li>访问数据库的<a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>部分，</li>
<li>使用ORM的业务逻辑service</li>
<li>响应客户端的controller（消费JSON或者XML的HTTP接口）</li>
<li>发送请求，处理响应的JavaScript代码</li>
<li>和设计稿一致的CSS样式</li>
</ul>


<p>而且在这个过程中还会涉及到一些外围的工具</p>

<ul>
<li>虚拟机环境准备</li>
<li>数据库连接</li>
<li>自动化测试（单元测试，集成测试，可能还有UI测试）</li>
<li>数据库迁移脚本</li>
</ul>


<p>在这个过程中，开发者需要掌握和开发过程相关的一切实践中的一切工具.</p>

<p>在我的<a href="http://www.thoughtworks.com/">ThoughtWorks</a>的第一个项目中，我是以Java开发工程师角色加入的，下项目的时候，我学会了自动化provision，<a href="https://cucumber.io/">cucumber</a>测试工具，Rails，<a href="https://gradle.org/">gradle</a>（没错，我之前用Java都是用IDE构建的，在Linux世界我用make），<a href="http://jasmine.github.io/2.0/introduction.html">jasmine</a>测试工具，<a href="http://backbonejs.org/">Backbone.js</a>，haml.js。</p>

<p>第二个项目的时候，我是以前端工程师角色加入，下项目的时候，我学会了nginx配置缓存、负载均衡服务器，<a href="http://gatling.io/">gatling</a>测试工具，Hadoop/Spark等的集群配置，还有一些和项目相关的<a href="http://icodeit.org/2014/04/intro-map-gis/">GIS（地理信息系统）</a>的技术栈，前后端分离策略等。</p>

<p>第三个项目我是以Java开发工程师角色加入的，下项目的时候，我学会了如何做性能测试，如何建立<a href="http://dashing.io/#setup">一个漂亮的Dashboard</a>（可以用来展现CI等），而且在业余时间系统的学习了CSS3和HTML5，将之前零敲碎打的那些知识串起来，这些总结做了几次内部培训后，还整理成了<a href="https://selfstore.io/products/348">一本电子书</a>。</p>

<p>第四个项目我又变成了一个前端工程师，但是这个项目有意思的地方是跟mobile相关，于是页面性能，体验又变成了一个重点，下项目的时候，我对无状态的Web应用，session的持久化，<a href="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details">CSS3的动画</a>，用Backbone.js组织多页面的方式等等又有了新的理解。</p>

<p>如果这些经历造成了你觉得我很牛的错觉，那我应该道歉。我觉得自己勉强可以算是个合格的程序员：对学习保持着热情，对解决问题保持着热情，仅此而已。在项目上，如果我发现了问题，我就想办法解决，如果属于知识欠缺，那我就会去学习。我还远远没有到达精通这些技术的地步，但是在工程实践领域，根据<a href="https://en.wikipedia.org/wiki/Pareto_principle">80/20原则</a>，这些粗浅的知识足以解决80%的问题，而另外的20%，我们才真正需要一个专家来帮忙。也就是说，团队里需要有一个能解决20%的问题的前端工程师，而其他的80%的前端工作，应该可以被其他所有的开发完成，对于后端开发也是一样。</p>

<p><del>尝试从系统级别去解决一个问题，而不是将问题抛给另外一个角色（后端工程师，UX或者QA）</del></p>

<p>我是一个Dev，但是花了一些时间来学习界面设计，这里是我从设计到实现的两个小页面：</p>

<p><img src="/images/2015/06/ilearn-resized.png" alt="ilearn" /></p>

<p><img src="/images/2015/06/lightweight-resized.png" alt="lightweight" /></p>

<h3>总结</h3>

<p>我们缺的从来都不是前端/后端工程师，而是<strong>工程师</strong>(或者那些会系统思考，并总是想着解决问题的人)。角色划分在大的机构内可能是有意义的，就像历史上工厂里，工人被分为车工，钳工，木工，电工。但是这种模式在软件开发中未必好用，<strong>具体而微</strong>的小团队可能更具竞争力。而在一个个的小团队中，再细分前端后端就显得比较滑稽了。团队中的每个成员都应该具备基本的端到端能力（不仅仅是开发，更应该是具有业务上下文，即每个人都清楚我们要交付的最终产品是什么，以及这个产品是如何帮助最终用户的），每个成员也都需要为最终的交付物负责，而不是为自己的职责负责。</p>
]]></content>
  </entry>
  
</feed>
