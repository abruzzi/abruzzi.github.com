<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2016-02-01T00:36:07+11:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[不想当UX的开发不是好咨询师]]></title>
    <link href="http://abruzzi.github.com/2016/01/for-those-dev-who-doesnt-want-to-be-a-ux-cannot-be-a-good-consulant/"/>
    <updated>2016-01-31T23:04:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/for-those-dev-who-doesnt-want-to-be-a-ux-cannot-be-a-good-consulant</id>
    <content type="html"><![CDATA[<h2>成为咨询师</h2>

<p>本文旨在帮助<code>开发</code>完成向<code>咨询师</code>的转变，内容不但涉及向<code>UX</code>学习，还包括思维方式的转变。我尽量采用一些亲历的例子来说明该如何做，也会适当的解释为什么需要这样做。不过在展开详细讨论之前，首先来澄清这里提到的三种角色。</p>

<h3>开发（Developer）角色</h3>

<p><code>开发</code>是指那些喜欢写代码，享受写代码，喜欢纯粹，讨厌办公室政治，永远穿T恤的有些偏执的程序员。跟他们打交道，有这样一些注意事项：</p>

<ul>
<li>不要让他们帮你盗<code>QQ</code>号</li>
<li>不要让他们帮你修电脑或者装Windows系统</li>
<li>不要跟他们讨论<code>人文/政治</code>类的问题</li>
</ul>


<p><code>开发</code>往往还单纯的可爱，除此之外，他们还有这样一些特点：</p>

<ul>
<li>逻辑清晰</li>
<li>与人争辩时往往可以通过清晰的逻辑而获胜</li>
<li>单身</li>
</ul>


<p>业界已经有很多关于<code>开发</code>的描述了，我这里也有一个描述<code>开发</code>的列表：</p>

<p><del>
当然，要严格界定一个人是不是<code>开发</code>是非常困难的，大多数情况下，他们沉默寡言，遇到程序中的bug或者在调试某些库的问题时眼神呆滞，口中念念有词，他们不太喜欢和陌生人说话，在晚上精神充沛，白天则显得有些呆滞，喜欢喝咖啡，相信世界上有绝对的正确和错误，往往会带着非黑即白的二分法来看待事物，生活很难自理，喜欢机械键盘/电子设备，周末宁愿宅在家里写代码也不去做社交……
</del></p>

<h3>用户体验设计师（UX）</h3>

<p><code>UX</code>是指用户体验设计师，在本文的上下文中，更偏向与非<code>视觉设计</code>的那些设计师（产品设计师）。在项目中，他们会做用户调研，竞品分析，信息架构简历，交互设计（纸上原型，低保真）等活动，并负责开发纸上原型，验证这些原型等。</p>

<p>和<code>UX</code>打交道，也有一些应该注意的点，比如：</p>

<ul>
<li>不要叫他们美工</li>
<li>不要对他们说诸如：“帮我美化一下这个页面”，“这个颜色得再亮一些”之类的话</li>
<li>不要跟他们讲关于程序员的笑话</li>
</ul>


<p>事实上，人们对<code>UX</code>的误解很深。提到<code>UX</code>人们的第一反应是<code>PhotoShop</code>，P图/切图。这仅仅是他们日常工作中很小的一部分。大部分<code>UX</code>还要做很多用户研究，信息架构整理的事情。老实说，我在去年5月之前的对<code>UX</code>的认识和大部分<code>开发</code>的认识是一样的，但是在后来的项目上和多个<code>UX</code>合作过之后，我彻底改变了原先那种偏见，开始敬佩他们，并向他们学习。</p>

<p>设计工作可以细分为这样一些不同的方面（图片来源网络）：</p>

<p><img src="/images/2016/01/jjg-resized.png" alt="JJG" /></p>

<p><code>UX</code>的一项特别的技能在于能从复杂的现实世界中抽象出清晰的信息（用户画像，体验地图甚至最后的用户故事）。这项技能不但重要，而且还很牛逼。</p>

<h4>知识的诅咒</h4>

<p><a href="https://book.douban.com/subject/25782902/">《反脆弱》</a>里有个有意思的例子：人们仅仅创造了非常有限的词汇来描述颜色，比如蓝色，红色，而任何一个视觉正常的人都可以轻松的识别出数百种不同的颜色。也就是说，人们可以很轻松的理解相当复杂的事物，但是很难向别人描述该事物（想象一下向别人描述一只<code>章鱼</code>的颜色）。</p>

<p>人们对于现实世界中的事情（特别是复杂的业务场景）往往只能意会而很难言传，再加上知识的诅咒（我在<a href="http://icodeit.org/2015/08/how-to-write-a-book/">《如何写一本书》</a>里，详细讨论了这种常见的陷阱）的存在，当用户在描述A的时候，在没有上下文的人听来，很可能是B或者C。这种情况在软件开发中非常常见，也是很多项目之所以延期的原因（大量并无必要的返工，需求澄清等）。</p>

<p>在项目前期，<code>UX</code>需要和客户坐在一起，将客户的需求分析清晰。分析细节包括业务场景，用户画像生成，信息架构，体验地图等等，这些信息并不是天然就显现的，恰恰相反，它们需要UX经过很多轮的辛苦引导，从用户的脑海里<code>提取</code>出来的。</p>

<p>这里需要<code>UX</code>的核心能力是：</p>

<ul>
<li>有目的的抛出问题，引导客户进行发散</li>
<li>有节奏的收敛，形成共识</li>
<li>不断修正过程中的错误</li>
<li>可视化能力（这可能是大部分人觉得唯一和UX相关的点）</li>
</ul>


<h3>咨询师</h3>

<p><code>咨询师</code>是指那些根据自己的丰富经验来帮助客户解决具体问题的人。这些问题并不一定局限在技术上 —— 比如架构的设计，具体前端/后端技术的选定，还包括一些流程的改善。比如引入新的<code>工程实践</code>来缩减项目的周期时间，帮助团队发现问题，建设团队的能力，作为各个团队间的润滑剂帮助项目成功等等。</p>

<p><code>咨询师</code>工作中的一个常见的场景是：</p>

<ul>
<li>列出目前遇到的问题</li>
<li>确定各个问题的优先级（和各个利益方）</li>
<li>制定方案</li>
<li>给方案加上时间，形成计划</li>
<li>细化计划中的条目，并促成它</li>
</ul>


<h4>引导/启发</h4>

<p>我在印度的某一期<code>TWU</code>当教练的时候，发现了一个很有意思的现象，国外的同事在组织培训时更强调用<code>引导</code>/<code>启发</code>的方式，让学生们自己得出结论，并在课堂上进行讨论，以期教学相长。只有在过程中有<code>启而不发</code>的情况出现时，教练才会适当抛出自己的开发，并再次启动讨论。</p>

<p><img src="/images/2016/01/twu22-resized.png" alt="TWU 33" /></p>

<p>与我一直的认识不同的是，这种方式效果很好。通过一些适当的启发，学生很容易自己讨论出一些有趣的看法，然后教练在这个基础上做一些总结，并帮助他们分析不同看法/想法之间的优劣。</p>

<p>我非常认同这种模式，后来自己组织的其他培训/workshop也都尽量采取这种方式。咨询师在客户现场，也应该采取这种<code>引导</code>的方式帮助团队来完成能力建设，而不是事必躬亲。</p>

<h2>角色转化</h2>

<p>从<code>开发者</code>视角切换到<code>咨询师</code>的第一要诀就是：让团队解决自己遇到的问题！乍听起来，<code>咨询师</code>好像变成一个多余的角色了：既然团队自己可以搞定，还要<code>咨询师</code>干什么呢？<code>咨询师</code>的职责是让团队意识到问题，理清思路，制定解决方案，并逐步实施。</p>

<h3>使能/赋能</h3>

<p>我们来看一个简单的例子：在客户现场，你发现团队往往在集成时会花费很多额外的时间和返工，开发过程中大家各自为政，没有人知道一次commit会给软件包造成什么影响。</p>

<p>如果你是一个<code>咨询师</code>，应该如何解决这个问题？一个常犯的错误是，直接上手帮助团队搭建<a href="http://www.martinfowler.com/articles/continuousIntegration.html">持续集成</a>（CI）环境，并设置CI纪律（比如build红了不许过夜，红的时候其他人都不许commit等）。</p>

<p>一种更好的做法是：做为<code>咨询师</code>，首先需要帮助团队认识到这个问题，你需要让所有人都知道，我们现在的问题是什么。在所有人都清楚了这一点之后，你需要提出（或者<code>引导</code>出）持续集成的概念（因为根据经验，这是一种可以很好的解决集成时额外的返工现象的好办法）。</p>

<p>但是对于不熟悉<code>持续集成</code>的团队来说，搭建一个持续集成环境是一个非常<code>复杂</code>的任务。因此你需要分解这个任务为一些更小的，可以被解决的问题。</p>

<ul>
<li>申请虚拟机资源</li>
<li>安装<a href="https://jenkins-ci.org/">jenkins</a>（包括安装JVM，创建用户等）</li>
<li>配置本地构建脚本到jenkins（构建脚本，自动化测试等）</li>
<li>申请显示器资源（作为CI Monitor）</li>
<li>将结果显式在CI Monitor上</li>
</ul>


<p>有了任务之后，你需要分别为这些子任务分配owner。对比搭建<code>持续集成环境</code>这样的大任务，这些小的任务已经非常具体，更重要的是，他可以被团队中任何人理解并解决。</p>

<h3>学习做引导</h3>

<p>除了思维方式的转变，以及自身过硬的专业技能（比如clean code/重构能力，自动化测试，DevOps，持续交付经验等）之外，开发者需要从<code>UX</code>那里学习如何发现问题，并将问题可视化出来的技能。</p>

<p>当你发现团队面临某个问题是，可以通过组织一个类似<code>头脑风暴</code>的会议来帮助团队梳理：</p>

<ul>
<li>提出问题</li>
<li>维护会议纪律，保证所有人都贡献自己的想法</li>
<li>将想法/问题归类</li>
<li>找出问题的解决方案</li>
<li>制定计划（包括时间点和owner）</li>
</ul>


<p>关于如何做引导的详细信息，还可以参考我的<a href="http://icodeit.org/2016/01/how-to-facilitate/">上一篇文章</a>。</p>

<h3>进一步的阅读</h3>

<p>除了上边提到的</p>

<ol>
<li>思维方式的转变</li>
<li>向<code>UX</code>学习引导的技巧</li>
</ol>


<p>之外，事实上还有很多技巧和内容需要学习：</p>

<ul>
<li><a href="https://book.douban.com/subject/25899338/">《引导的秘诀》</a></li>
<li><a href="https://book.douban.com/subject/10433731/">《视觉会议》</a></li>
<li><a href="https://book.douban.com/subject/4051739/">《第五项修炼》</a></li>
<li><a href="https://book.douban.com/subject/1156866/">《系统思考》</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当我们谈论引导时，我们谈些什么？]]></title>
    <link href="http://abruzzi.github.com/2016/01/how-to-facilitate/"/>
    <updated>2016-01-23T23:42:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/how-to-facilitate</id>
    <content type="html"><![CDATA[<h2>什么是引导（facilitation）</h2>

<p>引导（facilitation）的词根来源与拉丁语“facil”，意思是“让……更容易”。而负责引导的<code>引导师</code>（facilitator）的核心职责是，通过一系列的活动、技巧，保证引导会议顺畅的进行，并解决整个过程中的问题，使得参与者就问题产生一个共识，达成一个结论。</p>

<p>其中可能涉及很多具体的问题，比如几乎在每个会议中都可能看到的：</p>

<ul>
<li>如果有人尝试将会议变成一言堂，如何处理？</li>
<li>如果参与者不愿意分享自己的观点，如何处理？</li>
<li>过程中，两个参与者产生了争执，如何处理？</li>
<li>如何把握节奏，刺激与会者发散？</li>
<li>如何在收集到足够信息后，进行收敛？</li>
</ul>


<p>显然，这是一个技术活儿。一次好的引导可以将与会者的众多想法，信息聚合起来，形成对团队下一步要做什么有极强指导意义的<code>方案</code>。</p>

<h2>日常的引导活动</h2>

<p>在平时的工作中，我们其实已经在频繁的使用引导活动，但是很少有人将其作为体系来关注，也很少有人能将这个能力应用在其他方面（比如在客户现场咨询，或者参加售前等）。引导是如此的常见，以至于我们对其视而不见。比如在interview完成之后，所有面试官和HR一起做的well/less well的列举；各种社区活动（Open Party，CDConf等）之后的回顾；每个项目在一个迭代结束后的Retro；对于某个问题的头脑风暴等等。</p>

<h3>项目回顾会议</h3>

<p>在开始前，引导师需要保证团队：</p>

<ul>
<li>每个人都有开发的态度</li>
<li>整个过程需要在一个足够安全的环境中进行（Safe Check）</li>
</ul>


<p>有时候，有Team Lead在场，新人可能不愿意对某事（比如最近加班有点过分）发表自己的看法等。这时候需要有<code>Safe Check</code>，比如分为1到5档，大家用不记名投票的方式来表述自己是否觉得安全。如果投票结果显示大部分人都觉得不安全，则需要与会的人中，职位最高的那个人离开会议，然后再做一次<code>Safe Check</code>，直到大家都觉得足够安全。不过，对于已经进行过多轮回顾的团队，我们往往会忽略掉这一步。</p>

<p>Retro过程是，团队坐在一起，回顾上一个迭代（通常是两个星期）做过的事情，有哪些做的比较好，哪些有待改进，有哪些疑惑等等。Retro可以有很多的形式，比如简单的<code>Well/Less Well/Questions</code>，更聚焦在产生<code>Action</code>的海星式等等。</p>

<p><img src="/images/2016/01/pens-resized.png" alt="pens" /></p>

<p>通常的顺序是：</p>

<ol>
<li>引导者请大家用纸笔将想法写在便签（stick）上</li>
<li>Time box这个过程（通常是5分钟）</li>
<li>大家将这些stick贴在墙上</li>
<li>引导者和团队一起过一遍所有的stick</li>
<li>归类相似的stick</li>
<li>引导者促进团队交流，讨论stick上的问题，并形成一些改进点（Action）</li>
</ol>


<p>Action一定要足够具体，并且需要一个所有者，<code>所有者</code>负责确保该<code>Action</code>一定会发生。比如团队发现上一个迭代中<code>Code review</code>做的不够好，一个<code>Action</code>就是每天下午5点有人来提醒大家来进行<code>Code review</code>。</p>

<p>如果这时候发现有太多的问题，团队可以用投票的方式选出本次Retro要讨论的数个stick。</p>

<h3>引导会议</h3>

<p>在日常工作中，我们几乎每天都有会议，而且越来越多的团队已经意识到冗长，无聊的会议有多大的杀伤力了。在很多会议上，与会者要么在刷新朋友圈，要么在对着笔记本电脑写代码或者读新闻，即使强制要求不许带电脑和手机的情况下，也无法限制参加者神游太虚。</p>

<p>根据《引导的秘诀》这本书里的定义，引导会议是</p>

<pre><code>引导会议是一个高度结构化的会议，会议中的领导者（引导者）引导参会人通过预先设定好的步骤达成所有参会人产生，理解并接受的结果。
</code></pre>

<p>引导会议需要充分调用参与者的积极性，每个人都需要足够聚焦，这要求引导者可以有能力使得团队振奋（比如幽默的风格，或者具有挑战性的问题等）。另外，每个人的idea都需要被充分重视（一个细节就是不要随意篡改你听到的内容，这是没有经验的引导者常犯的错误之一）。一旦所有参与者都积极起来，引导者就可以稍微退后一些，将舞台交给团队。</p>

<p>而有时候，情景则相反，大家都不发言，也没有看到明显的发言的趋势，这时候需要一些方法来激励。如果是团队都比较茫然，引导者需要列出一些简单而容易理解的步骤，帮助团队按照预设的节奏来逐步前进。比如，在一开始的时候就将agenda板书在墙上，并通过头脑风暴的方式，鼓励参与者来将自己的idea可视化出来。</p>

<p>一个典型的误区是，引导会议的最后结论是本来就存在与引导者脑海中的想法。如果仅从结果来看，这种情况可能发生，但是只能说是碰巧而已。一个好的引导者需要帮助与会者自己产生，并得出一个可行的，被广泛认可的方案，而不是强加一个自己的给团队。</p>

<p>我们最为专业的引导活动是UX团队在客户现场的<code>inception</code>，<code>inception</code>由一系列相互关联，环环相扣的工作坊组成，这些工作坊基本上都需要采用很多引导的技巧，帮助客户团队将自己的问题描述清楚，并形成一个所有参与者都达成一直的可行方案。</p>

<p><img src="/images/2016/01/sticks-resized.png" alt="sticks" /></p>

<p>如果你不知道如何开始一个引导会议，一个简单而通用的模式是：</p>

<ol>
<li>我们的现状是</li>
<li>我们的目标是</li>
<li>我们如何到达目标</li>
<li>在行进中，如何度量</li>
</ol>


<p>《引导的秘诀》里还提到了一种<code>5P</code>模式：目的(Purpose)，产出(Product)，与会人(Participant)，可能的问题(Probable issues)以及流程(Process)。</p>

<p>5P提示你在准备会议之前，需要尝试回答这几个问题</p>

<ul>
<li>为什么要开这次会议？主要目的是什么？</li>
<li>会议后的产出是什么？</li>
<li>谁需要参与会议？</li>
<li>在会议中，我们可能遇到什么问题？</li>
<li>遇到这些问题是，我们如何解决？</li>
</ul>


<h2>引导中的常用技巧</h2>

<p>在引导活动中，有一些基本的规则，可以保证引导会议的顺畅性，比如</p>

<ul>
<li>引导师需要有足够的权威（可以打断那些长篇大论，保证过程的流畅）</li>
<li>如果人数太多，可以使用token（比如一个玩具考拉，或者一个澳式橄榄球，只有持有token的人可以说话）</li>
<li>保持one conversation（不要交头接耳）</li>
<li>每张stick上只写一条问题/想法</li>
</ul>


<p>引导师必须有控制会话何时结束的能力，否则引导活动将会变成一发不可收拾的冗长会议。坚持<code>one conversation</code>可以保证参与者足够聚焦，也保证所有人都在同一个频道上。如果发现有交头接耳的，引导者可以直接打断并提醒之。</p>

<p>每张便签上只写一条想法，首先可以保证多样性，便于讨论，也便于后续的分类。另外，简洁的描述在一定程度上可以促进与会者进行讨论，而一个冗长的描述则会让人丧失兴趣。</p>

<p>另外还有一些比较基础的技巧：</p>

<ul>
<li>所有讨论都应该对事不对人（特别是一些负面的总结）</li>
<li>如果有人提出与议题并不特别相关，但是又特别重要的点时，可以将这些点记下来（不要轻易打击发言者的积极性）</li>
<li>不定时的总结，以确保参与者都在同一频道，并且有助于大家对进度的了解（是不是快结束了）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[穷人的持续集成与持续交付（下）]]></title>
    <link href="http://abruzzi.github.com/2016/01/a-poor-mans-cd-part2/"/>
    <updated>2016-01-10T14:05:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/a-poor-mans-cd-part2</id>
    <content type="html"><![CDATA[<h1>客户端程序的的持续交付</h1>

<p><a href="http://icodeit.org/2016/01/a-poor-mans-cd-part1/">上篇文章</a>介绍了如何使用一些免费的服务来实现服务器端API的持续集成、持续交付环境的搭建。有了服务端，自然需要有消费者，在本文中我们将使用另外一个工具来实现纯前端的站点的部署。</p>

<p>其中包括：</p>

<ul>
<li>持续集成（单元测试，集成测试等）</li>
<li>持续部署/持续交付</li>
<li>静态站点托管</li>
</ul>


<p>除此之外，我们还会涉及到：</p>

<ul>
<li><a href="https://github.com/natritmeyer/site_prism">自动化UI测试site_prism</a></li>
<li>静态站点的发布脚本</li>
<li>aws的<a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html">命令行工具</a></li>
</ul>


<p>我们的应用最后看起来是这样子的。</p>

<p><img src="/images/2016/01/bookmarks-app-resized.png" alt="bookmarks app" /></p>

<h2>技术选型</h2>

<p>我们在本文中，将采取另外一套免费服务来完成环境的搭建</p>

<ul>
<li><a href="http://www.thoughtworks.com/">ThoughtWorks</a>出品的<a href="https://snap-ci.com/">Snap CI</a>作为持续集成/持续交付环境</li>
<li><a href="https://console.aws.amazon.com/s3/home?region=us-west-2">AWS的S3</a>作为应用发布的地方</li>
</ul>


<p><code>Snap CI</code>是一个非常易于使用的持续交付环境，由于很多关于持续集成，持续交付的概念和实践都跟<code>ThoughtWorks</code>有关，所以这个产品对于构建，流水线，部署等等的支持也都做的非常好。</p>

<p><code>S3</code>是亚马逊的云存储平台，我们可以将静态资源完全托管在其上。<code>S3</code>的另一个好处是它可以将你的文件变成一个Web Site，比如你的目录中有<code>index.html</code>，这个文件就可以作为你的站点首页被其他人访问。这个对于我们这个前后端分离项目来说非常有用，我们的<code>css</code>，<code>js</code>，<code>font</code>文件，还有入口文件<code>index.html</code>都可以托管于其上。</p>

<h2>实例</h2>

<p>在本文的例子中，我们将定义3个<code>stage</code>。<code>Snap CI</code>将一次发布分为若干个<code>stage</code>，每个<code>stage</code>只做一件事情，如果一个<code>stage</code>失败了，后边的就不会接着执行。</p>

<p>我们的3个<code>stage</code>分别为：</p>

<ol>
<li>单元测试</li>
<li>集成测试</li>
<li>部署</li>
</ol>


<h3>准备工作</h3>

<p><code>bookmarks-frontend</code>是一个纯前端的应用，它会消费后端提供的API，但是其实它并不知道（也不应该知道）后端的API部署在什么地方：</p>

<p>```js</p>

<p>$(function() {</p>

<pre><code>var feeds = $.get(config.backend+'/api/feeds');
var favorite = $.get(config.backend+'/api/fav-feeds/1');

$.when(feeds, favorite).then(function(feeds, favorite) {
    //...
});
</code></pre>

<p>});
```</p>

<p>由于我们在本地开发时，需要<code>backend</code>指向本地的服务器，而发布之后，则希望它指向<a href="http://icodeit.org/2016/01/a-poor-mans-cd-part1/">上一篇文章</a>中提到的服务器，因此我们需要编写一点构建脚本来完成这件事儿：</p>

<p>```js
var backend = 'http://quiet-atoll-8237.herokuapp.com';</p>

<p>gulp.task('prepareConfig', function() {</p>

<pre><code>gulp.src(['assets/templates/config.js'])
.pipe(replace(/#backend#/g, 'http://localhost:8100'))
.pipe(gulp.dest('assets/script/'));
</code></pre>

<p>});</p>

<p>gulp.task('prepareRelease', function() {</p>

<pre><code>gulp.src(['assets/templates/config.js'])
.pipe(replace(/#backend#/g, backend))
.pipe(gulp.dest('assets/script/'));
</code></pre>

<p>});
```</p>

<p>我们定义了两个<code>gulp</code>的task，本地开发时，使用<code>prepareConfig</code>，要发布时，使用<code>prepareRelease</code>，然后定义一个简单的模板文件<code>config.js</code>：</p>

<p>```js
module.exports = {</p>

<pre><code>backend: '#backend#'
</code></pre>

<p>}
```</p>

<p>然后可以很简单的包装一下，方便本地开发和发布：</p>

<p><code>js
gulp.task('dev', ['prepareConfig', 'browserify', 'concatcss']);
gulp.task('build', ['prepareConfig', 'script', 'css']);
gulp.task('release', ['prepareRelease', 'script', 'css']);
</code></p>

<p>这样，我们在本地开发时，只需要简单的执行：</p>

<p><code>sh
$ gulp
</code></p>

<p>即可。而在发布阶段，只需要执行：</p>

<p><code>sh
$ gulp release
</code></p>

<h3>单元测试</h3>

<p>我们在<code>Snap CI</code>上将<code>github</code>上的代码库关联起来，然后添加一个名叫<code>unit-test</code>的<code>stage</code>，指定这个<code>stage</code>对应的命令为：</p>

<p><code>sh
npm install
gulp
</code></p>

<p><img src="/images/2016/01/snap-ci-unit-resized.png" alt="Snap CI unit" /></p>

<p>这样，每当我们有新的提交之后，<code>Snap CI</code>都会拿到新代码，并执行上述命令，如果执行成功，则本地构建成功。</p>

<h3>集成测试</h3>

<p>由于采取的是<strong>前后端分离</strong>的策略，我们的应用可以完全独立与后端进行开发，因此我们设置了一个<code>fake server</code>，具体细节可以参考<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">我之前的博客</a>，也可以看源码。不过这里我们要为集成测试编写一个脚本，并在<code>Snap CI</code>上执行。</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>export PORT=8100
bundle install</p>

<h1>launch the application</h1>

<p>echo "launch the application"
ruby app.rb 2>&amp;1 &amp;
PID=$!</p>

<h1>wait for it to start up</h1>

<p>sleep 3</p>

<h1>run the rspec tests and record the status</h1>

<p>rspec
RES=$?</p>

<h1>terminate after rspec</h1>

<p>echo "terminate the application"
kill -9 $PID</p>

<h1>now we know whether the rspec success or not</h1>

<p>exit $RES
```</p>

<p>这个脚本中，首先安装所有的<code>gems</code>，然后启动<code>fake server</code>并将这个server放置在后台运行，然后执行<code>rspec</code>。当<code>rspec</code>测试执行完成之后，我们终止服务进行，然后返回结果状态码。</p>

<p>这里使用了<code>capybara</code>和<code>poltergeist</code>来做UI测试，<code>capybara</code>会驱动<code>phantomjs</code>来在内存中运行浏览器，并执行定义好的<code>UI</code>测试，比如此处，我们的UI测试：</p>

<p>```rb
require 'spec_helper'</p>

<p>describe 'Feeds List Page' do</p>

<pre><code>let(:list_page) {FeedListPage.new}

before do
    list_page.load
end

it 'user can see a banner and some feeds' do
    expect(list_page).to have_banner
    expect(list_page).to have_feeds
end

##...
</code></pre>

<p>end
```</p>

<p><img src="/images/2016/01/snap-ci-it-resized.png" alt="Snap CI logs" /></p>

<h3>部署</h3>

<p>首先需要在<code>S3</code>上创建一个<code>bucket</code>，命名为<code>bookmarks-frontend</code>。然后为其设置<code>static website hosting</code>，这时候<code>AWS</code>会assign一个新的域名给你，比如<code>http://bookmarks-frontend.s3-website-us-west-2.amazonaws.com/</code>。</p>

<p>然后你需要将这个<code>bucket</code>设置成<code>public</code>，这样其他人才可以访问你的<code>bucket</code>。</p>

<p><img src="/images/2016/01/aws-s3-public-resized.png" alt="AWS S3" /></p>

<p>有了这个之后，我们来编写一个小脚本，这个脚本可以将本地的文件上传至S3。</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<h1>install gulp and its dependencies</h1>

<p>npm install</p>

<h1>package stuff, and point the server to the right place</h1>

<p>gulp release</p>

<h1>upload the whold folder</h1>

<p>aws s3 cp public/ s3://bookmarks-frontend \</p>

<pre><code>--recursive \
--region us-west-2 \
--acl public-read
</code></pre>

<p>```</p>

<p><code>aws</code>命令是<code>aws command line</code>提供的，另外我们需要在环境变量中设置AWS提供给你的token：</p>

<p><code>sh
AWS_ACCESS_KEY_ID=xxxxxxxxxx
AWS_SECRET_ACCESS_KEY=xxxxxxxxxx
</code></p>

<p>然后我们就可以将本地的<code>public</code>目录递归的上传到S3的对应目录了！</p>

<p><img src="/images/2016/01/snap-ci-pipeline-resized.png" alt="snap ci pipeline" /></p>

<p>完整的代码可以在<a href="https://github.com/abruzzi/bookmarks-frontend">此处下载</a>。</p>

<h2>总结</h2>

<p>我们前端的持续交付也介绍完了。现在前后端应用完全独立，发布也互不影响。不论是服务器端新增加了API，还是添加了新数据，客户端的发布都不受影响；同样，修改样式，添加新的<code>JavaScript</code>也完全不会影响后端。更重要的是，所有的发布都是一键式的，开发者只需要一个<code>git push</code>就可以享受这些免费服务提供的自动构建，自动化测试以及自动部署的功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[穷人的持续集成与持续交付（上）]]></title>
    <link href="http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1/"/>
    <updated>2016-01-09T23:34:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1</id>
    <content type="html"><![CDATA[<h1>服务器端应用的持续交付</h1>

<p>本文将使用一些免费的服务来为你的项目搭建<code>持续交付</code>平台，这些服务包括</p>

<ul>
<li>持续集成环境</li>
<li>持续部署环境</li>
<li>服务端应用托管</li>
</ul>


<p>以及一些可以用于本地开发使用的开源工具如：</p>

<ul>
<li><a href="https://github.com/abruzzi/node-build-monitor">基于Node的构建monitor</a></li>
<li><a href="https://toolbelt.heroku.com/">Heroku的命令行工具</a></li>
<li><a href="https://github.com/travis-ci/travis.rb">Travis CI的命令行工具</a></li>
</ul>


<p>除此之外，我们在过程中编写的脚本还可以用以本地构建，如果你的团队中正好已经有CI工具/CD工具，将这些脚本集成进去也是一件非常容易的事情。</p>

<p><img src="/images/2016/01/heroku-log-resized.png" alt="heroku real time log" /></p>

<h2>背景知识</h2>

<h3>软件的度量</h3>

<p>传统的管理方法论，在软件开发这个领域来说基本上是不工作的。软件项目的不确定性使得人们畏惧，管理者希望通过一些数字，指标来让自己感到某种虚幻的“掌控感”。软件行数，测试覆盖率，代码故障率等数字的名声基本上已经很糟了，经常有人拿来讽刺那些追求虚幻掌控感的“领导”。</p>

<p>但是有一个数字，即使最顽固的“自由主义者”也会认为是有意义的，那就是周期时间（cycle time）。简而言之，就是一个需求从产生到最终上线所需要的时间。其中包括了需求分析，设计，编码，测试，部署，运维等活动，可能还会包含后续的监控。</p>

<p>其实不论是瀑布模型，还是迭代开发的方式，或者其他的方法论，周期时间的缩短都是至关重要的。而具体到周期内，单纯的开发时间变长或者测试时间变长都无关紧要。比如项目A的开发时间是测试时间的2倍，项目B则恰恰反过来，这并不能说A做的比B好，真正有意义的是A的周期时间是否比B更短。</p>

<p>单纯改善项目过程中的某一个阶段的时间，可能并不能达到预期的目的。局部优化并不一定会带来全局的优化。换言之，<strong>通过某些策略来提高软件测试的效率未必能减少周期时间！</strong>。</p>

<h3>持续交付</h3>

<p>传统情况下，企业要进行软件开发，从用户研究到产品上线，其中会花费数月，甚至数年（我的一位印度同事给我聊起过，他的上家公司做产品，从版本启动到版本上线需要整整两年时间！）。而且一旦软件需求发生变更，又有需要数月才能将变更发布上线。除了为变更提交代码外，还有很多额外的回归测试，发布计划，运维部门的进度等等。而市场机会千变万化，在特定的时间窗口中，企业的竞争者可能早已发布并占领了相当大的市场份额。</p>

<p>在软件工程领域，人们提出了持续交付（continuous delivery）的概念，它旨在减少周期时间，强调在任何时刻软件都处于可发布状态。采用这种实践，我们可以频繁，快速，安全的将需求的变化发布出来，交由真实世界的用户来使用，在为用户带来价值的同时，我们也可以快速，持续的得到反馈，并激励新的变化产生（新的商业创新，新的模式等）。</p>

<p>持续交付包含了自动化构建，自动化测试以及自动化部署等过程，持续改进开发流程中的问题，并促进开发人员，测试人员，运维人员之间的协作，团队可以在分钟级别将变更发布上线。</p>

<h3>持续交付相关技术及实践</h3>

<ul>
<li>版本控制（配置管理）</li>
<li>持续集成CI</li>
<li>自动化测试</li>
<li>构建工具及构建脚本</li>
<li>部署流水线</li>
</ul>


<p>团队通过版本控制来进行协作，所有的代码会在持续集成环境中编译，代码静态检查/分析，自动化测试（还可能产生报告等）。除此之外，CI还还需要有自动化验收测试，自动化回归测试等。</p>

<p>持续交付则更进一步，它将环境准备，持续集成，自动化部署等放在了一起。通过全自动（有些过程可以设置为手动，比如发布到产品环境）的方式，使得软件可以一键发布。如果上线后发现严重defect，还支持一键回滚的机制（其实就是将之前的一个稳定版本做一次发布，由于发布流程已经经过千锤百炼，所以发布本身就变得非常轻松，安全）</p>

<p>这篇文章中，我们会使用<code>git</code>+<code>github</code>作为版本控制工具，<code>travis-ci</code>作为持续集成环境，<code>gradle</code>作为构建工具，<code>Heroku</code>作为应用的部署环境。这些工具都是免费服务，如果你需要更高级的功能（比如更多的并发数，更大的数据库），则可以选择付费套餐。不过对于我们平时的大部分side project来说，免费服务已经足够。</p>

<h2>实例</h2>

<p>我在<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">《前后端分离了，然后呢？》</a>这篇文章中，提到了一个叫做<code>bookmarks</code>的应用，这个应用是一个前后端分离的非常彻底的应用。</p>

<p>我们这里会再次使用这个应用作为实例，并采用不同的两个免费服务（<a href="https://travis-ci.org">travis-ci</a>和<a href="https://snap-ci.com">snap-ci</a>）来完成<code>持续部署</code>环境的搭建。</p>

<h3>bookmarks服务器</h3>

<p><code>bookmarks-server</code>是一个基于<code>spring-boot</code>的纯粹的<code>API</code>，它可以被打包成一个<code>jar</code>包，然后通过命令行启动运行。在本文中，我们我们将会将这个server部署到<a href="https://dashboard.heroku.com/">heroku</a>平台上。</p>

<p>首先需要定义一个<code>Procfile</code>，这个是我们应用的入口，<code>heroku</code>根据这个文件来明确以何种方式来启动我们的应用：</p>

<p><code>
web: java -Dserver.port=$PORT -jar build/libs/bookmarks-server-0.1.0.jar --spring.profiles.active=staging
</code></p>

<p>由于我们在本地使用的使用<code>mysql</code>，而<code>heroku</code>默认的是<code>postgres</code>数据库，因此需要在<code>application.yml</code>中额外配置</p>

<p>```yml
spring:
  profiles: staging</p>

<p>  datasource:</p>

<pre><code>driverClassName: org.postgresql.Driver
url: ${JDBC_DATABASE_URL}
username: ${DATABASE_USER}
password: ${DATABASE_PASS}
</code></pre>

<p>  jpa:</p>

<pre><code>database_platform: org.hibernate.dialect.PostgreSQLDialect
hibernate:
  ddl-auto: update
</code></pre>

<p>```</p>

<p>有了这些配置后，我们需要创建一个<code>heroku</code>应用：</p>

<p><code>sh
$ heroku create
Created http://quiet-atoll-8237.herokuapp.com/ | git@heroku.com:quiet-atoll-8237.git
</code></p>

<p>创建之后，我们可以在界面上对这个应用进行一些配置（当然，也可以通过命令行，具体参看<code>heroku help</code>）。为了支持数据库，需要为我们的应用添加一个<code>postgres</code>的AddOn。添加之后，<code>heroku</code>会为我们提供一个<code>postgres</code>的连接地址，格式大概是这样：</p>

<p><code>
postgres://username:password@host:port/database
</code></p>

<p>然后我们需要在<code>Heroku</code>的配置界面中配置一些环境变量：</p>

<p><img src="/images/2016/01/heroku-config-resized.png" alt="heroku env config" /></p>

<p>这样，当应用部署到<code>Heroku</code>上之后，我们的应用就可以读到这些配置了（注意<code>application.yml</code>中的环境变量<code>JDBC_DATABASE_URL</code>）。</p>

<h4>搭建持续集成环境</h4>

<p>持续集成环境，这里我们选用最简单的<code>travis-ci</code>，它可以很容易的与<code>github</code>集成。</p>

<ul>
<li>在项目X中定义一个<code>.travis.yml</code>的文件</li>
<li>将你的代码push到github上</li>
<li>绑定github帐号到<code>travis</code></li>
<li>在<code>travis</code>中启用项目X</li>
</ul>


<p>这个<code>.travis.yml</code>因项目而异，我们这里的项目是<code>spring-boot</code>，所以只需要指定<code>java</code>即可：</p>

<p><code>yml
language: java
</code></p>

<p>如果是<code>java</code>项目，并且项目中有<code>build.gradle</code>，<code>travis-ci</code>会自动执行<code>gradle check</code>任务。</p>

<h4>自动化部署</h4>

<p>当CI运行成功之后，我们需要<code>travis-ci</code>帮我们将应用程序发布到<code>heroku</code>上，这时候需要做一些修改。最简单的方式是直接安装<code>travis-ci</code>的命令行工具到本地：</p>

<p><code>sh
$ gem install travis -v 1.8.0 --no-rdoc --no-ri
</code></p>

<p>然后通过<code>heroku</code>的<code>auth:token</code>命令获得<code>heroku</code>的token，在加密并写入<code>.travis.yml</code>：</p>

<p>```sh
$ heroku auth:token
00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067</p>

<p>$ travis encrypt 00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067 --add
```</p>

<p>当然可以合并为一条命令：</p>

<p><code>sh
$ travis encrypt $(heroku auth:token) --add
</code></p>

<p>将加密过的token存入<code>.travis.yml</code>文件。最后的结果大致如下：</p>

<p>```yml
language: java
deploy:
  provider: heroku
  api_key:</p>

<pre><code>secure: ...
</code></pre>

<p>  app: quiet-atoll-8237
```</p>

<p>注意此处的<code>app</code>，正是我们的App的名字。另外，还需要给<code>build.gradle</code>添加一个名叫<code>stage</code>的task，<code>travis</code>在deploy时需要这个<code>task</code>：</p>

<p>```groovy
task stage {</p>

<pre><code>dependsOn build
</code></pre>

<p>}
```</p>

<p><img src="/images/2016/01/travis-deploy-resized.png" alt="travis deploy" /></p>

<p>这样，我们只需要在本地的一个提交，一切都会自动化起来：</p>

<ul>
<li>travis会执行<code>gradle check</code></li>
<li><code>gradle check</code>会编译并运行自动化测试</li>
<li><code>travis</code>会部署应用到<code>heroku</code>上</li>
<li><code>heroku</code>会自动重启服务</li>
</ul>


<p>我们可以在本地进行简单的测试（注意此处我们的<code>staging</code>环境的URL）：</p>

<p>```sh
$ curl https://quiet-atoll-8237.herokuapp.com/api/feeds -s | jq .
[
  {</p>

<pre><code>"id": 1,
"url": "http://icodeit.org/2016/01/how-to-summarize-privious-project/",
"title": "如何持久化你的项目经历",
"author": "icodit.org",
"summary": "通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。",
"publishDate": "2016-01-07"
</code></pre>

<p>  },
  {</p>

<pre><code>"id": 2,
"url": "http://icodeit.org/2015/11/get-started-with-reflux/",
"title": "你为什么应该试一试Reflux？",
"author": "icodit.org",
"summary": "React在设计之初就只关注在View本身上，其余部分如数据的获取，事件处理等，全然不在考虑之内。",
"publishDate": "2016-01-09"
</code></pre>

<p>  }
]
```</p>

<p>完整的<a href="https://github.com/abruzzi/bookmarks-server">代码在这里</a>。</p>

<h2>其他</h2>

<h3>CI monitor</h3>

<p><a href="https://github.com/abruzzi/node-build-monitor">node-build-monitor</a>是一个非常容易配置，使用的CI monitor，我们只需要进行简单地配置，就可以将<code>travis</code>的状态可视化出来</p>

<p>```json
{
  "monitor": {</p>

<pre><code>"interval": 2000,
"numberOfBuilds": 12,
"debug": true
</code></pre>

<p>  },
  "services": [</p>

<pre><code>{
  "name": "Travis",
  "configuration": {
    "slug": "abruzzi/bookmarks-server"
  }
}
</code></pre>

<p>  ]
}
```</p>

<p>不过这个工具会在有网络异常时自动终止，我们可以通过一个简单的脚本来在它终止时自动重启：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>until node app/app.js
do</p>

<pre><code>echo "restarting..."
</code></pre>

<p>done
```</p>

<p><img src="/images/2016/01/ci-monitor-resized.png" alt="CI Monitor" /></p>

<h2>小结</h2>

<p>通过<code>travis</code>和<code>heroku</code>这样的免费服务，我们就可以轻松的将自己的项目做到持续集成+持续交付。我们后端的服务相对来说是比较容易的，但是涉及到一个前后端分离的架构，如何做到静态内容的托管，打包，部署，并和后端API集成起来，我会在下一篇文章中详细解释。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何持久化你的项目经历]]></title>
    <link href="http://abruzzi.github.com/2016/01/how-to-summarize-privious-project/"/>
    <updated>2016-01-05T12:44:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/how-to-summarize-privious-project</id>
    <content type="html"><![CDATA[<h1>下项目之后</h1>

<p>通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。这里面既有终于摆脱了厌烦了的<code>技术栈</code>的解脱感，也有对新项目/新技术的向往，可能还有些在旧项目中做的不太满意的事情，可以在新项目重头再来的期望。</p>

<p>可能有点老生常谈了，不过这里我想说说下项目后如何做总结的事儿。对上一个项目的总结，其重要程度可能要远远超过你的想象。我是在2014年初，在一个客户现场的一个会议室和一位同事谈我的Annual Review的时候，才意识到这个问题的。</p>

<p>Annual Review会回顾我们过去一年的项目经历，有哪些方面的进步，同时也会展望未来的计划。但是这其中有几个问题：第一个问题是以年为单位的Review粒度太粗，有些经历已经淡忘，也有人可能一年会换好几个项目；第二个问题是对于大多数人来说，展望未来是一件比较容易的事儿，每个人或多或少都会有一些计划（比如学会前端的某些技术，尝试一些DevOps方面的工作，或者了解一下大数据等等）；但是对于回顾过去，我们其实并不擅长；最后一个问题是即使做了回顾，回顾的层次非常浅，作用并不大。</p>

<p>说到回顾过去，更多时候我们关注的是从项目中学到了什么样的新技术，这种浅层次的回忆和记流水帐是容易的，但是对于我们的成长并不会有太大的收益。真正会为帮助我们在将来的项目中做决策，甚至会影响我们学习效率，解决问题能力的是：<code>深度回顾</code>。</p>

<h2>深度回顾练习</h2>

<p>深度回顾可以帮助我们梳理知识，将实际的案例归纳总结为实际可用的知识。要获得这种能力，需要做一些针对性的练习。根据我自己的经验，这些练习大约可以归为3类，难度依次增加。</p>

<h3>项目上的直接经验</h3>

<p>这个练习比较简单，就是问问自己：“<strong>我在项目里学到了什么？</strong>”</p>

<p>要回答这个问题是很容易的，项目中用到的技术如模板引擎，前端框架，自动化测试套件，build工具等等，总结这些内容的过程，对于我们的PS来说都是“自动”发生的，几乎不需要付出额外的efforts。这些回顾、总结可以帮助我们成为一个“熟手”，即当下一次遇到相同或者类似的场景时，我们可以很容易直接应用这些经验。</p>

<p>更进一步，再问问自己在项目中的其他收获。比如客户关系处理的经历，团队建设的经验，甚至是写英文邮件的技巧等等方面，看看做的有没有问题，有没有提升的可能？</p>

<p>人类最牛逼的技能是：可以审视自己的行为。也就是站在旁观者的角度来看待自己的行为，随波逐流式的在各种琐事中沉浮事实上无法得到提升的。可以经常性的将自己置身事外，以一个旁观者的角度来审视自己做过的事情。并从中找出做得好的地方和不足的地方，然后自己给过去的自己一些建议，并记录下来。这些刻意的练习会帮助你养成回顾，从经验中学习的习惯，而这个习惯正是一个人区别于另一个人的绝对“捷径”。</p>

<h3>练习讲故事</h3>

<p>这个练习是，假想你遇到了一个同一个办公室的同事，他对你刚做完的这个项目很感兴趣，你来给他描述一下这个项目。描述的内容包括但不限于这些方面：</p>

<ul>
<li>项目的背景介绍</li>
<li>该项目以何种方式，为那些用户，带来了什么样的价值？（business model是什么）</li>
<li>该项目的实际用户数量是什么级别？</li>
<li>项目的部署，运维是如何操作的？</li>
<li>项目的监控是怎样做的？</li>
<li>当遇到系统故障，项目组是如何反应的？</li>
</ul>


<p>能把一件事情描述清楚是一件非常了不起的能力。我见过很多的程序员，写起代码来好不含糊，但是却很难将一件简单的事情讲清楚。我们当然要提防那些夸夸其谈，华而不实的“嘴子”，但是也至少得要求自己做到清晰，准确的将自己经历过的事情描述清楚。</p>

<p>描述项目背景需要至少需要交代这样一些内容：客户是谁，最终的消费者是谁，项目以何种方式运作（离岸交付，本地，onsite，咨询，培训等），我们<strong>帮助客户为消费者带来了什么样的价值</strong>。客户的商业模式是什么，在我们周围有哪些类似的项目。</p>

<p><img src="/images/2016/01/bmcanvas-basic-model-resized.jpg" alt="business canvas" /></p>

<p>即使在技术方面，也有很多被Dev忽略掉的信息，比如项目在产品环境中如何部署，数据中心建在何处，客户如何运维、监控等。实际的发布周期如何，发布流程如何，客户的内部论坛上都会有很多的这样的信息，但是很少有人关注。从一个项目roll off的时候，这些信息即使做不到了若指掌，至少也能描述清楚，否则难免有些“入宝山而空回”的遗憾。</p>

<h3>回顾项目中的挑战</h3>

<p>从简单的CRUD系统，到复杂的分布式计算，从企业内部的管理系统，到支持高并发、要求实时处理的交易平台，每个项目都会遇到一些挑战。除了技术上的挑战之外，还有陈旧而无文档的代码库，复杂的业务场景，不配和的客户接口人等等。挑战无处不在，那么作为项目中的一员，你是如何应对这些挑战的呢？最后又是如何解决的？</p>

<p>现实世界是一个充满了trade off的世界，我们需要做种种权衡，代码测试覆盖率和交付压力，性能和客户能负担的机器实例数量，框架A和框架B的优劣等等。我们在采取这个方案的时候，只能舍弃其他方案，由于谁也无法在事先准确预料采取某个方案一定是对的，那么在一个失败的方案背后，其实也是一个很好的教训，至少可以为未来的决策提供帮助。</p>

<ul>
<li>遇到的最大的挑战是什么？</li>
<li>这个挑战是如何被解决的？</li>
<li>如果有机会重做，你会如何考虑？</li>
</ul>


<h3>其他练习</h3>

<p>这里列出了一些我常用的，辅助性的练习。它们可以帮助你更好的梳理项目上学到的技能、知识，并且转换成你自己的知识。这些练习未必一定要等到项目结束之后才做，事实上它们都可以应用在日常的工作中。</p>

<ul>
<li>记笔记</li>
<li>写博客</li>
<li>在办公室内演讲</li>
<li>去社区贡献话题</li>
</ul>


<p>很多人都会记笔记，但只有一小部分的人在记录之后会持续翻阅。很多人会使用Evernote/印象笔记之类的工具将一些临时的想法，问题的思路，知识点的细节等记录下来，但是仅仅记录是不够的，笔记需要不断的检索、整理、提炼、修正、总结和归纳。在不断的加工之后，这些笔记可能会得到沉淀，并升华形成一些更有意义的内容（比如个人博客，或者可以发表到InfoQ/IBM DeveloperWorks平台上的文章等）。</p>

<p>除了记录笔记之外，写博客也是一种很好的总结形式。通过将素材不断充实、整理、完善，最终形成一个可供别人直接消费的文章，不但可以锻炼到总结能力，还可以很好的提升表达能力，而且可以帮助你将已有的知识体系化。如果你的博客写成了系列，也很容易通过Gitbook等将其发布为一本电子书，从而影响更多人（说不定还可以赚点咖啡钱）。</p>

<p>写博客/电子书，终究是书面形式的。事实上一个人可以很容易的通过文字将自己的实际情况隐藏起来。举个极端的例子：如果有足够的动机（比如公司的KPI要求），即使不熟悉某种语言/工具，仅仅通过Google，一个人也可以通过这种“作弊”的方式写出一篇“专家级”的文章。但是对于演讲这种面对面的形式，则基本上无法作弊，从而也更具有挑战性。另一方面，对于一个新的知识、技能，自己掌握是一回事儿，要讲出来让别人也能听懂，并从中收益，则完全是另外一回事儿。作为咨询师，语言表达（包括书面和演讲）能力的重要性勿庸赘言。整理知识，并归纳为演讲，会帮助你将体系化后的知识更好的表达出来。</p>

<p>在办公室里讲session有一定的挑战，但受众毕竟是“自己人”，压力相对会小一些（比如在ThoughtWorks，我们非常鼓励员工为其他人讲session，具体可以参看<a href="http://icodeit.org/2015/01/how-we-do-training-in-thoughtworks/">我的这篇文章</a>）。要在社区中演讲则要面临更大的挑战，通过将话题不断锤炼，不断归纳，最终形成可以在社区分享的话题，则不但可以提高内容的质量，也可以更好的锻炼表达能力和临场应变能力。</p>

<p><img src="/images/2016/01/xian-resized.jpg" alt="xian community" /></p>

<p>不过归根结底，这些活动的重要输入还是对之前项目中的知识、经历的深度回顾。</p>

<h2>总结</h2>

<p>从项目上下来之后，需要深入思考并总结之前的经验，这种深入思考会帮助你建立比较完整的知识体系，也可以让你在下一项目中更加得心应手，举一反三。如果只是蜻蜓点水般的“经历”了若干个项目，而不进行深入的总结和思考，相当于把相同的项目用不同的技术栈做了很多遍一样，那和我们平时所痛恨的重复代码又有什么不同呢？</p>
]]></content>
  </entry>
  
</feed>
