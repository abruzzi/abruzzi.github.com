<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2017-02-14T09:42:10+08:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[测试自动化后，我们还需要QA吗？]]></title>
    <link href="http://abruzzi.github.com/2016/09/what-should-qa-do-in-a-agile-team/"/>
    <updated>2016-09-24T23:43:00+08:00</updated>
    <id>http://abruzzi.github.com/2016/09/what-should-qa-do-in-a-agile-team</id>
    <content type="html"><![CDATA[<h2>QA的职责</h2>

<p>我们先讨论一下传统的瀑布模型下QA是如何工作的，其中最主要的问题是什么；然后作为对比，我们来看看在敏捷团队里QA又是如何工作的，工作重点又是什么；最后，我们详细看一看在新的职责下，QA应该如何做。</p>

<h3>瀑布开发模型</h3>

<p>即使在今天，在很多企业中，瀑布模型仍然是主流。每一个需求都需要经过分析，设计，开发，测试，上线部署，运维等阶段。虽然一些企业已经在实施<code>敏捷开发</code>，比如项目/产品以迭代的方式运作，也有诸如每日站会，代码检视等敏捷实践，但是如果仔细审视，你会发现其实<em>开发模式</em>骨子里还是瀑布：按照软件组件划分的部门结构（详见<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律</a>），按照职能划分的团队（开发和测试分属不同部门），过长的反馈周期，永远无法摆脱的集成难题等等。</p>

<p>随着软件变得越来越复杂，团队里没有任何一个人可以说出系统是如何运作的，也不知道最终用户是谁，以及最终用户会以何种方式来使用最终的软件。</p>

<p>更糟糕的是，按照职能划分的团队在物理上都是隔离的，比如独立的测试部门，独立的运维部门，整日忙碌而难以预约到档期的业务人员，当然还有经常疲于交付，无处吐槽的<em>苦逼</em>开发。由于这些隔离，信息的反馈周期会非常长，一个本来很容易修复的缺陷可能在4周之后才可能被另一个部门的测试发现，然后通过复杂的工作流（比如某种形式的缺陷追踪系统）流到开发那里，而开发可能还在拼命的完成早就应该交付的功能，从而形成恶性循环。</p>

<h3>瀑布模式中的QA</h3>

<p>在这样的环境中，QA们能做的事情非常有限。在需求开始时会他们参加需求澄清的会议，制定一些<code>测试计划</code>，然后进行测试用例的设计。有的企业会用诸如Excel之类的工具来记录这些用例。这些写在Excel里的，<code>死</code>的用例用处非常有限。而最大的问题在于：它们无法<code>自动化执行</code>。另外，在实际软件开发中，需求总是会经常发生变化，需求的优先级也会有调整，然后这些记录在Excel中的<code>死</code>的用例会很快过期，变得无人问津。</p>

<p>除此之外，QA中的有些成员会使用工具来录制一些UI测试的场景，然后在每个新版本出来之后进行回放即可。然而，当UI发生一点变化之后，这些自动化的用例就会失效：比如<code>HTML</code>片段中元素位置的调整，<code>JavaScript</code>的异步调用超时等等。</p>

<p>显然，这种单纯以黑盒的形式来<strong>检查功能点</strong>的测试方式是不工作的，要真正有效的提升软件质量，仅仅通过<strong>事后检查</strong>是远远不够的，软件的质量也应该内建于软件之中。QA的工作也应该是一个贯穿软件生命周期的活动，从商业想法，到真实上线，这其中的所有环节，都应该有QA的参与。</p>

<h3>系统思考</h3>

<p>如果不从一个系统的角度来思考软件质量，就无法真正构建出健壮的、让业务和团队都有信心的软件系统。<strong><em>质量从来都不只是QA的职责，而是整个团队的职责。</em></strong></p>

<p>关于软件质量，一个根深蒂固的误解是：缺陷在开发过程中被引入，然后在测试阶段被发现，最后在QA和开发的来来回回的撕扯中被解决（或者数量被大规模降低），最后在生产环境中，就只会有很少的，优先级很低的缺陷。</p>

<p>然而事实上，很多需求就没有仔细分析，业务价值不很确定，验收条件模糊，流入开发后又会引入一些代码级别的错误，以及业务规则上的缺陷，测试阶段会漏掉一些功能点，上线之后更是问题百出（网络故障，缓存失效，黑客攻击，操作系统补丁，甚至内存溢出，log文件将磁盘写满等等）。</p>

<p>在一个敏捷团队中，<strong>每个个人都应该对质量负责</strong>，而QA则以自己的丰富经验和独特视角来发掘系统中可能的质量隐患，并帮助团队将这些隐患消除。</p>

<p><img src="/images/2016/09/circle-resized.png" alt="测试职责" /></p>

<p>我在ThoughtWorks的同事<code>Anand Bagmar</code>在他的演讲<a href="http://www.slideshare.net/abagmar/what-is-agile-testing-how-does-automation-help">What is Agile testing- How does automation help?</a>中详细讨论过这部分内容。</p>

<h3>QA到底应该干什么？</h3>

<p>本质上来说，任何软件项目的目标都应该是：<strong>更快地将<code>高质量</code>的软件从想法变成产品</strong>。</p>

<p>将这个大目标细分一下，会得到这样几个子项，即企业需要：</p>

<ul>
<li>更多的商业回报（发掘业务价值）</li>
<li>更快的上线时间（做最简单，直接的版本）</li>
<li>更好的软件质量（质量内嵌）</li>
<li>更少的资源投入（减少浪费）</li>
</ul>


<p>其实就是传说中的<strong>多、快、好、省</strong>。如果说这是每一个软件项目的目标的话，那么团队里的每一个个人都应该向着这个目标而努力，任何其他形式的工作都可以归类为<code>浪费</code>。用Excel记录那些经常会失效，而且无法自动执行的测试用例是浪费，会因为页面布局变化而大面积失效的UI测试也是浪费，一个容易修复的缺陷要等到数周之后才被发现也是浪费。</p>

<p>在这个大前提下，我们再来思考QA在团队里应该做什么以及怎么做。</p>

<h3>QA的职责</h3>

<p>Lisa Crispin在<a href="https://book.douban.com/subject/5338399/">《敏捷软件测试》</a>中提到过一个很著名的模型：敏捷测试四象限。这个模型是QA制定测试策略时的一个重要参考：</p>

<p><img src="/images/2016/09/agile-testing-quadrants.png" alt="敏捷软件测试" /></p>

<p>如果按照纵向划分的话，图中的活动，越向上越面向业务；越向下越面向技术。横向划分的话，往左是支撑团队；往右是评价产品。</p>

<p>其实简化一下，QA在团队里的工作，可以分为两大类：</p>

<ul>
<li>确保我们在<code>正确的</code>交付产品</li>
<li>确保我们交付了<code>正确的</code>产品</li>
</ul>


<p>根据这个四象限的划分，大部分团队可能都会从Q2起步：QA会和BA，甚至UX一起，从需求分析入手，进行需求分析，业务场景梳理，这时候没有具体的可以被测试的软件代码。不过这并不妨碍<strong>测试</strong>活动，比如一些纸上原型的设计（感谢刘海生供图）：</p>

<p><img src="/images/2016/09/prototype-resized.png" alt="" /></p>

<p>通过这一阶段之后，我们已经有了用户故事，这时候QA需要和开发一起编写用户故事的自动化验收测试。当开发交付一部分功能之后，QA就可以做常规的用户故事测试，几个迭代之后，QA开始进行跨功能需求测试和探索性测试等。根据探索性测试的结果，QA可能会调整测试策略，调整测试优先级，完善测试用例等等。</p>

<p>根据项目的不同，团队可以从不同的象限开始测试策略的制定。事实上，Q1-Q4仅仅是一个编号，与时间、阶段并无关系，Lisa Crispin还专门<a href="http://lisacrispin.com/2011/11/08/using-the-agile-testing-quadrants/">撰文解释</a>过。</p>

<p>关于QA如何在软件分析的上游就介入，然后通过BDD的方式与业务分析师一起产出软件的各种规格描述，并通过实例的方式来帮助整个团队对需求的理解，ThoughtWorks的林冰玉有一篇文章很好的介绍了<a href="http://insights.thoughtworkers.org/when-we-talk-about-bdd/">BDD的正确做法</a>。如果将QA的外延扩展到在线的生产环境，制定合理的测量指标，调整测试策略，强烈推荐林冰玉写的另一篇文章<a href="http://www.jianshu.com/p/20b454a88bdb">产品环境中的QA</a>。</p>

<h4>其他职责</h4>

<p>事实上，软件生命周期中有很多的活动，有很多处于<code>灰色</code>地段。既可以说是应该开发做，又可以说应该QA做，甚至可以推给其他角色（比如OPs）。不过我们知道，一旦涉及角色，人们就再也不会按照<code>全局优化</code>的思路来应对问题了。这种<code>灰色</code>的活动包括：</p>

<ul>
<li>持续集成的搭建</li>
<li>测试环境的创建于维护</li>
<li>UAT上的数据准备</li>
<li>代码中的测试代码的维护</li>
<li>测试代码的重构</li>
</ul>


<p>在团队实践中，这些活动我们通常会让QA和开发或者OPs同事一起结对来完成。一方面避免知识孤岛的形成，另一方面在跨角色的工作中，也可以激发出更多不同的思路。</p>

<h3>万能的QA？</h3>

<p>虽然在这些活动中，QA都会参与，但是并不是说团队里只要有一个QA就可以了。QA在参与这些活动时，侧重点还是有很大不同的。</p>

<p>比如需求分析阶段，如果有QA的加入，一些从QA角度可以发现的有明显缺陷的场景，则可以在分析阶段就得到很好的处理。另一方面，尽早介入可以设计出更合理的测试计划（比如哪些功能的优先级比较高，用户更会频繁使用，那么对应的测试比重也会更高）。在Story分析与书写阶段，QA可以帮助写出更加合理的验收条件，既满足业务需求，又可以很好的指导开发。</p>

<p>在和开发一起编写澄清需求时，主要是编写自动化验收测试，而不是实际编写业务逻辑的实现（虽然QA应该参与<code>Code Reivew</code>环节，学习并分享自己的观点）；甚至在上线运维阶段，QA还需要和OPs一起来设计用户数据的采集指标（比如用户访问的关键路径，浏览器版本，地区的区分等），从而制定出新的测试策略。</p>

<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.slideshare.net/abagmar/what-is-agile-testing-how-does-automation-help">What is Agile testing - How does automation help?</a></li>
<li><a href="http://insights.thoughtworkers.org/agile-showcase-se7en/">敏捷实践Showcase的七宗罪</a></li>
<li><a href="http://www.jianshu.com/p/20b454a88bdb">产品环境下的QA</a></li>
<li><a href="https://book.douban.com/subject/5338399/">《敏捷软件测试》</a></li>
</ul>


<p>P.S. 感谢林冰玉对本文的<code>Review</code>和指导。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何设计一次培训]]></title>
    <link href="http://abruzzi.github.com/2016/09/how-to-design-a-training/"/>
    <updated>2016-09-10T13:35:00+08:00</updated>
    <id>http://abruzzi.github.com/2016/09/how-to-design-a-training</id>
    <content type="html"><![CDATA[<h2>培训元模式</h2>

<p>最近在帮客户设计一个<code>微服务进阶版培训</code>的材料，整理的过程中我意识到这类事情我已经做过好多次了。比如在ThoughtWorks的<code>P2能力建设</code>项目，<a href="http://icodeit.org/3p3w/">3周3页面</a>工作坊等等，我觉得应该将<code>设计课程/设计培训</code>中的模式、原则和实践都提取一下，形成一个元模式（即关于培训的培训）。</p>

<p>一个培训中的活动，按照时间顺序可以分为三个步骤：</p>

<ol>
<li>设计培训内容</li>
<li>培训前期准备</li>
<li>培训中的一些实践</li>
</ol>


<h3>设计培训内容</h3>

<p>根据经验，只有那些正好处于瓶颈阶段，需要别人给予一些具体指导的人，培训是最有效的。比如我最近在学习iOS开发，那么<code>用Swift开发一个Todo List应用</code>就特别合适，而另一个<code>基于Objective-C的自动化测试</code>则对我来说一点用也没有（即使这个可能更高级，讲师更牛）。</p>

<p>在任何一个培训可能的设计之前，首先需要回答几个问题：</p>

<ol>
<li>培训目的是什么？</li>
<li>参与者对主题的了解程度如何？</li>
<li>参与者的组成比例（比如junior占比，senior占比等）</li>
<li>结果如何检验？</li>
</ol>


<h4>一个例子</h4>

<p>例子是人类的好朋友，这里我们来看一个例子：</p>

<blockquote><p>客户要为负责开发的同事做一次培训，培训的目的是要帮助他们建立<code>微服务架构</code>下的常见实践的知识框架。从结果的长期效果来看，这次培训要能指导实际的开发工作。参与者对<code>微服务</code>的一些概念有初步了解，也做过小的练习，但是诸如如何划分服务边界，如何拆分微服务等，都不了解，也比较迫切的想要了解。</p></blockquote>

<p>根据这个上下文，客户希望在培训中可以传递这样一些内容：</p>

<ul>
<li>如何拆分微服务</li>
<li>常见的微服务设计原则</li>
<li>拆分微服务的时机</li>
<li>如何做微服务的测试</li>
</ul>


<p>为了确保信息传递的准确性，我问了一遍上边都提到的列表，并且得到了答案：</p>

<ul>
<li>听众是开发经验相对丰富的开发（3-5年）</li>
<li>学习拆分为了将大的应用拆分，以方便维护</li>
<li>自动化测试能力和意识都较为薄弱</li>
<li>听众自己的期望是可以有一些切实可以指导实际开发的收获</li>
</ul>


<p>在有了这些输入的情况下，我做出了这样一些调整：</p>

<ul>
<li>不专门讲拆分微服务</li>
<li>主要精力讲<a href="https://github.com/abruzzi/jigsaw-ddd">DDD</a>（Domain Driven Design）</li>
<li>设计迭代式的，逐步变得复杂的场景来练习DDD</li>
<li>讲解和练习<a href="https://github.com/abruzzi/cdc-demo">自动化测试</a>（Consumer Driven Contract）</li>
<li>Session+Workshop+讨论的形式</li>
</ul>


<p>看了这个计划之后，客户开始觉得挺困惑，说这个怎么跟我们梳理的课程诉求不一致？对于这个疑惑，我的建议是这样的：</p>

<ul>
<li>之前的例子不能落地（找不到足够复杂的，又适合在培训中拆分的场景）</li>
<li>微服务的核心不是基础设施，而是设计原则，或者说如何在开发中找出边界</li>
<li>有了DDD的指导，划分本身并非难事儿</li>
<li>自动化测试（集成测试和契约测试）的能力和认识必须建立</li>
</ul>


<p>然后我把整理好的课件，实例分解，课程安排给客户讲了一遍之后，他觉得很满意。客户自己也是懂技术的，在分析了现状之后，后来又专门要求给部门内做一些<code>DDD</code>培训（而不是微服务本身）。</p>

<h3>培训方式</h3>

<p>同样，方式上也需要一些问题的解答才能有效进行：</p>

<ol>
<li>培训总时长</li>
<li>更偏重练习还是偏重讲解（工作坊还是Session，以及各自的占比）</li>
<li>参与者如何投入（比如是工作时间，还是晚上等）</li>
</ol>


<p>根据经验来看，不论是TWU还是对<code>客户</code>的培训，工作坊和Session结合的方式效果最好。
Workshop至少需要包含这样几部分：</p>

<ul>
<li>明确要做的练习（多长时间，达到什么目的等）</li>
<li>Showcase（参与感，如果有多轮的话，要保证每个人都有Show的机会，而不是每次同一个人）</li>
<li>讨论环节（点评，这个时机可以做一些小结，将要传递的信息润物细无声的传递出去）</li>
</ul>


<p><img src="/images/2016/09/workshop-resized.png" alt="workshop" /></p>

<p>应该避免的做法是:</p>

<ul>
<li>一个无法完成的任务</li>
<li>过长的时间</li>
<li>没有讨论，没有点评（特别是在中国文化中，Trainer有指出对错的<code>义务</code>）</li>
</ul>


<p>而<code>Session</code>则简单一些，交互比较少，需要讲师之前做足功课</p>

<ul>
<li>有清晰的Agenda（时长，要传递的大致内容）</li>
<li>如果是讲方法论（DDD，BDD等等），最好结合实践</li>
<li>不要讲代码（没有人能看清你的编辑器，也没有人有耐心看超过1行的代码）</li>
<li>一次不要传递太多信息（只讲三点）</li>
</ul>


<p>两者穿插起来，可以收到很好的效果，既不至于让人觉得没有内容，也不会感觉只说不练。</p>

<h4>预演（Dry Run）</h4>

<p>在进行实际的实施之前，可以从参与者中找出一些典型的人进行交流，<code>dry run</code>一两次。不过交流也需要平衡一些事实：</p>

<ol>
<li>侧重点（做对的事情），比如从设计的层面来讲，DDD，重构等方法的掌握比服务的可用性要重要很多</li>
<li>参与者想要听的和主题的相关性（比如培训目的是Story拆分，那么测试驱动开发的需求就要果断放弃）</li>
</ol>


<p>持续建立关注点，引导发散，归纳问题，归类并给出见解和可能的方案。</p>

<h4>如何回答问题</h4>

<p>有两种教学方式：苏格拉底式和填鸭式。苏格拉底式讲究只问不答，通过讲师不断提问的方式让学员自己思考，琢磨，并期望领悟；填鸭式则恰恰相反，假设学员没有任何能动性，讲师纯粹将自己知道的全部告诉学员。</p>

<p>这其实两者在时间中都不合适。有一个度可以把握的是：</p>

<blockquote><p>善待问者如撞钟，叩之以小者则小鸣，叩之以大者则大鸣，待其从容，然后尽其声。</p></blockquote>

<p>即根据提问的深度来反馈，比如<code>JavaScript</code>培训，学生问如何声明一个数组，讲师讲词法作用域，则费劲而没有效果。经过一段时间的练习和积累之后，学生会问出更深入的问题，这时候再逐步提高答案的深度。</p>

<h3>实践</h3>

<h4>Energize</h4>

<p>如果培训在白天的话，在午饭后，人们自然会感到困倦，这时候需要一些<code>提神</code>的小游戏帮助人们清醒。适度的紧张（比如简单的7Up游戏）或者肢体动作（做几个广播体操的动作）都会帮助人们振奋精神。</p>

<ul>
<li>围成一个圈的丢球自我介绍</li>
<li>A和B向对方互相介绍自己，然后A反过来向整个Group介绍B，B向整个Group介绍A</li>
<li>7Up</li>
<li>丢空气球</li>
</ul>


<h4>工作坊基本准则</h4>

<ol>
<li>按时参加</li>
<li>保持One convensition</li>
<li>手机静音</li>
</ol>


<h4>分组进行</h4>

<p>分组讨论是一个很好的实践，既可以避免<code>只说不练</code>的现象，又可以让参与者有充分的参与感，还可以让培训的时间长度更灵活，更容易控制。</p>

<p>分组可以用报数的方法，通常人们习惯和自己熟悉的人坐在一起。这会促进他们交头接耳的几率，分组时可以通过报数的方式，比如目标是分为3组，就依次报数1、2、3，然后所有报1的人为1组，报2的人为2组，以此类推。</p>

<p>一个我自己常用的伎俩是自由调整时间。比如在一个练习开始前，你告诉参与者他们有10分钟来完成一个Task，然后在5分钟后，你发现大家都基本已经做完了，这时候可以直接说：时间到！（相信我，没有人真正看表的，他们通常会被手头的任务搞得焦头烂额）。反过来，你可以说：再延长5分钟！以督促那些比较慢的小组动作更快一些，而事实上他们还没有用完限定的10分钟。</p>

<p><img src="/images/2016/09/grouping-resized.png" alt="grouping" /></p>

<h4>Parking lot</h4>

<p>培训当然需要参与者和trainer的积极互动，但是有时候参与者提出的问题不太适合在课堂上展开：</p>

<ul>
<li>与培训主题关联并不太大</li>
<li>比较个例的问题</li>
<li>争议较大，难以在短时间内讨论清楚的</li>
</ul>


<p>这些问题可以记录下来，在正式课程时间结束后单点讨论，或者作为下一次备课的关键点，加入到课件中。</p>

<h4>Retro</h4>

<p>和我们倡导的一切活动一样，培训也需要有始有终。我们需要收集参与者的反馈，包括positive的和constructive的，这样经过几轮迭代之后，培训会成熟而具有一定的可复制性。</p>

<p>可以分成三类：<code>做得好的/有待提高的/一些疑问/建议</code></p>

<p>将问题分组讨论之后，分为三组，然后讨论出一些解决方法。</p>

<p><img src="/images/2016/09/retro-resized.png" alt="retro" /></p>

<h4>其他</h4>

<ul>
<li>二维码+金数据表单</li>
<li>白板+白板笔</li>
<li>Flipchart</li>
</ul>


<h3>总结</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无他，但手熟尔]]></title>
    <link href="http://abruzzi.github.com/2016/05/practise-in-programming/"/>
    <updated>2016-05-26T22:56:00+08:00</updated>
    <id>http://abruzzi.github.com/2016/05/practise-in-programming</id>
    <content type="html"><![CDATA[<h2>高效幻象</h2>

<p>通过对自己的行为观察，我发现在很多时候，我以为我掌握了的知识和技能其实并不牢靠。我引以为豪的<code>高效</code>其实犹如一个彩色的肥皂泡，轻轻一碰就会破碎，散落一地。</p>

<h3>你可能只是精通搜索</h3>

<p>我们现在所处的时代，信息爆炸，每个人每天都会接触，阅读很多的信息，快速消费，快速遗忘。那种每天早上起来如同皇帝批阅奏折的、虚假的误以为掌握知识的错觉，驱动我们进入一个恶性循环。</p>

<p>即使在我们真的打算解决问题，进行主动学习时，更多的也只是在熟练使用搜索引擎而已（在一个领域待久了，你所使用的关键字准确度自然要比新人高一些，仅此而已）。精通了高效率搜索之后，你会产生一种你<code>精通搜索到的知识本身</code>的<strong>错觉</strong>。</p>

<p><img src="/images/2016/05/stackoverflow-oreilly.png" alt="stack overflow" /></p>

<h4>如何写一个Shell脚本</h4>

<p>在写博客的时候，我通常会在文章中配图。图片一般会放在一个有固定格式的目录中，比如现在是2016年5月，我本地就会有一个名为<code>$BLOG_HOME/images/2016/05</code>的目录。由于使用的是<code>markdown</code>，在插入图片时我就不得不输入完整的图片路径，如：<code>/images/2016/05/stack-overflow.png</code>。但是我又不太记得路径中的<code>images</code>是单数(<code>image</code>)还是复数(<code>images</code>)，而且图片格式又可能是<code>jpg</code>,<code>jpeg</code>,<code>gif</code>或者<code>png</code>，我也经常会搞错，这会导致图片无法正确显示。另外，放入该目录的原始文件尺寸有可能比较大，我通常需要将其缩放成800像素宽（长度无所谓，因为文章总是要从上往下阅读）。</p>

<p>为了自动化这个步骤，我写了一个小的Shell脚本。当你输入一个文件名如：<code>stack-overflow.png</code>后，它会缩放这个文件到800像素宽，结果是一个新的图片文件，命名为<code>stack-overflow-resized.png</code>，另外它将符合<code>markdown</code>语法的文件路径拷贝到剪贴板里：<code>/images/2016/05/stack-overflow-resized.png</code>，这样我在文章正文中只需要用<code>Command+V</code>粘贴就可以了。</p>

<p>有了思路，写起来就很容易了。缩放图片的命令我是知道的：</p>

<p><code>sh
$ convert -resize 800 stack-overflow.png stack-overflow-resized.png
</code></p>

<p>但是要在文件明上加入<code>-resized</code>，需要分割文件名和文件扩展名，在<code>Bash</code>里如何做到这一点呢？Google一下：</p>

<p>```sh
FULLFILE=$1</p>

<p>FILENAME=$(basename "$FULLFILE")
EXTENSION="${FILENAME##<em>.}"
FILENAME="${FILENAME%.</em>}"</p>

<p>convert -resize 800 $FULLFILE $FILENAME-resized.EXTENSION
```</p>

<p>难看是有点难看，不过还是可以工作的。接下来是按照当前日期生成完整路径，<code>date</code>命令我是知道的，而且我知道它的<code>format</code>格式很复杂，而且跟<code>JavaScript</code>里Date对象的<code>format</code>又不太一样（事实上，世界上有多少种日期工具，基本上就有多少种格式）。再Google一下：</p>

<p><code>sh
$ date +"/images/%Y/%m/"
</code></p>

<p>最后一步将路径拷贝到剪贴板也容易，Mac下的<code>pbcopy</code>我也会用：<code>echo</code>一下字符串变量，再管道到<code>pbcopy</code>即可：</p>

<p><code>sh
PREFIX=`date +"/images/%Y/%m/"`
echo "$PREFIX$FILENAME-resized.EXTENSION" | pbcopy
</code></p>

<p>但是将内容粘贴到<code>markdown</code>里之后，我发现这个脚本多了一个换行。我想这个应该是<code>echo</code>自己的行为吧，会给字符串自动加上一个换行符。Google一下，发现加上<code>-n</code>参数就可以解决这个问题。</p>

<p>好了，完整的脚本写好了：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>FULLFILE=$1</p>

<p>FILENAME=$(basename "$FULLFILE")
EXTENSION="${FILENAME##<em>.}"
FILENAME="${FILENAME%.</em>}"</p>

<p>convert -resize 800 $FULLFILE $FILENAME-resized.EXTENSION</p>

<p>PREFIX=<code>date +"/images/%Y/%m/"</code>
echo -n "$PREFIX$FILENAME-resized.EXTENSION" | pbcopy
```</p>

<p>嗯，还不错，整个过程中就用了我十几分钟时间而已，以后我在写博客时插入图片就方便多了！</p>

<p>不过等等，好像有点不对劲儿，我回过头来看了看这段脚本：7行代码只有1行是我独立写的！没有<code>Google</code>的话，查看<code>man date</code>和<code>man echo</code>也可以解决其中一部分问题，不过文件扩展名部分估计又得花较长时间。</p>

<p>仔细分析一下，之前的成就感荡然无存。</p>

<h4>更多的例子</h4>

<p>我相信，过几周我再来写这样一个简单的脚本时，上面那一幕还是会出现。开发者的IDE的外延已经将<code>Google</code>和<code>Stack Overflow</code>集成了。很难想象没有这两个IDE的<code>插件</code>我要怎样工作。</p>

<p>其实除此之外，日常工作中这样的事情每时每刻都在发生：</p>

<ol>
<li>Ansible里如何创建一个给用户<code>robot</code>读写权限的目录？</li>
<li>Python 3中启动简单HTTPServer的命令是？</li>
<li>Spring Boot的Gradle String是？</li>
<li>Mongodb中如何为用户<code>robot</code>授权？</li>
<li>Gulp里一个Task依赖另一个Task怎么写？</li>
</ol>


<p>等等等等，这个列表可以根据你的技术栈，偏向前端/后端的不同而不同，但是相同的是在<code>Google</code>和<code>Stack Overflow</code>上搜索，阅读会浪费很多时间，而这些本来都是可以避免的。</p>

<h3>肌肉记忆</h3>

<p>大脑在对信息存储上有很高级的设计，如果某件事情不值得记忆，大脑会自动过滤掉（比如我们很容易获得的搜索结果）。而对于那些频繁发生，计算结果又不会变化的信息，大脑会将其下放到“更低级别”的神经去记忆。比如各种运动中的肌肉记忆，习武之人梦寐以求的“拳拳服膺”，“不期然而然，莫知之而至”。</p>

<p>这里也有两个小例子：</p>

<h4>一个C语言的小程序</h4>

<p>上周末我买了一个茶轴的机械键盘，打开包装之后我很兴奋，赶紧插在我的笔记本上，打开一个编辑器，心说敲一些代码体验一下。几秒钟后，我发现敲出来的是：</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int main(int argc, char *argv[]) {</p>

<pre><code>if(argc != 3) {
    fprintf(stderr, "Usage: %s ip port\n", argv[0]);
    return -1;
}

fprintf(stdout, "Connecting to %s %d\n", argv[1], atoi(argv[2]));

return 0;
</code></pre>

<p>}
```</p>

<p>然后在命令行里</p>

<p>```sh
$ gcc -o hello hello.c
$ ./hello
Usage: ./hello ip port</p>

<p>$ ./hello 10.180.1.1 9999
Connecting to 10.180.1.1 9999
```</p>

<p>整个过程极为流畅，上一次开发C代码已经是4年多前了。也就是说，我的手指已经记下了所有的这些命令：</p>

<ol>
<li>Linux下<code>main</code>函数的convention</li>
<li><code>fprintf</code>的签名</li>
<li><code>stderr/stdout</code>用法的区分</li>
<li><code>main</code>函数不同场景的返回值</li>
<li><code>gcc</code>命令的用法</li>
</ol>


<p>另外一个小例子是<code>vim</code>编辑器。我使用<code>vim</code>已经有很多年了，现在在任何一个Linux服务器上，编辑那些<code>/etc/nginx/nginx.conf</code>之类的配置文件时，手指就会<code>自动</code>的找到快捷键，<code>自动</code>的完成搜索，替换，跳转等等操作。</p>

<h3>刻意练习</h3>

<p>对比这两个例子，一方面我惊讶于自己目前对搜索引擎、<code>Stack Overflow</code>的依赖；一方面惊讶于<code>肌肉记忆力</code>的深远和神奇。结合一下两者，我发现自己的开发效率有望得到很大的提升。</p>

<p>比如上面列出的那些略显尴尬的问题，如果我的手指可以<code>自动</code>的敲出这些答案，那么节省下的搜索、等待、阅读的时间就可以用来干别的事情，比如跑步啊，骑车啊，去驾校学车被教练骂啊等等，总之，去过自己的生活。</p>

<p>这方面的书籍，博客都已经有很多，比如我们在ThoughtWorks University里实践的<code>Code Kata</code>，<code>JavaScript Dojo</code>，<code>TDD Dojo</code>之类，都已经证明其有效性。</p>

<p>如果你打算做一些相关的练习，从<code>Kata</code>开始是一个不错的选择。每个<code>Kata</code>都包含一个简单的编程问题，你需要不断的去练习它（同一个题目做20遍，50遍等）。前几次你是在解决问题本身，慢慢就会变成在审视自己的编程习惯，发现并改进（比如快捷键的使用，语法的熟悉程度等等），这样在实际工作中你会以外的发现自己的速度变快了，而且对于重构的信心会变大很多。其实道理也很简单：如果你总是赶着deadline来完成任务，怎么会有时间来做优化呢？</p>

<p>这里有一些参考资料和<code>Kata</code>的题目，可供参考：</p>

<ul>
<li><a href="https://sites.google.com/site/steveyegge2/practicing-programming">Practicing Programming</a></li>
<li><a href="https://blog.codinghorror.com/the-ultimate-code-kata/">The Ultimate Code Kata</a></li>
<li><a href="http://codekata.com/">一些Kata的题目</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CI上的Web前端性能测试]]></title>
    <link href="http://abruzzi.github.com/2016/02/performance-testing-in-ci/"/>
    <updated>2016-02-20T18:18:00+08:00</updated>
    <id>http://abruzzi.github.com/2016/02/performance-testing-in-ci</id>
    <content type="html"><![CDATA[<h2>Web站点的响应速度</h2>

<p>雅虎在2006年就发布了一份提升Web站点响应速度的<a href="https://developer.yahoo.com/performance/rules.html">最佳实践指南</a>。该指南包含了35条规则，分为7个类别。这些规则已经被广泛使用，并指导人们在新的站点设计时更有针对性的考虑问题。这份指南已经成了Web前端性能度量的一个事实标准了。</p>

<p><a href="http://yslow.org/">YSlow</a>是一个基于这份指南的测试工具，它可以测试一个站点是否“慢”，以及为什么“慢”？你可以通过很多方式来使用<a href="http://yslow.org/">YSlow</a>，比如Firefox，Chrome的插件，命令行工具，甚至PhantomJS这样的无头（Headless）浏览器。YSlow会检测你的站点中的资源是否没有压缩，是否缺失了超时设置，更进一步，它还会检测你的JS/CSS是否已经压缩/精简化，图片的尺寸，是否使用了CDN等等很多的维度。它还可以生成很多格式的报告，比如打分信息，TAP协议的输出，以及junit测试报告的格式。</p>

<p>我们这里讨论如何在持续集成服务器上设置一个<code>YSlow</code>任务，这个任务会在每次构建之后，测试你应用的性能指标，以帮助你更快的发现和定位问题。当然，我推荐你在<code>staging</code>环境，很多开发者在测试环境，本地开发环境都会启动很多对<code>Debug</code>友好的设置，比如未压缩的JS/CSS，没有超时设置的响应等，这会导致该构建任务的<code>打分</code>不够准确。</p>

<p><img src="/images/2016/02/jenkins-report-resized.png" alt="jenkins failure" /></p>

<h3>搭建CI环境</h3>

<p>按照传统方式，如果要搭建一个这样的CI任务，我们需要至少做这样一些事情：</p>

<ul>
<li>安装JDK</li>
<li>安装Jenkins</li>
<li>安装<a href="http://phantomjs.org/">PhantomJS</a></li>
<li>安装<a href="http://yslow.org/phantomjs/">YSlow.js脚本</a></li>
</ul>


<p>然后设置环境变量，在Jenkins上创建任务，并运行YSlow.js脚本。这个任务很简单，只需要设置好参数，然后将结果输出为Jenkins上的报告即可。比如：</p>

<p><code>sh
$ phantomjs /var/share/yslow.js -i grade -threshold "B" -f junit \
http://bookmarks-frontend.s3-website-us-west-2.amazonaws.com/ &gt; yslow.xml
</code></p>

<ul>
<li><code>-i grade</code> 展示打分（grade）信息（还可以是basic/stats/all）等</li>
<li><code>-threshold "B"</code> 指定失败的阈值为B</li>
<li><code>-f junit</code> 输出为<code>junit</code>识别的XML格式</li>
</ul>


<p>这里的阈值可以是数字（0-100分），字母（A-F级别）或者一个JSON字符串（混合使用）</p>

<p><code>sh
-threshold '{"overall": "B", "ycdn": "F", "yexpires": 85}'
</code></p>

<p>上面的命令会测试站点<code>http://bookmarks-frontend.s3-website-us-west-2.amazonaws.com/</code>的各项指标，并应用雅虎的那35条规则，并最终生成一个<code>junit</code>测试报告格式的文件：<code>yslow.xml</code>。</p>

<p>但是维护CI环境是一个比较麻烦的事情，而且既然每个项目都可能会用到这样的<code>基础设施</code>，一种好的做法就是将其做成一个<code>镜像</code>保存起来，以方便其他项目的复用！这里我们使用<code>docker</code>来安装和配置我们的CI环境，配置完成之后，我们可以将<code>docker</code>的镜像分享给其他团队，也可以供我们在下一个项目中使用。</p>

<h3>基于docker/docker-compose的环境搭建</h3>

<p>在<a href="https://www.docker.com/">docker</a>出现之前，我们要搭建一个<code>测试</code>或者<code>staging</code>环境，往往需要很多个不同角色的机器：有专门的数据库服务器，文件服务器，缓存服务器，Web服务器，反向代理等等。这样在成本上显然是个不小的开销，如果将所有不同的组件部署在同一台机器上，则又可能互相干扰，只需要一个小小的失误，整个系统就需要重新配置。更可怕的是，这个环境和生产系统不一致，那么很可能真实的错误要等到系统上线之后才会被发现。</p>

<p>比如在2012年，我所在的一个项目中，客户的系统采用传统的J2EE架构。本地开发中，我们使用了Jetty作为容器，而<code>测试</code>和<code>Staging</code>环境使用了Tomcat。由于Tomcat对空格的处理和Jetty有所不同，我们在本地测试通过，并且运行良好的代码，在<code>Staging</code>变得完全不能工作。这个问题花费了团队很多时间来排查错误。</p>

<p>在<code>docker</code>出现之后，我们可以在一台物理机器上运行多个互不干涉的容器，每个容器可以是一个组件（比如运行数据库的容器，Web服务器容器等等）。这样不但缩减了成本，而且可以让我们的环境尽可能和生产环境一致（有的项目甚至直接将CI出来的镜像应用到生产中）。不过对多个容器的管理是一个很麻烦的事情，好在<code>docker</code>提供了<a href="https://docs.docker.com/compose/overview/">docker-compose</a>工具来解决这个问题。使用<code>docker-compose</code>可以定义一组互相独立，但是又可以协作在一起的容器，这样我们可以很容易的搭建一个<code>仿生产</code>环境。</p>

<p>比如我们可以定义个<code>docker-compse.yml</code></p>

<p>```yml
app:
  build: .
  links:</p>

<pre><code>- db:postgres
</code></pre>

<p>  ports:</p>

<pre><code>- 8000:8000
</code></pre>

<p>  volumes:</p>

<pre><code>- .:/app
</code></pre>

<p>  working_dir: /app
  entrypoint: /app/start.sh
  environment:</p>

<pre><code>JDBC_DATABASE_URL: jdbc:postgresql://postgres:5432/bookmarks
DATABASE_USER: bookmarks-user
DATABASE_PASS: bookmarks-password
</code></pre>

<p>db:
  image: postgres:9.3
  ports:</p>

<pre><code>- 5432:5432
</code></pre>

<p>  environment:</p>

<pre><code>POSTGRES_DB: bookmarks
POSTGRES_USER: bookmarks-user
POSTGRES_PASSWORD: bookmarks-password
</code></pre>

<p>```</p>

<p>这个<code>docker-compose</code>定义了两个组件，<code>app</code>和<code>db</code>。<code>db</code>使用了<code>postgres:9.3</code>镜像，并设置了自己的环境变量。<code>app</code>则从当前目录<code>.</code>构建一个新的镜像，<code>app</code>与<code>db</code>通过<code>links</code>属性连接起来。</p>

<p>如果在当前目录执行<code>docker-compose build</code>命令，<code>docker-compose</code>会找到本地的<code>Dockerfile</code>，然后构建出一个<code>docker</code>的镜像，并启动该容器，同时，它还会启动<code>postgres:9.3</code>容器作为数据库组件。这样我们的环境就被完整的搭建好了。</p>

<h4>搭建CI环境</h4>

<p>```yml
app:
  build: .
  ports:</p>

<pre><code>- 8080:8080
- 50000:50000
</code></pre>

<p>  volumes:</p>

<pre><code>- ./data:/var/jenkins_home
</code></pre>

<p>```</p>

<p>这个配置，表明我们会根据当前目录的<code>Dockerfile</code>来构建一个镜像。</p>

<p>通过命令<code>volumns</code>，我们将本地目录<code>./data</code>映射为<code>jenkins_home</code>，这样我们定义的job信息，以及插件的安装都会放到本地的目录中，方便管理。配置完成之后，构建并启动该容器：</p>

<p>```
FROM jenkins:latest</p>

<h1>Env</h1>

<p>ENV PHANTOMJS_VERSION 1.9.6
ENV PHANTOMJS_YSLOW_VERSION 3.1.8
ENV SHARE_BIN /var/share</p>

<h1>Install stuff by using root</h1>

<p>USER root
RUN apt-get update
RUN apt-get upgrade -y
RUN apt-get install -y git wget libfreetype6 libfontconfig bzip2</p>

<p>RUN mkdir -p $SHARE_BIN</p>

<p>RUN wget -q --no-check-certificate -O /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 \
https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2
RUN tar -xjf /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2 -C /tmp
RUN rm -f /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64.tar.bz2
RUN mv /tmp/phantomjs-$PHANTOMJS_VERSION-linux-x86_64/ $SHARE_BIN/phantomjs
RUN ln -s $SHARE_BIN/phantomjs/bin/phantomjs /usr/bin/phantomjs</p>

<p>RUN wget -q --no-check-certificate -O /tmp/yslow-phantomjs-$PHANTOMJS_YSLOW_VERSION.zip \
http://yslow.org/yslow-phantomjs-$PHANTOMJS_YSLOW_VERSION.zip
RUN unzip /tmp/yslow-phantomjs-$PHANTOMJS_YSLOW_VERSION.zip -d $SHARE_BIN/
USER jenkins
```</p>

<p>执行下面的命令来设置并启动CI服务器：</p>

<p><code>sh
docker-compose up
</code></p>

<p><img src="/images/2016/02/jenkins-in-docker-resized.png" alt="jenkins in docker" /></p>

<p>创建新任务，并指定该任务执行的命令为：</p>

<p><code>sh
$ phantomjs /var/share/yslow.js -i grade -threshold "B" -f junit \
http://bookmarks-frontend.s3-website-us-west-2.amazonaws.com/ &gt; yslow.xml
</code></p>

<p>由于此时<code>phantomjs</code>已经被安装到了容器中，我们可以直接在jenkins中使用。运行结束之后，这个命令会生成一个报告：</p>

<p><img src="/images/2016/02/jenkins-report-resized.png" alt="jenkins failure" /></p>

<ul>
<li>没有压缩内容</li>
<li>没有添加过期的头信息</li>
</ul>


<p>在产品环境，我们需要使用反向代理来添加这些头信息，以保证最终用户在使用Web站点时的体验。</p>

<h3>总结</h3>

<p>我们只需要很少的配置就可以设置好一个工作良好的CI任务，这样在程序员某天引入了未经压缩的JS/CSS或者UX不小心提供了巨大而未经处理的图片时，你可以尽快的得到通知，并在正是上线之前发现这些问题。</p>

<p><a href="https://github.com/abruzzi/phantomjs-yslow">代码配置</a>在这里。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术的执念]]></title>
    <link href="http://abruzzi.github.com/2016/02/pitfall-of-technology/"/>
    <updated>2016-02-14T17:34:00+08:00</updated>
    <id>http://abruzzi.github.com/2016/02/pitfall-of-technology</id>
    <content type="html"><![CDATA[<h2>知识漩涡</h2>

<p>只需稍加留意，我们就会发现自己被各种技术，工具包围。<a href="https://www.thoughtworks.com/radar">ThoughtWorks的技术雷达</a>差不多每隔半年就会更新一次，而项目中更是会遇到很多已经从技术雷达上消失的技术，项目上的旧技术/旧框架还在服役，新的技术/工具/语言/框架又在迅速的出现，有些昙花一现，迅速被新的后来者取代，有的留下来了，不过也都在不断的演化，改变（不兼容的API，不同的版本等等随处可见）。</p>

<p>如果你不幸是一个前端工程师，那么这个更新速度还要更加迅速。三年前<code>Backbone</code>是主流，两年前是<code>Angular.js</code>，去年是<code>React</code>，紧接着<code>Flux</code>，<code>Reflux</code>等作为React的扩展而成为了新的主流；<code>Grunt</code>流行过一段时间，很快被<code>Gulp</code>替代，而新的<code>Webpack</code>又依稀有大一统的趋势。每周几乎都能看到新的框架涌现，双向绑定，虚拟DOM，事件代理，同构，后端渲染，更友好的语法糖，更快的执行速度等等等等，几乎任何一个方向都有无穷无尽的变化。</p>

<p><img src="/images/2016/02/full-stack-js-resized.png" alt="full stack js" /></p>

<p>而后端也好不到哪里去，容器技术，Web框架，ORM，构建脚本，自动化测试工具，依赖管理，应用服务器等等，你总有很多的选项，却又无法在事先区分到底哪个技术/工具更靠谱，更适合项目。</p>

<p>置身其中，往往有眼花缭乱，应接不暇的感觉。知识工作者当然需要<strong>终身不断</strong>的学习，但是像目前这种节奏，我很怀疑这是一种健康的状态。周围经常有人抱怨，好不容易上手了一个前端的MVC框架，一看周围的项目，大家已经在spike另外的框架/工具了（这意味着你在项目上无法使用该框架了……）。仅仅从学习的速度上来讲，我们已经远远无法跟上科技演化的节奏了，这是<strong>人类</strong>自身的一种限制。</p>

<h3>知识的陷阱</h3>

<p>假设你在一个<code>Ruby</code>项目上，学习了<code>Rails/ActiveRecord/RSpec/MySQL</code>。如果下一个项目还是<code>Ruby</code>，同样的技术站，你会觉得这是一种重复，因为除了业务逻辑、业务对象变化了之外，并没有新的内容，还是<strong>同样的</strong>技术。如果下一个项目是<code>Python</code>，技术栈变成了<code>Django/nose/PostgreSQL</code>，你可能会觉得有所提升，因为学到了不同的技术，框架，共建工具，测试工具等等，其实仔细观察，这还是一种重复，古人云：“换汤不换药”者，是也。</p>

<p>在目前我们所处的时代，信息以远远超过人们能接受的速度不断的被创造出来，一方面信息传播的速度大大提升了，另一方面是信息传播的渠道也极具多样化。我们无时无刻不被过载的信息包围着，即使你不主动的去尝试获取新的信息，手机App里的微信，微博，Flipboard，Pocket，知乎，开发者头条，Feedly，果壳，丁香园等等的推送已经足以提供给你足够的信息（大部分甚至都来不及消费就变成了历史信息而被忽略）。</p>

<p>以我自己为例，从2015年10月到现在（2016年2月），我学习了很多东西，看一下下面这张图：</p>

<p><img src="/images/2016/02/tech-tree.png" alt="tech tree" /></p>

<p>图中的灰色方框中的内容是项目要求的知识，另外的则是我根据自己的兴趣学习的（两者基本上各占一半）。事实上有很多内容（尤其是根据自己兴趣学习的）在真正要使用时，可能还需要学一遍。这些内容可能让我产生了<strong>我学到了好多东西</strong>的错觉。其实这个在另一个角度显现了技术人员的一个误区：以为自己可以掌握所有软件开发相关的知识（或者说太过于纵容自己的好奇心和兴趣）。</p>

<h2>过载的信息</h2>

<p>身处这样的信息过载环境，我们很难不为自己对信息的缺乏而感到不安，担心自己错过了什么重要的信息，这种担心和焦虑会促使我们进一步将时间消耗在对信息的获取上，从而更无暇思考什么是真正重要的。</p>

<p><a href="http://book.douban.com/subject/1013208/">《如何阅读一本书》</a>将书分为两类：一种是提供资讯/信息（known）的，一种是帮助你理解（understand）信息的。相对于理解来讲，资讯本身其实并不那么重要。我们大部分人目前采用的碎片化的阅读方式无法提供给我们足够的“理解力”。我们都有这样的体验，有些书特别耗费脑力，读起来很累，而另一些书则非常轻松，易于消费。碎片话的阅读方式易于消费，只需要很少的思考就可以读懂，但是危害严重，它们并不会让帮助你提升理解力。</p>

<p>但是直觉上我们会选择容易的事情来做，虽然这种浅层次的阅读只对扩展信息/资讯有帮助，对提升理解力则几乎无用。而我们在处理日常工作中的问题时，能真正帮助的，只有理解了的那部分知识。我在2014年，曾经有几个月屏蔽了所有微信，微博，内容聚合类的应用，也尽量少的去技术论坛，每天就是写代码，读纸质书，除了最初几天的忐忑之外，整个过程的收获非常大（而且也没有漏掉任何重要的信息）。</p>

<h3>知识框架</h3>

<p>技术人员有时候会有一种想要把所有技术都掌握的<code>执念</code>，这在局外人来看是一种荒诞不经的想法，但是置身其中，你很难看出这一点。毕竟，有意思的东西是在太多了，各种范式的编程语言，编译器技术，人工智能，数据可视化，地理信息系统，嵌入式设备，软硬件结合，大数据，自动化测试等等，每一个方向都有无穷无尽的有意思的东西。</p>

<p>但是在知识规模如此巨大的今天，一个人是无法掌握所有技术的（更不用说新的技术还在不断的涌现出来）！这就要求我们有节制的来聚焦在某些技术上，而视其他技术如无物。当然这需要很大的勇气和魄力，不过唯有如此，技术人员才有可能有真正的长进和成就。</p>

<p>我基于自己的经验，绘制了一个<code>Web开发</code>方面的知识框架，这个框架上包含了一个比较全的技能/知识集合，也是我认为一个<code>Web开发</code>人员应该掌握的一些知识点。</p>

<p><img src="/images/2016/02/knowledge-framework.png" alt="knowledge framework" /></p>

<p>在成为一个专家之前，你需要先对要学习的领域有一个全面的认识。也就是说，做<code>Web开发</code>，需要尽可能覆盖到这个框架上的所有点。一旦完成了这棵树上的所有节点，就不用再去做第二次了，这时候你可以尝试找到树上的某一个分支，深入下去。这个听起来好像和我之前文章中的观点有所矛盾，其实不然。我在<a href="http://icodeit.org/2015/06/do-we-really-short-for-front-end-developer/">《我们真的缺前端工程师》</a>一文中提到过，工程师不应该将自己束缚在前端开发上，要了解整个软件开发的全生命周期。这里的观点其实是一致的，即首先要了解软件开发全生命周期中的所有节点，然后再有所侧重的去找自己的兴趣点来发展，即：先建立广度，再建立深度。</p>

<h2>应对方法</h2>

<h3>对于知识的陷阱</h3>

<p>当因自己的兴趣（而不是项目驱动，也就是没有实际的土壤来验证）而想要学习一个新的知识时，对照<code>知识框架</code>，如果发现你已经在历史上学过它了，那就强迫自己放弃这个念头。比如如果你很熟悉用<code>rspec</code>来编写测试，忽然有一天心血来潮，想要学习JUnit，正确的做法就是泡杯茶，等这种冲动自己过去。相信我，一旦有了Java项目，你可以非常快速的掌握JUnit，而且很快会找到对应的feature，就像一个长期工作在Java技术栈上的同事那样！</p>

<h3>对于过载的信息</h3>

<p>实践中，首先要令自己相信：<code>你无法掌握所有的知识，即使仅仅在软件开发领域</code>。有了这个大前提之后，你只需要采取<code>先建立广度，再建立深度</code>的原则即可：</p>

<ul>
<li>做减法（在建立了<code>知识框架</code>之后，有针对性的学习）</li>
<li>主动，深度阅读经典</li>
<li>为那些<code>有趣但非自己关注方向</code>的知识赋予较低的优先级</li>
</ul>


<p>另外，还可以尝试将微信，微博关闭一段时间，或者至少可以不去点那些朋友圈里的<code>《老X聊微服务》</code>或者<code>《12个你不知道的Sublime技巧》</code>文章，保持专注，保持简单。</p>
]]></content>
  </entry>
  
</feed>
