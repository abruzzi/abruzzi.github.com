<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2016-01-10T16:05:07+11:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[穷人的持续集成与持续交付（下）]]></title>
    <link href="http://abruzzi.github.com/2016/01/a-poor-mans-cd-part2/"/>
    <updated>2016-01-10T14:05:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/a-poor-mans-cd-part2</id>
    <content type="html"><![CDATA[<h1>客户端程序的的持续交付</h1>

<p><a href="http://icodeit.org/2016/01/a-poor-mans-cd-part1/">上篇文章</a>介绍了如何使用一些免费的服务来实现服务器端API的持续集成、持续交付环境的搭建。有了服务端，自然需要有消费者，在本文中我们将使用另外一个工具来实现纯前端的站点的部署。</p>

<p>其中包括：</p>

<ul>
<li>持续集成（单元测试，集成测试等）</li>
<li>持续部署/持续交付</li>
<li>静态站点托管</li>
</ul>


<p>除此之外，我们还会涉及到：</p>

<ul>
<li><a href="https://github.com/natritmeyer/site_prism">自动化UI测试site_prism</a></li>
<li>静态站点的发布脚本</li>
<li>aws的<a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html">命令行工具</a></li>
</ul>


<p>我们的应用最后看起来是这样子的。</p>

<p><img src="/images/2016/01/bookmarks-app-resized.png" alt="bookmarks app" /></p>

<h2>技术选型</h2>

<p>我们在本文中，将采取另外一套免费服务来完成环境的搭建</p>

<ul>
<li><a href="http://www.thoughtworks.com/">ThoughtWorks</a>出品的<a href="https://snap-ci.com/">Snap CI</a>作为持续集成/持续交付环境</li>
<li><a href="https://console.aws.amazon.com/s3/home?region=us-west-2">AWS的S3</a>作为应用发布的地方</li>
</ul>


<p><code>Snap CI</code>是一个非常易于使用的持续交付环境，由于很多关于持续集成，持续交付的概念和实践都跟<code>ThoughtWorks</code>有关，所以这个产品对于构建，流水线，部署等等的支持也都做的非常好。</p>

<p><code>S3</code>是亚马逊的云存储平台，我们可以将静态资源完全托管在其上。<code>S3</code>的另一个好处是它可以将你的文件变成一个Web Site，比如你的目录中有<code>index.html</code>，这个文件就可以作为你的站点首页被其他人访问。这个对于我们这个前后端分离项目来说非常有用，我们的<code>css</code>，<code>js</code>，<code>font</code>文件，还有入口文件<code>index.html</code>都可以托管于其上。</p>

<h2>实例</h2>

<p>在本文的例子中，我们将定义3个<code>stage</code>。<code>Snap CI</code>将一次发布分为若干个<code>stage</code>，每个<code>stage</code>只做一件事情，如果一个<code>stage</code>失败了，后边的就不会接着执行。</p>

<p>我们的3个<code>stage</code>分别为：</p>

<ol>
<li>单元测试</li>
<li>集成测试</li>
<li>部署</li>
</ol>


<h3>准备工作</h3>

<p><code>bookmarks-frontend</code>是一个纯前端的应用，它会消费后端提供的API，但是其实它并不知道（也不应该知道）后端的API部署在什么地方：</p>

<p>```js</p>

<p>$(function() {</p>

<pre><code>var feeds = $.get(config.backend+'/api/feeds');
var favorite = $.get(config.backend+'/api/fav-feeds/1');

$.when(feeds, favorite).then(function(feeds, favorite) {
    //...
});
</code></pre>

<p>});
```</p>

<p>由于我们在本地开发时，需要<code>backend</code>指向本地的服务器，而发布之后，则希望它指向<a href="http://icodeit.org/2016/01/a-poor-mans-cd-part1/">上一篇文章</a>中提到的服务器，因此我们需要编写一点构建脚本来完成这件事儿：</p>

<p>```js
var backend = 'http://quiet-atoll-8237.herokuapp.com';</p>

<p>gulp.task('prepareConfig', function() {</p>

<pre><code>gulp.src(['assets/templates/config.js'])
.pipe(replace(/#backend#/g, 'http://localhost:8100'))
.pipe(gulp.dest('assets/script/'));
</code></pre>

<p>});</p>

<p>gulp.task('prepareRelease', function() {</p>

<pre><code>gulp.src(['assets/templates/config.js'])
.pipe(replace(/#backend#/g, backend))
.pipe(gulp.dest('assets/script/'));
</code></pre>

<p>});
```</p>

<p>我们定义了两个<code>gulp</code>的task，本地开发时，使用<code>prepareConfig</code>，要发布时，使用<code>prepareRelease</code>，然后定义一个简单的模板文件<code>config.js</code>：</p>

<p>```js
module.exports = {</p>

<pre><code>backend: '#backend#'
</code></pre>

<p>}
```</p>

<p>然后可以很简单的包装一下，方便本地开发和发布：</p>

<p><code>js
gulp.task('dev', ['prepareConfig', 'browserify', 'concatcss']);
gulp.task('build', ['prepareConfig', 'script', 'css']);
gulp.task('release', ['prepareRelease', 'script', 'css']);
</code></p>

<p>这样，我们在本地开发时，只需要简单的执行：</p>

<p><code>sh
$ gulp
</code></p>

<p>即可。而在发布阶段，只需要执行：</p>

<p><code>sh
$ gulp release
</code></p>

<h3>单元测试</h3>

<p>我们在<code>Snap CI</code>上将<code>github</code>上的代码库关联起来，然后添加一个名叫<code>unit-test</code>的<code>stage</code>，指定这个<code>stage</code>对应的命令为：</p>

<p><code>sh
npm install
gulp
</code></p>

<p><img src="/images/2016/01/snap-ci-unit-resized.png" alt="Snap CI unit" /></p>

<p>这样，每当我们有新的提交之后，<code>Snap CI</code>都会拿到新代码，并执行上述命令，如果执行成功，则本地构建成功。</p>

<h3>集成测试</h3>

<p>由于采取的是<strong>前后端分离</strong>的策略，我们的应用可以完全独立与后端进行开发，因此我们设置了一个<code>fake server</code>，具体细节可以参考<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">我之前的博客</a>，也可以看源码。不过这里我们要为集成测试编写一个脚本，并在<code>Snap CI</code>上执行。</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>export PORT=8100
bundle install</p>

<h1>launch the application</h1>

<p>echo "launch the application"
ruby app.rb 2>&amp;1 &amp;
PID=$!</p>

<h1>wait for it to start up</h1>

<p>sleep 3</p>

<h1>run the rspec tests and record the status</h1>

<p>rspec
RES=$?</p>

<h1>terminate after rspec</h1>

<p>echo "terminate the application"
kill -9 $PID</p>

<h1>now we know whether the rspec success or not</h1>

<p>exit $RES
```</p>

<p>这个脚本中，首先安装所有的<code>gems</code>，然后启动<code>fake server</code>并将这个server放置在后台运行，然后执行<code>rspec</code>。当<code>rspec</code>测试执行完成之后，我们终止服务进行，然后返回结果状态码。</p>

<p>这里使用了<code>capybara</code>和<code>poltergeist</code>来做UI测试，<code>capybara</code>会驱动<code>phantomjs</code>来在内存中运行浏览器，并执行定义好的<code>UI</code>测试，比如此处，我们的UI测试：</p>

<p>```rb
require 'spec_helper'</p>

<p>describe 'Feeds List Page' do</p>

<pre><code>let(:list_page) {FeedListPage.new}

before do
    list_page.load
end

it 'user can see a banner and some feeds' do
    expect(list_page).to have_banner
    expect(list_page).to have_feeds
end

##...
</code></pre>

<p>end
```</p>

<p><img src="/images/2016/01/snap-ci-it-resized.png" alt="Snap CI logs" /></p>

<h3>部署</h3>

<p>首先需要在<code>S3</code>上创建一个<code>bucket</code>，命名为<code>bookmarks-frontend</code>。然后为其设置<code>static website hosting</code>，这时候<code>AWS</code>会assign一个新的域名给你，比如<code>http://bookmarks-frontend.s3-website-us-west-2.amazonaws.com/</code>。</p>

<p>然后你需要将这个<code>bucket</code>设置成<code>public</code>，这样其他人才可以访问你的<code>bucket</code>。</p>

<p><img src="/images/2016/01/aws-s3-public-resized.png" alt="AWS S3" /></p>

<p>有了这个之后，我们来编写一个小脚本，这个脚本可以将本地的文件上传至S3。</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<h1>install gulp and its dependencies</h1>

<p>npm install</p>

<h1>package stuff, and point the server to the right place</h1>

<p>gulp release</p>

<h1>upload the whold folder</h1>

<p>aws s3 cp public/ s3://bookmarks-frontend \</p>

<pre><code>--recursive \
--region us-west-2 \
--acl public-read
</code></pre>

<p>```</p>

<p><code>aws</code>命令是<code>aws command line</code>提供的，另外我们需要在环境变量中设置AWS提供给你的token：</p>

<p><code>sh
AWS_ACCESS_KEY_ID=xxxxxxxxxx
AWS_SECRET_ACCESS_KEY=xxxxxxxxxx
</code></p>

<p>然后我们就可以将本地的<code>public</code>目录递归的上传到S3的对应目录了！</p>

<p><img src="/images/2016/01/snap-ci-pipeline-resized.png" alt="snap ci pipeline" /></p>

<p>完整的代码可以在<a href="https://github.com/abruzzi/bookmarks-frontend">此处下载</a>。</p>

<h2>总结</h2>

<p>我们前端的持续交付也介绍完了。现在前后端应用完全独立，发布也互不影响。不论是服务器端新增加了API，还是添加了新数据，客户端的发布都不受影响；同样，修改样式，添加新的<code>JavaScript</code>也完全不会影响后端。更重要的是，所有的发布都是一键式的，开发者只需要一个<code>git push</code>就可以享受这些免费服务提供的自动构建，自动化测试以及自动部署的功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[穷人的持续集成与持续交付（上）]]></title>
    <link href="http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1/"/>
    <updated>2016-01-09T23:34:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/a-poor-mans-cd-part1</id>
    <content type="html"><![CDATA[<h1>服务器端应用的持续交付</h1>

<p>本文将使用一些免费的服务来为你的项目搭建<code>持续交付</code>平台，这些服务包括</p>

<ul>
<li>持续集成环境</li>
<li>持续部署环境</li>
<li>服务端应用托管</li>
</ul>


<p>以及一些可以用于本地开发使用的开源工具如：</p>

<ul>
<li><a href="https://github.com/abruzzi/node-build-monitor">基于Node的构建monitor</a></li>
<li><a href="https://toolbelt.heroku.com/">Heroku的命令行工具</a></li>
<li><a href="https://github.com/travis-ci/travis.rb">Travis CI的命令行工具</a></li>
</ul>


<p>除此之外，我们在过程中编写的脚本还可以用以本地构建，如果你的团队中正好已经有CI工具/CD工具，将这些脚本集成进去也是一件非常容易的事情。</p>

<p><img src="/images/2016/01/heroku-log-resized.png" alt="heroku real time log" /></p>

<h2>背景知识</h2>

<h3>软件的度量</h3>

<p>传统的管理方法论，在软件开发这个领域来说基本上是不工作的。软件项目的不确定性使得人们畏惧，管理者希望通过一些数字，指标来让自己感到某种虚幻的“掌控感”。软件行数，测试覆盖率，代码故障率等数字的名声基本上已经很糟了，经常有人拿来讽刺那些追求虚幻掌控感的“领导”。</p>

<p>但是有一个数字，即使最顽固的“自由主义者”也会认为是有意义的，那就是周期时间（cycle time）。简而言之，就是一个需求从产生到最终上线所需要的时间。其中包括了需求分析，设计，编码，测试，部署，运维等活动，可能还会包含后续的监控。</p>

<p>其实不论是瀑布模型，还是迭代开发的方式，或者其他的方法论，周期时间的缩短都是至关重要的。而具体到周期内，单纯的开发时间变长或者测试时间变长都无关紧要。比如项目A的开发时间是测试时间的2倍，项目B则恰恰反过来，这并不能说A做的比B好，真正有意义的是A的周期时间是否比B更短。</p>

<p>单纯改善项目过程中的某一个阶段的时间，可能并不能达到预期的目的。局部优化并不一定会带来全局的优化。换言之，<strong>通过某些策略来提高软件测试的效率未必能减少周期时间！</strong>。</p>

<h3>持续交付</h3>

<p>传统情况下，企业要进行软件开发，从用户研究到产品上线，其中会花费数月，甚至数年（我的一位印度同事给我聊起过，他的上家公司做产品，从版本启动到版本上线需要整整两年时间！）。而且一旦软件需求发生变更，又有需要数月才能将变更发布上线。除了为变更提交代码外，还有很多额外的回归测试，发布计划，运维部门的进度等等。而市场机会千变万化，在特定的时间窗口中，企业的竞争者可能早已发布并占领了相当大的市场份额。</p>

<p>在软件工程领域，人们提出了持续交付（continuous delivery）的概念，它旨在减少周期时间，强调在任何时刻软件都处于可发布状态。采用这种实践，我们可以频繁，快速，安全的将需求的变化发布出来，交由真实世界的用户来使用，在为用户带来价值的同时，我们也可以快速，持续的得到反馈，并激励新的变化产生（新的商业创新，新的模式等）。</p>

<p>持续交付包含了自动化构建，自动化测试以及自动化部署等过程，持续改进开发流程中的问题，并促进开发人员，测试人员，运维人员之间的协作，团队可以在分钟级别将变更发布上线。</p>

<h3>持续交付相关技术及实践</h3>

<ul>
<li>版本控制（配置管理）</li>
<li>持续集成CI</li>
<li>自动化测试</li>
<li>构建工具及构建脚本</li>
<li>部署流水线</li>
</ul>


<p>团队通过版本控制来进行协作，所有的代码会在持续集成环境中编译，代码静态检查/分析，自动化测试（还可能产生报告等）。除此之外，CI还还需要有自动化验收测试，自动化回归测试等。</p>

<p>持续交付则更进一步，它将环境准备，持续集成，自动化部署等放在了一起。通过全自动（有些过程可以设置为手动，比如发布到产品环境）的方式，使得软件可以一键发布。如果上线后发现严重defect，还支持一键回滚的机制（其实就是将之前的一个稳定版本做一次发布，由于发布流程已经经过千锤百炼，所以发布本身就变得非常轻松，安全）</p>

<p>这篇文章中，我们会使用<code>git</code>+<code>github</code>作为版本控制工具，<code>travis-ci</code>作为持续集成环境，<code>gradle</code>作为构建工具，<code>Heroku</code>作为应用的部署环境。这些工具都是免费服务，如果你需要更高级的功能（比如更多的并发数，更大的数据库），则可以选择付费套餐。不过对于我们平时的大部分side project来说，免费服务已经足够。</p>

<h2>实例</h2>

<p>我在<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">《前后端分离了，然后呢？》</a>这篇文章中，提到了一个叫做<code>bookmarks</code>的应用，这个应用是一个前后端分离的非常彻底的应用。</p>

<p>我们这里会再次使用这个应用作为实例，并采用不同的两个免费服务（<a href="https://travis-ci.org">travis-ci</a>和<a href="https://snap-ci.com">snap-ci</a>）来完成<code>持续部署</code>环境的搭建。</p>

<h3>bookmarks服务器</h3>

<p><code>bookmarks-server</code>是一个基于<code>spring-boot</code>的纯粹的<code>API</code>，它可以被打包成一个<code>jar</code>包，然后通过命令行启动运行。在本文中，我们我们将会将这个server部署到<a href="https://dashboard.heroku.com/">heroku</a>平台上。</p>

<p>首先需要定义一个<code>Procfile</code>，这个是我们应用的入口，<code>heroku</code>根据这个文件来明确以何种方式来启动我们的应用：</p>

<p><code>
web: java -Dserver.port=$PORT -jar build/libs/bookmarks-server-0.1.0.jar --spring.profiles.active=staging
</code></p>

<p>由于我们在本地使用的使用<code>mysql</code>，而<code>heroku</code>默认的是<code>postgres</code>数据库，因此需要在<code>application.yml</code>中额外配置</p>

<p>```yml
spring:
  profiles: staging</p>

<p>  datasource:</p>

<pre><code>driverClassName: org.postgresql.Driver
url: ${JDBC_DATABASE_URL}
username: ${DATABASE_USER}
password: ${DATABASE_PASS}
</code></pre>

<p>  jpa:</p>

<pre><code>database_platform: org.hibernate.dialect.PostgreSQLDialect
hibernate:
  ddl-auto: update
</code></pre>

<p>```</p>

<p>有了这些配置后，我们需要创建一个<code>heroku</code>应用：</p>

<p><code>sh
$ heroku create
Created http://quiet-atoll-8237.herokuapp.com/ | git@heroku.com:quiet-atoll-8237.git
</code></p>

<p>创建之后，我们可以在界面上对这个应用进行一些配置（当然，也可以通过命令行，具体参看<code>heroku help</code>）。为了支持数据库，需要为我们的应用添加一个<code>postgres</code>的AddOn。添加之后，<code>heroku</code>会为我们提供一个<code>postgres</code>的连接地址，格式大概是这样：</p>

<p><code>
postgres://username:password@host:port/database
</code></p>

<p>然后我们需要在<code>Heroku</code>的配置界面中配置一些环境变量：</p>

<p><img src="/images/2016/01/heroku-config-resized.png" alt="heroku env config" /></p>

<p>这样，当应用部署到<code>Heroku</code>上之后，我们的应用就可以读到这些配置了（注意<code>application.yml</code>中的环境变量<code>JDBC_DATABASE_URL</code>）。</p>

<h4>搭建持续集成环境</h4>

<p>持续集成环境，这里我们选用最简单的<code>travis-ci</code>，它可以很容易的与<code>github</code>集成。</p>

<ul>
<li>在项目X中定义一个<code>.travis.yml</code>的文件</li>
<li>将你的代码push到github上</li>
<li>绑定github帐号到<code>travis</code></li>
<li>在<code>travis</code>中启用项目X</li>
</ul>


<p>这个<code>.travis.yml</code>因项目而异，我们这里的项目是<code>spring-boot</code>，所以只需要指定<code>java</code>即可：</p>

<p><code>yml
language: java
</code></p>

<p>如果是<code>java</code>项目，并且项目中有<code>build.gradle</code>，<code>travis-ci</code>会自动执行<code>gradle check</code>任务。</p>

<h4>自动化部署</h4>

<p>当CI运行成功之后，我们需要<code>travis-ci</code>帮我们将应用程序发布到<code>heroku</code>上，这时候需要做一些修改。最简单的方式是直接安装<code>travis-ci</code>的命令行工具到本地：</p>

<p><code>sh
$ gem install travis -v 1.8.0 --no-rdoc --no-ri
</code></p>

<p>然后通过<code>heroku</code>的<code>auth:token</code>命令获得<code>heroku</code>的token，在加密并写入<code>.travis.yml</code>：</p>

<p>```sh
$ heroku auth:token
00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067</p>

<p>$ travis encrypt 00xxxxxxxxxxxxx55d11dbd0cxxxxxxxxxxfe067 --add
```</p>

<p>当然可以合并为一条命令：</p>

<p><code>sh
$ travis encrypt $(heroku auth:token) --add
</code></p>

<p>将加密过的token存入<code>.travis.yml</code>文件。最后的结果大致如下：</p>

<p>```yml
language: java
deploy:
  provider: heroku
  api_key:</p>

<pre><code>secure: ...
</code></pre>

<p>  app: quiet-atoll-8237
```</p>

<p>注意此处的<code>app</code>，正是我们的App的名字。另外，还需要给<code>build.gradle</code>添加一个名叫<code>stage</code>的task，<code>travis</code>在deploy时需要这个<code>task</code>：</p>

<p>```groovy
task stage {</p>

<pre><code>dependsOn build
</code></pre>

<p>}
```</p>

<p><img src="/images/2016/01/travis-deploy-resized.png" alt="travis deploy" /></p>

<p>这样，我们只需要在本地的一个提交，一切都会自动化起来：</p>

<ul>
<li>travis会执行<code>gradle check</code></li>
<li><code>gradle check</code>会编译并运行自动化测试</li>
<li><code>travis</code>会部署应用到<code>heroku</code>上</li>
<li><code>heroku</code>会自动重启服务</li>
</ul>


<p>我们可以在本地进行简单的测试（注意此处我们的<code>staging</code>环境的URL）：</p>

<p>```sh
$ curl https://quiet-atoll-8237.herokuapp.com/api/feeds -s | jq .
[
  {</p>

<pre><code>"id": 1,
"url": "http://icodeit.org/2016/01/how-to-summarize-privious-project/",
"title": "如何持久化你的项目经历",
"author": "icodit.org",
"summary": "通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。",
"publishDate": "2016-01-07"
</code></pre>

<p>  },
  {</p>

<pre><code>"id": 2,
"url": "http://icodeit.org/2015/11/get-started-with-reflux/",
"title": "你为什么应该试一试Reflux？",
"author": "icodit.org",
"summary": "React在设计之初就只关注在View本身上，其余部分如数据的获取，事件处理等，全然不在考虑之内。",
"publishDate": "2016-01-09"
</code></pre>

<p>  }
]
```</p>

<p>完整的<a href="https://github.com/abruzzi/bookmarks-server">代码在这里</a>。</p>

<h2>其他</h2>

<h3>CI monitor</h3>

<p><a href="https://github.com/abruzzi/node-build-monitor">node-build-monitor</a>是一个非常容易配置，使用的CI monitor，我们只需要进行简单地配置，就可以将<code>travis</code>的状态可视化出来</p>

<p>```json
{
  "monitor": {</p>

<pre><code>"interval": 2000,
"numberOfBuilds": 12,
"debug": true
</code></pre>

<p>  },
  "services": [</p>

<pre><code>{
  "name": "Travis",
  "configuration": {
    "slug": "abruzzi/bookmarks-server"
  }
}
</code></pre>

<p>  ]
}
```</p>

<p>不过这个工具会在有网络异常时自动终止，我们可以通过一个简单的脚本来在它终止时自动重启：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>until node app/app.js
do</p>

<pre><code>echo "restarting..."
</code></pre>

<p>done
```</p>

<p><img src="/images/2016/01/ci-monitor-resized.png" alt="CI Monitor" /></p>

<h2>小结</h2>

<p>通过<code>travis</code>和<code>heroku</code>这样的免费服务，我们就可以轻松的将自己的项目做到持续集成+持续交付。我们后端的服务相对来说是比较容易的，但是涉及到一个前后端分离的架构，如何做到静态内容的托管，打包，部署，并和后端API集成起来，我会在下一篇文章中详细解释。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何持久化你的项目经历]]></title>
    <link href="http://abruzzi.github.com/2016/01/how-to-summarize-privious-project/"/>
    <updated>2016-01-05T12:44:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/how-to-summarize-privious-project</id>
    <content type="html"><![CDATA[<h1>下项目之后</h1>

<p>通常来说，下项目总是一件比较高兴的事（大部分团队还会一起吃个饭庆祝一下）。这里面既有终于摆脱了厌烦了的<code>技术栈</code>的解脱感，也有对新项目/新技术的向往，可能还有些在旧项目中做的不太满意的事情，可以在新项目重头再来的期望。</p>

<p>可能有点老生常谈了，不过这里我想说说下项目后如何做总结的事儿。对上一个项目的总结，其重要程度可能要远远超过你的想象。我是在2014年初，在一个客户现场的一个会议室和一位同事谈我的Annual Review的时候，才意识到这个问题的。</p>

<p>Annual Review会回顾我们过去一年的项目经历，有哪些方面的进步，同时也会展望未来的计划。但是这其中有几个问题：第一个问题是以年为单位的Review粒度太粗，有些经历已经淡忘，也有人可能一年会换好几个项目；第二个问题是对于大多数人来说，展望未来是一件比较容易的事儿，每个人或多或少都会有一些计划（比如学会前端的某些技术，尝试一些DevOps方面的工作，或者了解一下大数据等等）；但是对于回顾过去，我们其实并不擅长；最后一个问题是即使做了回顾，回顾的层次非常浅，作用并不大。</p>

<p>说到回顾过去，更多时候我们关注的是从项目中学到了什么样的新技术，这种浅层次的回忆和记流水帐是容易的，但是对于我们的成长并不会有太大的收益。真正会为帮助我们在将来的项目中做决策，甚至会影响我们学习效率，解决问题能力的是：<code>深度回顾</code>。</p>

<h2>深度回顾练习</h2>

<p>深度回顾可以帮助我们梳理知识，将实际的案例归纳总结为实际可用的知识。要获得这种能力，需要做一些针对性的练习。根据我自己的经验，这些练习大约可以归为3类，难度依次增加。</p>

<h3>项目上的直接经验</h3>

<p>这个练习比较简单，就是问问自己：“<strong>我在项目里学到了什么？</strong>”</p>

<p>要回答这个问题是很容易的，项目中用到的技术如模板引擎，前端框架，自动化测试套件，build工具等等，总结这些内容的过程，对于我们的PS来说都是“自动”发生的，几乎不需要付出额外的efforts。这些回顾、总结可以帮助我们成为一个“熟手”，即当下一次遇到相同或者类似的场景时，我们可以很容易直接应用这些经验。</p>

<p>更进一步，再问问自己在项目中的其他收获。比如客户关系处理的经历，团队建设的经验，甚至是写英文邮件的技巧等等方面，看看做的有没有问题，有没有提升的可能？</p>

<p>人类最牛逼的技能是：可以审视自己的行为。也就是站在旁观者的角度来看待自己的行为，随波逐流式的在各种琐事中沉浮事实上无法得到提升的。可以经常性的将自己置身事外，以一个旁观者的角度来审视自己做过的事情。并从中找出做得好的地方和不足的地方，然后自己给过去的自己一些建议，并记录下来。这些刻意的练习会帮助你养成回顾，从经验中学习的习惯，而这个习惯正是一个人区别于另一个人的绝对“捷径”。</p>

<h3>练习讲故事</h3>

<p>这个练习是，假想你遇到了一个同一个办公室的同事，他对你刚做完的这个项目很感兴趣，你来给他描述一下这个项目。描述的内容包括但不限于这些方面：</p>

<ul>
<li>项目的背景介绍</li>
<li>该项目以何种方式，为那些用户，带来了什么样的价值？（business model是什么）</li>
<li>该项目的实际用户数量是什么级别？</li>
<li>项目的部署，运维是如何操作的？</li>
<li>项目的监控是怎样做的？</li>
<li>当遇到系统故障，项目组是如何反应的？</li>
</ul>


<p>能把一件事情描述清楚是一件非常了不起的能力。我见过很多的程序员，写起代码来好不含糊，但是却很难将一件简单的事情讲清楚。我们当然要提防那些夸夸其谈，华而不实的“嘴子”，但是也至少得要求自己做到清晰，准确的将自己经历过的事情描述清楚。</p>

<p>描述项目背景需要至少需要交代这样一些内容：客户是谁，最终的消费者是谁，项目以何种方式运作（离岸交付，本地，onsite，咨询，培训等），我们<strong>帮助客户为消费者带来了什么样的价值</strong>。客户的商业模式是什么，在我们周围有哪些类似的项目。</p>

<p><img src="/images/2016/01/bmcanvas-basic-model-resized.jpg" alt="business canvas" /></p>

<p>即使在技术方面，也有很多被Dev忽略掉的信息，比如项目在产品环境中如何部署，数据中心建在何处，客户如何运维、监控等。实际的发布周期如何，发布流程如何，客户的内部论坛上都会有很多的这样的信息，但是很少有人关注。从一个项目roll off的时候，这些信息即使做不到了若指掌，至少也能描述清楚，否则难免有些“入宝山而空回”的遗憾。</p>

<h3>回顾项目中的挑战</h3>

<p>从简单的CRUD系统，到复杂的分布式计算，从企业内部的管理系统，到支持高并发、要求实时处理的交易平台，每个项目都会遇到一些挑战。除了技术上的挑战之外，还有陈旧而无文档的代码库，复杂的业务场景，不配和的客户接口人等等。挑战无处不在，那么作为项目中的一员，你是如何应对这些挑战的呢？最后又是如何解决的？</p>

<p>现实世界是一个充满了trade off的世界，我们需要做种种权衡，代码测试覆盖率和交付压力，性能和客户能负担的机器实例数量，框架A和框架B的优劣等等。我们在采取这个方案的时候，只能舍弃其他方案，由于谁也无法在事先准确预料采取某个方案一定是对的，那么在一个失败的方案背后，其实也是一个很好的教训，至少可以为未来的决策提供帮助。</p>

<ul>
<li>遇到的最大的挑战是什么？</li>
<li>这个挑战是如何被解决的？</li>
<li>如果有机会重做，你会如何考虑？</li>
</ul>


<h3>其他练习</h3>

<p>这里列出了一些我常用的，辅助性的练习。它们可以帮助你更好的梳理项目上学到的技能、知识，并且转换成你自己的知识。这些练习未必一定要等到项目结束之后才做，事实上它们都可以应用在日常的工作中。</p>

<ul>
<li>记笔记</li>
<li>写博客</li>
<li>在办公室内演讲</li>
<li>去社区贡献话题</li>
</ul>


<p>很多人都会记笔记，但只有一小部分的人在记录之后会持续翻阅。很多人会使用Evernote/印象笔记之类的工具将一些临时的想法，问题的思路，知识点的细节等记录下来，但是仅仅记录是不够的，笔记需要不断的检索、整理、提炼、修正、总结和归纳。在不断的加工之后，这些笔记可能会得到沉淀，并升华形成一些更有意义的内容（比如个人博客，或者可以发表到InfoQ/IBM DeveloperWorks平台上的文章等）。</p>

<p>除了记录笔记之外，写博客也是一种很好的总结形式。通过将素材不断充实、整理、完善，最终形成一个可供别人直接消费的文章，不但可以锻炼到总结能力，还可以很好的提升表达能力，而且可以帮助你将已有的知识体系化。如果你的博客写成了系列，也很容易通过Gitbook等将其发布为一本电子书，从而影响更多人（说不定还可以赚点咖啡钱）。</p>

<p>写博客/电子书，终究是书面形式的。事实上一个人可以很容易的通过文字将自己的实际情况隐藏起来。举个极端的例子：如果有足够的动机（比如公司的KPI要求），即使不熟悉某种语言/工具，仅仅通过Google，一个人也可以通过这种“作弊”的方式写出一篇“专家级”的文章。但是对于演讲这种面对面的形式，则基本上无法作弊，从而也更具有挑战性。另一方面，对于一个新的知识、技能，自己掌握是一回事儿，要讲出来让别人也能听懂，并从中收益，则完全是另外一回事儿。作为咨询师，语言表达（包括书面和演讲）能力的重要性勿庸赘言。整理知识，并归纳为演讲，会帮助你将体系化后的知识更好的表达出来。</p>

<p>在办公室里讲session有一定的挑战，但受众毕竟是“自己人”，压力相对会小一些（比如在ThoughtWorks，我们非常鼓励员工为其他人讲session，具体可以参看<a href="http://icodeit.org/2015/01/how-we-do-training-in-thoughtworks/">我的这篇文章</a>）。要在社区中演讲则要面临更大的挑战，通过将话题不断锤炼，不断归纳，最终形成可以在社区分享的话题，则不但可以提高内容的质量，也可以更好的锻炼表达能力和临场应变能力。</p>

<p><img src="/images/2016/01/xian-resized.jpg" alt="xian community" /></p>

<p>不过归根结底，这些活动的重要输入还是对之前项目中的知识、经历的深度回顾。</p>

<h2>总结</h2>

<p>从项目上下来之后，需要深入思考并总结之前的经验，这种深入思考会帮助你建立比较完整的知识体系，也可以让你在下一项目中更加得心应手，举一反三。如果只是蜻蜓点水般的“经历”了若干个项目，而不进行深入的总结和思考，相当于把相同的项目用不同的技术栈做了很多遍一样，那和我们平时所痛恨的重复代码又有什么不同呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2015]]></title>
    <link href="http://abruzzi.github.com/2016/01/my-2015/"/>
    <updated>2016-01-02T19:54:00+11:00</updated>
    <id>http://abruzzi.github.com/2016/01/my-2015</id>
    <content type="html"><![CDATA[<h1>2015年总结</h1>

<p>2015年在不经意间就过去了。又是一年。按照惯例，我会在年末回顾一下这一年自己的进步，收获以及一些感慨（牢骚）。然后对来年做一点展望，看看什么地方可以做的更好。</p>

<h2>项目经历</h2>

<p>今年基本上经历了三个项目，性质也都不一样：</p>

<ul>
<li>海外交付</li>
<li>国内交付</li>
<li>国内售前</li>
</ul>


<p>3月前的项目以及没有什么印象了，依稀觉得项目上的所有实践都是“错”的，可能由于太过与荒诞，所以大脑自行将这段抹去了。</p>

<p>4月到6月在深圳的一个国内交付项目上，交付压力还挺大。不过也是在这个项目上，非常直接的体会到了其他角色的不容易。无论是客户的接口人，客户的项目经理，客户的领导，我们的开发，我们的UX，项目经理，还有交付的lead，所有人都不容易。</p>

<p><a href="http://icodeit.org/2015/07/is-project-manager-a-fool/">《项目经理是大傻逼吗》</a>这篇文章就是为了纪念这个项目，或者说是被这个项目驱动出来的。</p>

<p>6月之后回到办公室，在一个海外交付项目上。说是一个项目，中间其实换了6，7个不同的工作内容（出钱的是同一个客户而已）。总之一片混乱，所幸我们在10月前就结束了和这个客户的合作。这个项目事实上除了锻炼项目上人的耐心外，基本毫无益处。甚至对于很多毕业生来说，是深刻的伤害。</p>

<p>10月之后，我难得的在beach上待了下来，而且一待就是3个月。中间在一个联合国的项目上工作了2周，然后就是为另外一个咨询项目准备了几周方案。当然，闲是不可能闲着的。在beach上，如果不出意外，肯定会比项目上更忙！比如打黑工啊，内部什么系统的改进啊，总是有好多事情。</p>

<p>由于有一些本地的项目机会，而我又不在具体项目上，就来做这个售前的角色。帮助客户梳理需求，分析问题，设计方案，计算工作量等等。但是这个过程往往循环往复，一轮接着一轮，在合同确认之前，需要很多次讨论和交流。这应该不会是我自己的一个方向，在项目上写代码，培养新人，分享自己的学习所得，和他人一起进步，是我自己比较有热情的方向。</p>

<h2>技术方面</h2>

<p>在海外交付项目上，乏善足陈，项目中用到的也是非常厚重，已经至少10年的技术。通常来看，这样的大组织，没有人对要做的事情真正关心。好不容易遇到一个特别靠谱的人，结果我们的项目又结束了。国内项目上倒是有很多有意思的东西：</p>

<ul>
<li>如何在前端代码中很好的使用MVC</li>
<li>流畅的前端开发模式</li>
<li>如何做前端的测试</li>
</ul>


<p>上面这三点，我希望可以找时间整理出一本电子书，可以让没有<code>工程级</code>做过项目的前端工程师能有一个参考。</p>

<p>另一方面，由于项目的压力，和项目人员的特殊性（开发就俩人，一个做前端，一个做后端，要集成就pair一下），所以很多实践都没有应用，比如结对，自动化测试等，做的都不够好。虽然我们很推崇，强调CI/CD的实践，但是当和客户的后端系统集成时，就各种悲剧。</p>

<p>联合国的项目上，技术栈比较新颖，上一家的技术人员使用了他们当时能找到的所有酷炫的新技术，并用在了项目中，然后他们公司被收购。留给我们的在今年来看，依然是<a href="http://icodeit.org/2015/11/get-started-with-reflux/">比较新的</a>：</p>

<ul>
<li>React</li>
<li>Reflux</li>
<li>ES6</li>
<li>mocha/chai</li>
</ul>


<p>而在国内售前，基本上没有写过一行代码，更多是更高层次（高不一定是好哦）的工作。确认需求，估算工作量，确定方案（前后端测试，开发方式，部署策略，自动化测试等等）。</p>

<p>2016年，我希望可以多学习一些具体的编程知识，比如：</p>

<ul>
<li>mongodb</li>
<li>数据分析，数据挖掘</li>
<li>容器技术如docker</li>
</ul>


<h2>书籍</h2>

<p>今年读了一些技术方面的书，更多的则是一些非技术类的。《自私的基因》是在2012年11月去墨尔本时，在广州白云机场买的，路上10个小时，读了几页。直到2015年才又拿起来，读了两章左右，基本上颠覆了我之前建立的对“进化论”的认识。</p>

<p>另外读了一些科普类的，比如《哲学家在干了些什么》，《上帝掷骰子吗》等，又扫了一次盲。再就是一些佛教相关的书籍，《西藏生死书》，《能断：金刚经》，《正见》等，人生观和价值观得到了刷新。</p>

<p>技术类的，主要是一些与具体技术关系不太大的，比如《恰如其分的软件架构》，《企业级应用架构模式》，《发布！》，《实例化需求》，《持续发布》之类。</p>

<p>虽然竣工于2014年，但是我的一本著作和一本译作都是2015年才发布出来，那就算作2015年的吧：</p>

<ul>
<li><a href="http://www.amazon.cn/gp/product/B012R5A1NQ">《轻量级Web应用开发》</a></li>
<li><a href="http://www.amazon.cn/dp/B015317A94">《7周7Web框架》</a></li>
</ul>


<h2>社区</h2>

<p>今年在深圳的时候，有幸和ThoughtWorks的首席科学家<code>马丁.福勒</code>在同一次活动中作为讲师。</p>

<p><img src="/images/2016/01/shenzhen-resized.jpg" alt="shenzhen" /></p>

<p>回到西安之后，在本地社区中还讲过一个<code>前端工程师需要掌握的技能列表</code>的session</p>

<p><img src="/images/2016/01/xian-resized.jpg" alt="xian" /></p>

<p>2016年希望可以做一些更加深入的topic，以及一些更有意思，可以帮助到更多已经<code>在路上</code>的工程师们。</p>

<h2>People Development</h2>

<p>这个不知道如何翻译了，但是确实做了一些具体的事情：</p>

<ul>
<li>给我的sponsee们安排了读书会</li>
<li>组织了一次《编写可维护的JavaScript》的workshop</li>
<li>组织sponsee来做一个side project</li>
<li>组织《Web开发实战》的workshop</li>
</ul>


<p>我自己总结出来了一套组织workshop的方式，其实很简单：</p>

<ol>
<li>做好计划，做好课表，做好课件</li>
<li>找学员，同时从学员里找出<code>有基础，而且有意愿接着run workshop的人</code></li>
<li>讲课，收集feedback，并改进课表，课件</li>
<li>将run workshop的任务传递给那些<code>有基础，而且有意愿接着run workshop的人</code></li>
</ol>


<p>2016年希望可以找到更多的<code>候选人</code>，并帮助他们成为更好的讲师，教练。</p>

<h2>总的感悟</h2>

<p>总体的感觉是很忙，各种事情千头万绪，没有了清晰的一个vision，也没有了指导，自身的发展方向也变得模糊起来。一部分原因可能是压力的方向变了，在项目上的单一的压力下总是可以找出一些事情来的，但是在项目之外，各种可见不可见的压力都慢慢浮现。对于这些隐形的，不可见的，但是又可以感受到的压力，需要认真思索对策，然后想办法搞定。</p>

<p>学习上有点“半瓶醋”的感觉，很多技术都接触了，但是不见得深入。缺乏空杯心态，这个是2016年希望自己能改进的地方。另一方面，希望在一个IT系统的架构层面有一些积累，以便在考虑项目的问题时，能够更加全面，而不至于陷入细节，只见树木，不见森林。</p>

<p>2016，当然还会很忙，只是希望忙的过程中可以多一些快乐。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目经理是大傻B吗？]]></title>
    <link href="http://abruzzi.github.com/2015/07/is-project-manager-a-fool/"/>
    <updated>2015-07-07T23:18:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/07/is-project-manager-a-fool</id>
    <content type="html"><![CDATA[<h3>一些背景故事</h3>

<p>坊间流传着很多关于PM（Project Manager，项目经理）的笑话，在这些不无刻薄的笑话中，PM往往被描述成一个盲目的承诺客户需求变更，不了解实际情况而又喜欢指手画脚的专门坑开发的家伙。毋庸置疑，这些笑话当然是那些聪明的<strong>开发</strong>发明的（不过你得承认，在很多团队，这些笑话其实是实实在在每天都在发生着的）。</p>

<p>在智力工作中，对于开发的实际进度，开发速率等问题，具体着手做的人永远比在背后指手画脚的人更有发言权。软件开发正是一项智力活动，优秀的软件无法通过人力的堆积而产生。一个关于PM的经典的讽刺是：PM就是那些指望着9个女人在1个月内生出1个小孩的二货。从传统的意义上来说，这个笑话还真是一针见血。</p>

<p><img src="/images/2015/07/keep-calm-i-m-the-project-manager-resized.png" alt="project manager, 来源:http://sd.keepcalm-o-matic.co.uk/i/keep-calm-i-m-the-project-manager.png" /></p>

<p>我记得在加入ThoughtWorks不久的时候，私底下经常听到这种论调：PM基本就是项目上被人鄙视（当然大家不会表现的那么明显就是了）的角色，基本上负责<strong>团队建设</strong>去哪儿这种杂事儿就行了，团队的其他人员可以高度自治，并不需要被管理，项目就会如预期般按时交付。</p>

<p>这些论调在某些情况下可能是对的。但是如果在国内项目的这个上下文里，没有一个专业的PM来协助项目，控制需求，划定项目范围，与客户谈判等等，没有任何一个项目是可以真正成功交付的，指望<em>高度自治</em>的开发们来完成项目？咱们还是现实一些吧。</p>

<p>一个悲剧的事实是，开发人员往往都恃才傲物，有时还会带着一幅要来拯救世界的心态来做项目，这事实上和客户的期望，以及PM的期望是有很大出入的。在项目启动之初，PM会面临重重困难：首先，团队里的每个人都不好管，而且每个人都认为自己不需要被管理（当然这种想法在大部分时候都是错误的）；其次，PM需要和客户快速建立信任，并推动项目进入正轨；最后，往往留给PM自己的时间也非常有限，他们也需要学习大量的项目相关的上下文（业务上下文，人员关系，资源协调等）。</p>

<h3>除了催进度，PM平时还干点啥？</h3>

<p>本质上开说，PM其实就是一个轮询器：识别所有的项目风险，然后不断跟进。项目风险可能是技术风险，比如某个技术上压根搞不定的问题。也可能资源风险，比如人手不够，或者开发者很多，但是没有足够的设计师协助，这些风险都会导致项目无法按照时间交付。一个客观事实是，所有项目都会变化，做完售前到需求分析结束之后，需求可能会发生巨大变化，如果还按照报价来做项目很可能会<strong>亏本</strong>。</p>

<p>PM的一个重要职责就是在项目之初将项目范围定下来，这个范围的划分非常依赖经验：划得少了团队得天天加班，累得跟狗一样，然后才能保证交付（据我的经验，虽然项目一般不会天天加班，但是总会有一些攻关，打补丁的事儿，最后还是会累成狗），划得多了客户不买单，意思是就这个小功能你要做两个月，绝对不行。PM需要协调这些不一致，还需要和销售，客户等方面不断谈判，写方案，排计划，简而言之，也是累跟狗一样（而且潜在的，还可能被那些天真幼稚的开发坑 — 开发经常会高估自己的开发速度，反正我还没遇到过低估的，你见过吗？）。</p>

<p>我们每天看到的PM干的最多的事情就是：元芳，那个接口怎么样了？什么时候能做完，有什么blocker？李柯，昨天说的代理的事情怎么样了？小波，高保真什么时候出？何方，我们周三下午要showcase，麻烦你订一下会议室吧……</p>

<p><img src="/images/2015/07/pm-resized.png" alt="pm" /></p>

<h3>除了写代码，Dev平时还干点啥？</h3>

<p>如果脱离开PM的角度，做为一个孤傲的开发，时常会觉得PM为什么老是问我进度，是不是怀疑我的能力？为什么监视我的工作？相信我，其实他才不想监视你。但是你设想一下：如果你不参与代码编写，每天只是看旁边的哥们写，你如何知道他实际的进度呢？而且众所周知，开发很难准确的更新自己的工作进度，而且遇到问题也很少积极主动的报告，通常都会自己埋头尝试解决。那么，轮询显然是一种成本最低，反馈最快的方法。</p>

<p>不主动更新进度是另外一个大问题，不过这个得单独说。关于更新进度，典型的的场景是：早上站会的时候，开发目光呆滞的盯着某个卡片，努力回忆其中的验收条件以及自己的当前进度，如果恰好脑海中的技术细节和卡片的描述在某个点上匹配了，他会迅速的告诉你，目前进展良好，今天上午应该就可以做完。开发在更新进度时，不是盲目乐观，就是跳进太细节的地方进行讨论，最后讨论的结果就是：跟没更新一样，除了浪费了10分钟时间。但是别忘了，PM会在15分钟之后再来轮询一次。</p>

<p>PM每周都需要汇总很多数字，比如本迭代完成的点数，剩余的点数，总体进度如何，有没有人有请假计划，遇到什么blocker，每个blocker的具体原因，每个风险点的最终日期是何时，等等等等。他肯定不能记住这些数字，所以可能一天之内向你询问数次。</p>

<h3>PM的其他职责/技能</h3>

<p>上边说到的其实只是描述PM的辛苦，而最微妙，最考验PM的是其“察言观色”的技能。这绝对是一个工作经验在10年之内完全无法获得的技能（而且是在中国的项目上工作10年）。比如，在showcase的时候，有个客户说，嗯，挺好，整个流程就是这样的，后续你们的UI是不是还会美化？如果你遇到这个情况，请问，这个客户是什么意思？</p>

<p>如果你能回答上这个问题（而不是提出问题），那说明你还离PM差十万八千里。成熟的PM会先判断，问这个问题的人是什么角色，以及他在系统中的话语权如何，还有其他人就此问题的反应如何等等因素，然后找到一个合适的答案。</p>

<p>PM另一个绝技是扯皮（不是贬义），开发会花一个下午（我是说10分钟）去跟客户讨论需求的范围吗？或者会为5个人天来讨价还价吗？我想开发大概会说，尼玛，找其他供应商吧，老子不伺候了。</p>

<p>一个项目的成功，需要多方合作，这里说的合作并不局限在甲方和乙方之间，即使乙方的团队之中，也需要很紧密的合作。比如项目经理和开发，设计师之间的合作。如果仅仅从开发的角度来看，PM有时候看起来就是和客户站在一起来整开发的一样，比如催进度，过分保守的估算人天（导致团队加班赶工）。PM需要释放团队中的负面情绪，保证团队士气，还需要他做一些开发不屑于做的琐碎的事情。</p>

<h3>设身处地，替他人着想</h3>

<p>本质来来说，每个项目都是一次生意。在去掉那些繁杂的流程和形式之后，做一个项目和你去菜市场买菜其实并无二致。举个例子，根据传统，软件开发界特别喜欢找建筑行业做类比，我也找个建筑方面例子。装修房子的时候，我们会要求施工方提供图纸（水电改造，基本设计等），按期交付（确定工期），同时会界定项目范围（比如刷墙，贴地砖，吊顶，封阳台等等），会要求工人按时来上班，正常出勤，认真工作，直到项目结束。过程中我们还会讨价还价，比如捎带着把栏杆拆除，捎带着敲掉一面隔离墙等等。在过程中，我们还会敲敲地砖，检查过门石，检查吊顶，测试水电等等。作为甲方，这些活动相信没有人会觉得过分。</p>

<p>但是一旦我们做乙方，也就是施工方的时候，情况就全变了。比如客户要求打卡，有人会觉得不爽，客户要求代码review，有人会觉得不爽，要求代码有设计文档，有人会觉得不爽，要求设计有多个备选方案，有人会觉得不爽。大多数情况下，这都是虚无缥缈的虚荣在作祟，这种情况所在多有，不过还不致命。一旦涉及到讨价还价（不是商务上的讨价还价，而是和客户就工作量达不成一致，或者就某个技术方案达不成一致之后），开发全部歇菜，一言不合，转身就走，压根不具备讨价换件的能力，这样还怎么做生意啊？设身处地想一下，如果你是甲方，当提出了一些合理的要求（比如需要一方提供验收标准，通过验收测试等），结果施工方还一脸的“我不跟你说了，你就是以大傻B”，你能乐意吗？</p>

<h3>如何合作？</h3>

<p>说了这么多，这两种角色在同一个项目上要如何合作呢？我想，作为开发来说，有这样几点可能：</p>

<p>首先，理解PM的工作。在很多时候，开发会有莫名其妙的优越感（其实每个角色都会有了，比如销售看不上技术人员，技术Lead看不上PM等等），主要原因其实是<strong>坐井观天</strong>，对其他角色的辛苦和工作不清楚。然后错误的认为别人的工作都很low。</p>

<p>之前听一个同事讲过一个小session，里面有一点我印象非常深刻：不要因为一个人<strong>不会某个技术</strong>而鄙视他。就好比你不应该因为不会弹钢琴，而被一个会弹钢琴的人鄙视一样。道理很简单，但是开发在长期的“宅”生涯或者坐井观天中，进化出了这种非理性的观点：如果一个人连vim（此处的vim可以换成任何其他技术）都不会，就压根不足以谈人生。</p>

<p>其次，学习如何报告进度。PM催你的根本原因是进度不明确，如果每一个潜在的风险都清楚的显示着进度，而且有明确的负责人，PM就会降低轮询的频率。这需要开发经过刻苦的练习才能达到：</p>

<ul>
<li>站会前自己花3分钟整理一下昨天做的工作</li>
<li>根据story的验收条件（最好有和BA/QA一起的讨论需求），进行合理的任务划分（tasking技能）</li>
<li>可以借助便签纸等工具，帮助自己明确进度（划分了5个子任务，昨天完成了3个，那么可以粗略的估计为60%）</li>
</ul>


<p><img src="/images/2015/07/tasking-resized.png" alt="tasking" /></p>

<p>再次，合理估算。有些时候，新人（来自于传统管理环境的新人）可能会误以为PM是一个管理的角色，或者处于某些考虑会在PM询问进度时做出一些错误的回答。比如PM在迭代启动会议上是问这个迭代我们有没有可能做完所有计划内的任务，作为一个负责任的开发，你需要在第一时间指出那些“非理性”的期望，以便PM进行更加准确的计划。</p>

<ul>
<li>明确告诉PM，有哪些需求是不可能按时交付的，PM会根据实际情况来重新定计划，并和客户确认</li>
<li>明确告诉PM一些可能的风险，<strong>团队整体</strong>对交付负责，而不是PM，或者开发</li>
</ul>


<p>按照经验，项目从来就不会按照计划进行，在做好一个粗略的计划之后，PM的职责更多的是进行动态调整。所以团队内部至少需要保持信息的流通，虽然可能短期来看可能会影响开发速度，但是从整体上来看，可以减少很多不必要的浪费。</p>

<p>简而言之，要站在别人的角度考虑问题：<strong>如果换做是你，你会怎么做？</strong></p>
]]></content>
  </entry>
  
</feed>
