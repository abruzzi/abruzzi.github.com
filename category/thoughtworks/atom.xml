<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ThoughtWorks | I code it]]></title>
  <link href="http://abruzzi.github.com/category/thoughtworks/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2014-06-26T11:22:52+10:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Yahoo pipes 服务做内容聚合 -- ThoughtWorks好声音]]></title>
    <link href="http://abruzzi.github.com/2014/01/use-yahoo-pipe-service-to-aggregate-blogs-you-care/"/>
    <updated>2014-01-01T19:48:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/01/use-yahoo-pipe-service-to-aggregate-blogs-you-care</id>
    <content type="html"><![CDATA[<h3>ThoughtWorks好声音</h3>

<p><a href="http://voice.thoughtworkers.org/">ThoughtWorks好声音</a>是一个聚合网站，内容来自众ThoughtWorker的博客，我们每周会汇聚一次，从众多的博客中挑选出一些P2(软件卓越)相关的主题，然后编为一辑，再分享出去。</p>

<p>但是从近100个博客中找P2相关的内容，这件事本身非常繁琐，如果每周都做这个重复劳动的话，那么软件卓越从何谈起呢？作为以解放人类为己任的程序员，我们绝对不能忍受纯体力的劳动。</p>

<h4>获取博客地址列表</h4>

<p>之前郑晔做了一个<a href="https://jinshuju.net/">金数据</a>的统计，请各位同事把自己的名字和博客地址登记在一个金数据的表单上：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/blog-colllecting.png" alt="image" /></p>

<p>接下来第一步就是把网页上的所有地址取下来，这一步很容易，从金数据的页面上用jQuery找到表格的第二列，然后将其中的文字取出来：</p>

<p>```js</p>

<p>$("table tr td:nth-child(2)").map(function(key, item) {</p>

<pre><code>return $(item).text().trim(); 
</code></pre>

<p>});</p>

<p>```</p>

<p>写到这里突发奇想，能不能用phantomjs去把这个动作自动化？</p>

<p>```js
page.open(url, function (status) {</p>

<pre><code>if (status !== 'success') {
    console.log('Unable to access network');
} else {
    page.injectJs('jquery.js');

    var links = page.evaluate(function() {
        return $("table tr td:nth-child(2)").map(function(key, value) {
            return $(value).text().trim();
        });
    });

    var results = underscore(links).filter(function(item) {
        return item.length &gt; 0; 
    }).map(function(item) {
        if(!new RegExp('^(https|http)').test(item)) {
            return "http://" + item;
        }
        return item;
    });
}
phantom.exit();
</code></pre>

<p>});</p>

<p>```</p>

<p>这样，results数组中就包含了所有的博客链接了，而且有的同事比较懒，提供的URL中不包含<code>http</code>，这段代码还顺手给这样的url添加了头尾。</p>

<p>然后<strong>第二步</strong>，我<strong>想象</strong>着应该再写个脚本，在这个数组中得每个url的后边加上诸如<code>rss</code>或者<code>atom.xml</code>之类的后缀，然后去获取每个博客的rss文件，然后根据这些信息做一些事情。吃午饭的过程中我还在想象这个工具分为几个模块，用什么样的语言来做开发等等细节。</p>

<p>吃完午饭，突然想起来之前熊杰貌似发过一个yahoo pipes生成的rss，我在邮件中翻出来之后，失望的发现我自己的博客都不在里边，想想熊杰貌似还在乌干达援助非洲人民，那就自己动手重新定义一个吧。</p>

<h4>Yahoo pipes 服务</h4>

<p><a href="http://pipes.yahoo.com/pipes/">Yahoo pipes</a>是一个用来定制聚合的服务，只需要定义好数据源(通常是rss/atom)，然后定义一些操作，比如排序，去重，联合等等。最后这个pipe会生成一个结果集，这些特性简直就是为我们这个需求定制的：</p>

<ol>
<li>将博客地址+'/rss' / 博客地址+'/atom.xml' 添加到一个个的fetcher上</li>
<li>将这些fetcher联合起来</li>
<li>将联合的结果排序(按照发表日期/更新日期)</li>
<li>生成最后的rss</li>
</ol>


<p>yahoo pipes提供的编辑器非常简单易用：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/single-pipe.png" alt="image" /></p>

<p>而且在编辑界面底下有一个预览界面：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/single-preview.png" alt="image" /></p>

<p>当然，当定义好完整的pipe之后，我们的ThoughtWorks好声音的源看起来是这样的：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/tvot-pipe-resized.png" alt="image" /></p>

<p>运行这个pipe之后，得到一个preview的界面：</p>

<p><img src="http://abruzzi.github.com/images/2014/01/tvot-pipe-run-resized.png" alt="image" /></p>

<p>最后，可以将这个pipe公开发布，或者将这个pipe生成的rss订阅到阅读器中，比如<a href="http://www.vienna-rss.org/">vienna</a>:</p>

<p><img src="http://abruzzi.github.com/images/2014/01/vienna-resized.png" alt="image" /></p>

<p>然后就可以一目了然的看到最近有哪些ThoughtWorker更新了自己的博客，又有那些是P2相关的，可以<code>理论上</code>减轻我们编辑很多的工作量。</p>

<h4>结论</h4>

<p>手里是锤子的时候，看着周围的东西都像钉子。有时候，那些又酷又炫的技巧/工具可能并非必须。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2013]]></title>
    <link href="http://abruzzi.github.com/2013/12/by-the-end-of-2013/"/>
    <updated>2013-12-29T16:56:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/12/by-the-end-of-2013</id>
    <content type="html"><![CDATA[<p>总的来说，2013年收获颇丰，感谢同事们(特别鸣谢胡凯，张凯峰，以及RCA的各位同事)的帮助，我的第一本技术书籍<a href="http://icodeit.org/jsccp/">JavaScript核心概念及实践</a>在今年5月出版了。8月到10月，我和王磊，张久坤两位同事，和ThoughtWorks其他office的同事一起，在印度为来自世界各地的毕业生上了近两个月的课。12月从第一个项目上roll off下来，然后加入自己的第一个咨询项目。</p>

<p>在期间还去西电给学生<a href="http://blog.csdn.net/gy0305/article/details/9117859">讲过一次session</a>，<a href="http://www.csdn.net/article/2013-05-29/2815458">接受了CSDN的一次采访</a>，本来打算赶10月份的校园招聘去学校讲点东西，后来由于出差耽搁了。但是感谢王欢给了我一个在郑大晔校上课的机会，我们每周六会对准ThoughtWorker们讲一些软件开发得session(TDD, Refactor, Pair Programming等)。</p>

<p>总之，2013过的充实而紧张，希望来年能更加的充实，也希望可以跟大家分享更多的有意思的session和博客。</p>

<h4>在TWU(ThoughtWorks University) 当老师</h4>

<p>2013年，最大的收获，应该是自己对于<strong>压力</strong>的新的认识。有一回和胡凯聊压力这个事儿，我说我自己是认可平时带着些压力去学习、工作的，胡凯的看法则是不应该是“带着些”，而是带着最大的压力。他给我举了个游泳的例子，说你在岸边是学不会的，只有被被人踢到水里，才有可能学会。</p>

<p>我觉得挺有道理，8月去印度参加TWU，当然有很多困难了，比如语言问题本身；和其他国家来的trainer一起交流的问题；给一群来自世界各地的学生用英文上课的问题；我周五从项目上下来，周六飞去印度普内，周日早上到达休息了半天，然后周三就要给其他国家的trainer用英文讲一个关于社会公正的演讲，而且形式限定在<a href="http://www.pechakucha.org/">pecha kucha</a>上，在这种压力下，我不止一次的后悔为什么把自己逼的这么紧？我的真实想法是把胡凯踢到水里学游泳，我自己回西安的项目继续每天做story。</p>

<p><img src="http://abruzzi.github.com/images/2013/12/twu-prepare-resized.png" alt="image" /></p>

<p>但是周三过去了，我的演讲虽然也不至于震惊四座，但是不论是英文，还是主题，还是演讲技巧本身，都得到了比较正常的feedback。我存活了下来！</p>

<p>如果说这个小范围的，面向trainer的，带有彩排性质的演讲的压力值为100的话，那么下一周，面对着二十多个来自世界各地的毕业生，给他们讲一个关于如何给别人feedback的session，压力值至少为500+。即使是来自墨尔本、伦敦、巴西的trainer都开始表情凝重的备课，我自己的心情就更不用说了。还有人开导我说，不论你有多紧张，坐在底下的那些家伙都比你紧张100倍。</p>

<p><img src="http://abruzzi.github.com/images/2013/12/twu-discuss-resized.png" alt="image" /></p>

<p>我清楚的记得，第一天结束后，我们互相击掌，还去酒吧喝了一杯来庆祝，当然，8点就赶紧撤回住处，准备第二天的session了，但是不管怎样，我又一次的存活下来了！</p>

<p>压力，必须压到自己要放弃，要退缩的那种程度，才能收获最多。一咬牙过去了，就海阔天空，进入一个新境界了。很多时候，自己总会给自己找很多借口，然后自己就把自己荒废了。李仲轩老人讲，练拳也一样，有人一听说有捷径，有了贼心，就不会出功夫了。</p>

<h4>练拳</h4>

<p>我虽然不能算是“自幼喜欢舞刀弄枪”，但是也一直对武术比较感兴趣，只是没有耐心去吃苦练而已。小时候只是跟父亲学过一点小擒拿之类，后来从家中找到一本《少林罗汉十八手》，自学未果，倒是记得一些招式的名字，如<strong>巧纫针，披身捶，僧推门，僧伏虎</strong>之类。2006年，看到了《逝去的武林》后，对内家拳产生了浓厚的兴趣，但是苦于没有老师，倒是我的兄长在石家庄，近水楼台先得月，找到一位教授他练习形意拳的老师，我跟着站了几天三体式，学了个劈拳和崩拳。</p>

<p>但是我自己也知道，那跟没练是一样的，练外行都骗不了。</p>

<p>2007年暑假，我跟<a href="http://v.youku.com/v_show/id_XMjIzNTIyMjY0.html">李林京老师</a>在石家庄学过一段时间的意拳。但是开学之后回到昆明，就开始三天打鱼两天撒网，后来干脆练网也撤了，借口是内家拳练习得有老师，不然十分危险，一旦受伤则后患无穷。武林盛传“练拳容易改拳难”，一旦练错，再来纠正就非常困难，不如不练。</p>

<p>毕业之后，就再也没有练过，但是见过高山，也知道其中的一些窍要，就是不困下功夫练，今年年初开始感觉颈椎不舒服，上班也感觉挺累的，就又开始站站桩休息脊椎。结果一周之内，隐疾全消，而且渐渐觉得精神比以前好一些了，然后就一直坚持站桩，技击桩怕练偏，就站平步桩。</p>

<p>截止今天为止，除了7月份去伦敦的飞机上没站以外（下了飞机赶到酒店赶紧补上），每天都在站。夏天有一次和同事分享任忠信先生的形意拳，有人怀疑是假的，我给他们试了下，虽然没有搭手即飞，发人丈外那么神奇，但是吓吓外行的效果已经有了。</p>

<p>明年一定要抽时间去石家庄找李老师好好学习一段时间。练拳不但在身体上可以让人强健，而且在精神上也有很多的好处。</p>

<p>其实传统武术，最重要的是锻炼脊椎，腰杆挺直之后，内力渐生，丹田气满之后自然中气充足，精神也会变好，再加上老是有一种别人打不过你的优势，自然容易产生自信（大不了打一架嘛，咱不怯）。蔡元培当年说过，要文明其精神，野蛮其体魄，就是这个意思。</p>

<h4>项目</h4>

<p>今年的12月中旬，我从RCA项目上正式Roll off，从2012年4月加入ThoughtWorks之后，就一直在这个项目上。在这个项目上主要关注在软件交付上，和所有的BAU项目一样，在RCA，能学到一个成熟的框架是怎么实实在在运行的，从开发，测试，仿真，生产环境都是通的，如果有心的话，可以接触到自动部署，负载均衡，数据库的主备配置，各级缓存等生产上才会遇到的问题，但是很多时候又会比较无聊，因为可能更多的是在做老代码的维护，bug的修复，新功能的开发可能较少。</p>

<p><img src="http://abruzzi.github.com/images/2013/12/rca-family-resized.png" alt="image" /></p>

<p>RCA总的来说，有经验的人居多，所以交付压力来说要小一些，而且带新人方面也没有太大压力。所以时间长了，大家都会觉得有点疲。我们会定期举行CBS(Come Build Something)，或者CSS(Come Share Something)这样的活动来刺激一下。我们团队上一般有8个人，每次CBS都是有3-4个ideas，然后结对去做，虽然不会产出什么划时代/跨世纪的产品，但是每次也都会有一些产出。可惜在坚持方面做的并不好。从项目上Roll off的当天，团队送我了一本书《人与神话》(据说排在<strong>程序员谎称读过</strong>的经典书籍排行榜的榜首，不过实话实说，当时非常感动，谢谢我们team和我并肩作战近两年的同事+朋友)：</p>

<p><img src="http://abruzzi.github.com/images/2013/12/rca-memory-resized.png" alt="image" /></p>

<p>从项目上roll off之后，加入了西安本地的一个咨询项目，以前端工程师的身份加入，新项目的人对前端开发的经验相对来说都比较少，但是有很强烈的学习愿望，而且动力也很足。新项目本身做起来也比较有意思，各种前端的比较现代的技术(测试，本地构建，CI)，框架(AngularJS, Jasmine)都可以很好的进行实践。</p>

<p><img src="http://abruzzi.github.com/images/2013/12/gis-front-end-resized.png" alt="image" /></p>

<p>刚开始的时候，也是压力巨大，但是咬牙挺过前三天之后，就容易多了。单元在新的一年，可以和新的团队一起将这个项目做好。</p>

<h4>旅游</h4>

<p>年初和老婆去了次厦门，纯粹度假的方式，无计划，无目的，在鼓浪屿上住了两天：</p>

<p>7月份，我和学海兄参加了欧洲的AwayDay，本来准备讲一个关于轻量级web应用开发的session，但是后来由于session太多，我的就被cancel了。</p>

<p><img src="http://abruzzi.github.com/images/2013/12/london-eye-resized.png" alt="image" /></p>

<p>在印度正好赶上印度的AwayDay:</p>

<p><img src="http://abruzzi.github.com/images/2013/12/india-away-day-resized.png" alt="image" /></p>

<p>在普内周边的一个古堡上：</p>

<p><img src="http://abruzzi.github.com/images/2013/12/india-hiking-resized.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将应用程序部署到heroku]]></title>
    <link href="http://abruzzi.github.com/2013/01/developing-with-heroku/"/>
    <updated>2013-01-26T19:02:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/01/developing-with-heroku</id>
    <content type="html"><![CDATA[<h3>heroku</h3>

<p>使用heroku，开发人员可以很容易的将自己的应用程序公开给世界上的其他用户使用，heroku会为你提供一个url，一些预设的空间如数据库（postgresql）等。这对于需要频繁远程showcase的场景提供了非常好的方式，当然对于开发人员向其他的开发人员或者最终用户展现自己的框架的外观/行为等场景也会非常有用。</p>

<h3>在heroku上注册用户</h3>

<p>首先，当然是在heroku上<a href="https://api.heroku.com/signup/devcenter">注册一个开发账户</a>，如果你已经注册过，就请接着第二步</p>

<h3>下载heroku的本地Toolbox</h3>

<p>heroku提供了一个很好用的<a href="https://toolbelt.heroku.com/">工具包</a>，通过这个工具包，开发人员可以很容易的对部署在heroku上的应用程序做操作。</p>

<h3>在本地登陆heroku</h3>

<p>如果没有上传过key的话，heroku会提醒你创建一个新的ssh公钥，然后上传到heroku（这个过程与使用github非常类似）</p>

<p><code>
$ heroku login
Enter your Heroku credentials.
Email: adam@example.com
Password:
Could not find an existing public key.
Would you like to generate one? [Yn]
Generating new SSH public key.
Uploading ssh public key /Users/adam/.ssh/id_rsa.pub
</code></p>

<p>如果已经上传过key，则可以直接登陆</p>

<h3>准备工作</h3>

<p>在本地生成一个应用程序的基本结构，如：<code>Gemfile</code>，目录结构等。然后在本地配置好git环境，比如：</p>

<p><code>
$ git init
$ git add .
$ git commit -m "init"
</code>
准备Procfile：</p>

<p><code>
web: bundle exec ruby app.rb -p $PORT -E production
</code>
<code>app.rb</code>相当于你的应用程序的主入口(main)，<code>-E</code>指定运行环境（此处指定为production），你的应用程序可能会根据次设置来进行一些资源的选择（数据库指向，资源文件位置等）</p>

<p>在上传之前，需要确保自己的应用程序可以在本地正常运行：</p>

<p><code>
foreman start
</code>
应用程序将在本地的5000端口上运行，此时可以做一些简单的验证，保证应用程序运行正常。</p>

<p><code>
$ git add .
$ git commit -m "ready for deploy app to heroku"
</code></p>

<h3>上传你的App</h3>

<p>这时，可以很轻易的将App上传到heroku了：</p>

<p><code>
$ heroku create
$ git push heroku master
</code>
当然，第一次上传可能会比较慢（取决于你应用程序的大小），如果一切正常，heroku将会尝试根据你的Gemfile来安装依赖，安装完成之后，会尝试根据Procfile中的配置启动你的应用程序。</p>

<p>如果你的应用程序会访问数据库（非postgresql的数据库），那么建议在Gemfile中指定当测试时使用该数据库，而在production环境中使用postgresql，因为heroku使用的正是postgresql：</p>

<p>```
configure :test do</p>

<pre><code>DataMapper.setup(:default, ENV['DATABASE_URL'] || "local-db-url")
DataMapper.finalize.auto_upgrade!
</code></pre>

<p>end
```</p>

<p>我的应用在本地使用sqlite，而在heroku中使用其提供的postgresql。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[是时候慢下来了]]></title>
    <link href="http://abruzzi.github.com/2013/01/where-am-i/"/>
    <updated>2013-01-09T20:56:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/01/where-am-i</id>
    <content type="html"><![CDATA[<p>某个晚上，我在网上为自己挑选一个适合出差的行李箱，两个小时之后，我突然发现我停留在了一个瑞士军刀的淘宝店里；本来计划晚上看看AppleScript的资料，结果一个小时之后，我在用python写一个opencv的小程序，又过了一个小时，我停留在Alfred的powerpack的支付页面，面对着15英镑的价格陷入沉思。</p>

<p>而且周围好像每个人都有这样类似的经历。我咨询其他同事遇到类似的情况怎么处理，有人推荐使用Todo列表，而且Todo最好列在纸上。当列表中的Todo被消灭时，会激发你去写下更多的task。这当然是个好办法，我很早的时候就写过一个软件来完成Todo管理：<a href="http://code.google.com/p/stodo/">sTodo</a>。但是当打开电脑之后，时间就完全不受控制了，网络上总是有各种各样好玩的东西，新的框架，新的语言，某种颠覆式的CSS框架，新奇而好用的软件，可以大大提高用户体验的UI库，太多了……。</p>

<p><img src="http://abruzzi.github.com/images/2013/01/stodo_edit.png" alt="sTodo" /></p>

<p>上周三的晚上，回家之后打开电脑，开始了“学习”，事实上是很盲目的在网络上游荡，当我意识到又要重蹈覆辙的时候，我毅然的合起了电脑，然后拿起一本纸质的《JavaScript: The good parts》。最后当我要睡觉时才发现，读了大概30多页，而且以前的一些概念也更加清楚了。而且事实上我并未因为没有打开计算机而有什么实质性的损失。</p>

<p>然后我突然意识到我之前的所谓的学习的方式有很大的问题，网络当然可以为你提供大量的信息，但是很多时候，这些呈碎片装的信息的作用并不如预期般的大。它会帮你解决手头的小问题，但是阻挡了你的视线，你本可以走的更远！</p>

<p>在网络上看资料，总是有一种紧迫感：这么多的东西都不会，落后于时代好多年。打开电脑，一个晚上过去了，你可能读了很多的东西，但是记下来的非常少，因为总是会被各种链接，图片等干扰，这个看似在学习的过程事实上完全是在浪费实践，一天之后，你前一个晚上看到的东西几乎被完全遗忘，然后周而复始。</p>

<p>所以，是时候慢下来，你不会因为没有浏览几个网页，或者少读几篇文章而落后于时代几十年的，你需要好多年才能积累起来的知识，别人同样需要好多年。</p>

<p><img src="http://abruzzi.github.com/images/2013/01/todos.png" alt="image" /></p>

<p>合上电脑，捧起纸质的书籍，世界突然慢了下来，但是却会充盈很多。事实上，放慢脚步，消除网络带来的<strong><em>虚假的紧迫感</em></strong>，反而可以以更快的速度掌握一项技术，一个框架，也可以让印象更加深刻。晚上回家尽量不带电脑，我用trainng经费购买的10本书，现在才读完2.5本，去年5月买的书还有两本没有读完，这些亏欠都需要在脱离电脑的舒服之后才能想起来，也才有可能完成。</p>

<p>慢下来。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用opencv进行数字识别]]></title>
    <link href="http://abruzzi.github.com/2013/01/basic-digits-recognization/"/>
    <updated>2013-01-05T22:51:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/01/basic-digits-recognization</id>
    <content type="html"><![CDATA[<p>最终的效果图是这样的：</p>

<p><img src="http://abruzzi.github.com/images/2013/01/result.resized.png" alt="识别效果" /></p>

<p>图中的一个小的窗口中为resize之后的所有找到的图片的列表，在这个case中，有三个数字。</p>

<p>数字识别即将图片中的数字通过计算机算法识别为文本。如果要从头写一个识别器，可能需要很多的实践，花费很大的精力，而且还需要有良好的数学功底才能完成，不过使用opencv提供的丰富的API和算法实现，可以比较容易的做到，而且也可以得到比较高的精确率。</p>

<p>数字识别是模式识别中的一个特例，我这里要讨论的是一个比较简单的实现，基于最简单也最容易理解的KNN算法(请参看<a href="http://icodeit.org/blog/2013/01/k-nearest-neighbour/">之前的一篇文章</a>)。</p>

<p>数字识别和其他的所有计算机视觉相关的应用都会分为两个步骤：ROI抽取和识别。</p>

<pre><code>1. ROI抽取即将感兴趣的区域从原始图像中分离初来，这个步骤包括二值化，噪点的消除等
2. 识别即通过一些分类器将第一步中的结果进行分类，事实上属于机器学习的一个典型应用
</code></pre>

<h3>图像预处理</h3>

<p>原始图片中会有大量与目标无关的信息，比如人脸检测中，背景中往往有诸如桌椅，墙壁上的画，或者在户外的树木，动物等等，这些与目标无关的信息被称为噪音或者噪点，应该在进行分类之前通过一些特定的步骤来消除，不但可以减少计算量，而且还可以提高准确率。</p>

<p><img src="http://abruzzi.github.com/images/2013/01/865.origin.png" alt="原始图片" /></p>

<h4>灰度图</h4>

<p>通常的彩色图形由3个(RGB)或者4个(RGBA)通道组成，在计算机看来，一个彩色的图片是由3/4个矩阵组成，每个矩阵中包含若干个点(比如1024x768)，如果每个通道都参与运算的话，会引入太多的计算量，因此通常的做法是将彩色图像转换为灰度图，在opencv中，这一步非常容易：</p>

<p>```
def grayify(image):</p>

<pre><code>return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
</code></pre>

<p>```</p>

<h4>二值图</h4>

<p>灰度图较之原始图片，将三个维度的矩阵变成了一个维度，已经做了部分简化，但是算法来说，噪音并未消除，灰度图中，每个点仍然有8位来表示，每个点可能的灰度为0-255，二值图即将灰度图转换成黑白图，每个点只有两种可能：非黑即白，这样将大大简化计算。</p>

<p>opencv提供了阈值调节的API，可以将灰度图转换为二值图：高于某一个阈值的点被认为是白色，反之为黑色：</p>

<p>```
def thresholding_inv(image):</p>

<pre><code>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

ret, bin = cv2.threshold(gray, 48, 255, cv.CV_THRESH_BINARY_INV)
bin = cv2.medianBlur(bin, 3)

return bin
</code></pre>

<p>```
上面的代码中，48即为阈值，如果灰度高于48，那么改点会被认为是255，否则为0。效果如下：
<img src="http://abruzzi.github.com/images/2013/01/865.thres.png" alt="二值图" /></p>

<p>由于轮廓检测算法需要从黑色的背景中搜索白色的轮廓，所有此处的<code>threshold</code>最后一项参数为<code>cv.CV_THRESH_BINARY_INV</code>，即反转黑白色。</p>

<h4>轮廓检测</h4>

<p>轮廓检测会将二值图中的可以连通的区域(一个多边形)用一系列的点描述，默认的轮廓检查会返回一个点的序列，比如用四个点描述一个矩形，但是可以通过设置精度来返回更多的点，这里我们只需要返回矩形即可：</p>

<p><img src="http://abruzzi.github.com/images/2013/01/865.contours.png" alt="轮廓检查" /></p>

<p>比较有意思的是这里的数字8，由于8这个形状中有两个圆圈，默认的轮廓检查会将这两个圆圈都检测到，那么8就会有三个轮廓，同样还可能出现这种情况的还有数字4,6,9。</p>

<p><code>
contours, heirs = cv2.findContours(thres.copy(), \
cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)
</code></p>

<p>因此需要指定<code>findContours</code>函数仅搜索最外层的轮廓，而不关注内部可能出现的任何轮廓：</p>

<p><code>
contours, heirs = cv2.findContours(thres.copy(), \
cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
</code></p>

<h3>KNN分类算法</h3>

<p>KNN算法的原理可以参看之前的<a href="http://icodeit.org/blog/2013/01/k-nearest-neighbour/">一篇文章</a>。这里的实现主要参考了opencv的示例程序:</p>

<p>```
class KNearest(StatModel):</p>

<pre><code>def __init__(self, k = 3):
    self.k = k
    self.model = cv2.KNearest()

def train(self, samples, responses):
    self.model = cv2.KNearest()
    self.model.train(samples, responses)

def predict(self, samples):
    retval, results, neigh_resp, dists = \
    self.model.find_nearest(samples, self.k)
    return results.ravel()
</code></pre>

<p>```</p>

<h4>数字的顺序</h4>

<p>另外一个有意思的事情是轮廓检测的时候，算法并不一定按照从左到右，从上到下的方向进行，我开始只是简单的按照迭代的顺序将结果插入到一个list中，但是这样list中的结果是乱的，下午得到了team中有图像处理背景的<a href="http://muggleyoung.info/">杨眉同学</a>的支持：搜索到轮廓的时候，将此时的position信息与轮廓一起记录下来，然后在搜索完成之后，将整个列表按照x坐标排序(卡上的数字是按照从左向右书写)：</p>

<p>```
class PosImage(object):</p>

<pre><code>def __init__(self, pos, image):
    self.pos = pos
    self.image = image

def get_position(self):
    return self.pos

def get_image(self):
    return self.image
</code></pre>

<p>```</p>

<p>然后在迭代中记录position信息：</p>

<p>```</p>

<pre><code>cropped = gray[y:y+h, x:x+w]
resized = cv2.resize(cropped, (20, 20))
cv2.rectangle(image, (x, y), (x+w, y+h), (0, 255, 0), 3)
pos_image = PosImage((x, y), resized)
images.append(pos_image)
</code></pre>

<p>```</p>

<p>最后做一次新的arrange：</p>

<p>```
def rearrange(images):</p>

<pre><code>return sorted(images, cmp=lambda x, y:
cmp(x.get_position()[0], y.get_position()[0]))
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
