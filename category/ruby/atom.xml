<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | I code it]]></title>
  <link href="http://abruzzi.github.com/category/ruby/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2013-10-08T15:18:35+05:30</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Grape快速开发API]]></title>
    <link href="http://abruzzi.github.com/2013/08/quick-api-development-by-grape/"/>
    <updated>2013-08-04T10:29:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/08/quick-api-development-by-grape</id>
    <content type="html"><![CDATA[<h3>Grape简介</h3>

<p><a href="http://intridea.github.io/grape">Grape</a>是一个基于Rack的非常轻量级的框架，用于快速的开发API。一般来说，Rails对于单独的API来说，太过于重量级；而Sinatra虽然足够小巧，但是又没有为开发API提供足够的默认支持（如果从可控制性，灵活性上来说，Sinatra可能更好一些，但是如果有专门的更好用的工具，为什么不用呢？）。</p>

<p>安装非常简便：</p>

<p><code>
$ gem install grape
</code></p>

<p>或者使用在自己的Gemfile中，与其他的gem一起搭建API:</p>

<p><code>
gem 'grape'
</code></p>

<h3>为既有系统添加API</h3>

<h4>简单一试</h4>

<p>之前的一篇介绍<a href="http://icodeit.org/2013/05/using-active-record-as-a-standalone-orm/">ActiveRecord在既有系统中使用</a>的文章中，我使用ActiveRecord为既有的数据库visitor中的三个表(visitor, listGroup, listGroupItem)建立了ruby对应的模型。现在我们可以为这些模型包装一组API，以方便客户端（消费者）可以通过web来访问。</p>

<p>```
module MySys</p>

<pre><code>class API &lt; Grape::API
    format :json

    resource :visitors do

        desc "get all visitor information"
        get do
            Visitor.limit(20)
        end

    end
end
</code></pre>

<p>end
```</p>

<p>首先，MySys::API扩展了Grape::API。<code>format</code>定义我们的API会产生JSON格式的输出，resource定义了这一组API是为资源visitors提供的，因此访问API的url为：</p>

<p><code>
http://localhost:9292/visitors/
</code></p>

<p>当然，grape提供一个很方便的设置prefix，可以使得API的路径更有意义:</p>

<p><code>
format :json
prefix "mysys"
</code></p>

<p>url则相应地变为:</p>

<p><code>
http://localhost:9292/mysys/visitors/
</code></p>

<h4>处理参数</h4>

<p>在对参数的处理上，grape也非常灵活，比如接上例，我们想要获取某一个具体的用户的信息：</p>

<p><code>
http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001
</code></p>

<p>我们可以添加一个新的endpoint：</p>

<p>```
desc "return a visitor"
params do</p>

<pre><code>requires :visitor_uid, :type =&gt; String, :desc =&gt; "visitor id"
</code></pre>

<p>end
route_param :visitor_uid do</p>

<pre><code>get do
    Visitor.find(params[:visitor_uid])
end
</code></pre>

<p>end
```</p>

<p>params中要求，需要一个类型为String的参数visitor_uid。然后在handler中，通过params来引用这个参数的值。</p>

<h4>助手函数(Helper)</h4>

<p>Grape允许开发者将编解码，权限校验等等的通用的操作分离出来，放入助手函数，这些Helper可以被所有的API使用:</p>

<p>```
helpers do</p>

<pre><code>def generate_default_visitor(email, site) 
    {
        :visitor_uid =&gt; SecureRandom.hex,
        :password_expiration =&gt; (Time.now + 60 * 60 * 24),
        :last_used_timestamp =&gt; (Time.now - 60 * 60 * 24),
        :visitor_login_id =&gt; email,
        :site_name =&gt; site
    }
end
</code></pre>

<p>end
```</p>

<p>使用上边定义的助手函数<code>generate_default_visitor</code>：</p>

<p>```
desc "create a visitor"
params do</p>

<pre><code>requires :email, :type =&gt; String, :desc =&gt; "Email address"
requires :site, :type =&gt; String, :desc =&gt; "Site"
</code></pre>

<p>end
post do</p>

<pre><code>attr = generate_default_visitor(params[:email], params[:site])
visitor = Visitor.new attr
visitor.visitor_uid = attr[:visitor_uid]
visitor.save
</code></pre>

<p>end
```</p>

<h3>对API进行测试</h3>

<p>通过Web测试API有非常多的方式，比如通过浏览器的插件(POSTMan)，RSpec，但是我最喜欢，也是最轻便的方式是通过命令行工具curl：</p>

<p><code>
curl http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001
</code></p>

<p>或者：</p>

<p><code>
curl -H "Content-Type: application/json" -X POST -d "{\"email\":\"jtqiu@tw.com\", \"site\":\"mysys\"}" http://localhost:9292/visitors/
</code></p>

<p>命令行的程序curl是一个非常灵活，强大的工具，可以定制HTTP头信息，User Agent，支持所有的HTTP动词，最重要的是，在命令行很容易将工具们组合在一起，并完成自动化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rack it up]]></title>
    <link href="http://abruzzi.github.com/2013/08/rack-it-up/"/>
    <updated>2013-08-02T07:38:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/08/rack-it-up</id>
    <content type="html"><![CDATA[<h3>Rack it up (proc)</h3>

<p>一个最简单的rack应用程序可以是：一个简单的ruby对象，包含了一个call方法。这个call方法接受一个参数，并返回一个有三个元素的数组即可：</p>

<p>```
def call(env)</p>

<pre><code>[200, {}, ["content"]]
</code></pre>

<p>end
```</p>

<p>其中参数env将被rack用作HTTP请求对象来传递进来，而函数的返回值与HTTP响应对应：分别为状态码，HTTP头信息以及响应内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alfred简介及Alfred扩展编写]]></title>
    <link href="http://abruzzi.github.com/2013/05/create-a-alfred-extension-for-create-sinatra-project/"/>
    <updated>2013-05-18T20:04:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/create-a-alfred-extension-for-create-sinatra-project</id>
    <content type="html"><![CDATA[<h3>Alfred简介</h3>

<p><a href="http://www.alfredapp.com/">Alfred</a>是Mac下的一个小工具，可以极大的提高使用计算机的效率。Alfred提供非常丰富的功能集，比如：</p>

<ol>
<li>基本的文件/目录查找功能</li>
<li>应用程序加载器</li>
<li>快速的搜索（google，wikipedia）</li>
</ol>


<p><img src="http://abruzzi.github.com/images/2013/05/alfred-find.png" alt="使用Alfred搜索" /></p>

<h4>powerpack</h4>

<p>Alfred本身是免费的，但是一些高级的功能，如：</p>

<ol>
<li>自定义扩展（<strong>非常有用</strong>）</li>
<li>剪贴板栈/代码片段管理（<strong>非常有用</strong>）</li>
<li>iTunes控制</li>
<li>近期访过的文档</li>
</ol>


<p>提供在<a href="http://www.alfredapp.com/powerpack/">powerpack</a>中，这个功能是要收费的，不过个人觉得绝对的物超所值。这些功能可以极大的提高我对计算机的使用效率，而且剪贴板栈功能可以节省我很多的时间。</p>

<p><img src="http://abruzzi.github.com/images/2013/05/alfred-clipboard.png" alt="image" /></p>

<h3>扩展编写</h3>

<p>经常会使用<a href="http://www.sinatrarb.com/">sinatra</a>编写一些简单的Web应用程序，以用作一些showcase和应用程序的原型搭建。但是由于sinatra并不是一个框架，并不会像rails那样自动生成目录结构等，而每个sinatra应用的目录结构和文件依赖都非常相似，因此完全可以考虑将这个过程自动化。</p>

<p>基本思路是：</p>

<ol>
<li>定义一个目录结构的模板</li>
<li>每次开始一个sinatra工程时，将个模板目录拷贝到新的工程下</li>
<li>一些库依赖的下载（bundle install以及JavaScript库的下载）</li>
<li>在编辑器中打开这个新的目录</li>
</ol>


<h4>一个sinatra工程的原型</h4>

<p>```
$ pwd
/Users/twer/develop/templates/sinatra</p>

<p>$ tree -a
.
├── .rvmrc
├── Gemfile
├── app.rb
├── config.ru
├── public
│   ├── css
│   └── scripts
│       ├── app.js
│       └── libs
└── views
```</p>

<h4>Extension shell script</h4>

<p>```</p>

<h1>create the project folder</h1>

<p>cd ~/develop/ruby &amp;&amp; mkdir -p {query} &amp;&amp; cd {query}</p>

<h1>cp info to folder</h1>

<p>cp -R ~/develop/templates/sinatra/ .</p>

<h1>grab jquery</h1>

<p>curl http://code.jquery.com/jquery.js > public/scripts/libs/jquery.js</p>

<h1>open the project</h1>

<p>/Applications/MacVim.app/Contents/MacOS/Vim -g .
```</p>

<p><img src="http://abruzzi.github.com/images/2013/05/sinatra-ext-result.png" alt="image" /></p>

<p>执行完之后，<code>~/develop/ruby</code>下会生成一个新的目录，即<code>note</code>，这个目录中即为一个可以直接开始开发sinatra应用的工作目录了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在既有数据库中使用ActiveRecord]]></title>
    <link href="http://abruzzi.github.com/2013/05/using-active-record-as-a-standalone-orm/"/>
    <updated>2013-05-18T14:56:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/using-active-record-as-a-standalone-orm</id>
    <content type="html"><![CDATA[<h3>ActiveRecord</h3>

<p>作为rails中的ORM(object relation-db mapping)框架，ActiveRecord在初次出现之时带给了人们以无限的惊喜和热情，也使得很多不堪忍受其他语言中粗糙的ORM框架的开发者转而投入rials的怀抱。而有很多的其他语言也在不断尝试模仿ActiveRecord，比如著名的php框架<a href="http://codeigniter.org.cn/">codeigniter</a>。</p>

<p>在rails的后期版本中，ActiveRecord可以作为一个独立的库来在rails之外使用，这对使用ruby进行其他数据库应用开发的用户来说非常方便。</p>

<h4>在新的项目中使用ActiveRecord</h4>

<p>如果在一个全新的rails应用程序中使用ActiveRecord，那么关于数据库方面的一切都可以托管给它，开发者在初期可能连一行代码都不需要编写就可以让程序“像模像样”的运行起来。</p>

<h4>在已有的数据库上使用ActiveRecord</h4>

<p>现实世界中，最可能遇到的问题是数据库已经存在了（毕竟，对于关系型数据库而言，修改schema的影响太大）。这时候，我们仍然可以使用ActiveRecord来方便的访问数据库，得到ruby对象，而跳过冗长且容易出错的数据库访问层。</p>

<h3>一个例子</h3>

<h4>数据库结构</h4>

<p>数据库中有一个访客表(visitor)：</p>

<p><code>
+-----------------------+--------------+-----+
| Field                 | Type         | Key |
+-----------------------+--------------+-----+
| visitor_uid           | varchar(32)  | PRI |
| visitor_login_id      | varchar(128) | MUL |
| visitor_password      | varchar(32)  |     |
| visitor_name          | varchar(100) |     |
| created_timestamp     | timestamp    |     |
| password_expiration   | timestamp    |     |
| last_used_timestamp   | timestamp    | MUL |
| visitor_alias         | varchar(128) | MUL |
| visitor_password_hash | binary(64)   |     |
+-----------------------+--------------+-----+
</code></p>

<p>有一个访客浏览过的<code>分组</code>表(list_group)：</p>

<p><code>
+------------------+---------------------+-----+
| Field            | Type                | Key |
+------------------+---------------------+-----+
| list_group_id    | bigint(20) unsigned | PRI |
| list_type        | varchar(32)         | MUL |
| visitor_uid      | varchar(32)         | MUL |
| list_name        | varchar(128)        |     |
| create_timestamp | timestamp           |     |
+------------------+---------------------+-----+
</code></p>

<p>每个<code>分组</code>中，都有一些条目，具体到每个条目(list_group_item)：</p>

<p><code>
+----------------------+---------------------+-----+
| Field                | Type                | Key |
+----------------------+---------------------+-----+
| list_group_item_id   | bigint(20) unsigned | PRI |
| list_group_id        | bigint(20) unsigned | MUL |
| item_id              | varchar(128)        | MUL |
| create_timestamp     | timestamp           |     |
| last_use_timestamp   | timestamp           |     |
| note                 | varchar(4000)       |     |
+----------------------+---------------------+-----+
</code></p>

<p>三张表的关系如下：</p>

<p><img src="http://abruzzi.github.com/images/2013/05/active_record.png" alt="image" /></p>

<h4>示例程序的目录结构</h4>

<p>```
├── Gemfile
├── Gemfile.lock
├── app.rb
├── config
│   └── database.yml
├── debug.log
└── model</p>

<pre><code>├── list_group.rb
├── list_group_item.rb
└── visitor.rb
</code></pre>

<p>```</p>

<h4>models</h4>

<p>使用ActiveRecord，只需要简单的在模块上声明模块见的关系即可：</p>

<p>visitor类的定义，读起来非常自然：</p>

<p>```
require 'active_record'</p>

<p>class Visitor &lt; ActiveRecord::Base</p>

<pre><code>has_many :groups, 
    :class_name =&gt; 'ListGroup', 
    :foreign_key =&gt; 'visitor_uid'

self.table_name  = 'visitor'
self.primary_key = 'visitor_uid'
</code></pre>

<p>end
```</p>

<p>ListGroup类的定义：</p>

<p>```
class ListGroup &lt; ActiveRecord::Base</p>

<pre><code>self.table_name  = 'list_group'
self.primary_key  = 'list_group_id'

has_many :items, 
    :class_name =&gt; 'ListGroupItem', 
    :foreign_key =&gt; 'list_group_id'

belongs_to :visitor, 
    :class_name =&gt; 'Visitor', 
    :foreign_key =&gt; 'visitor_uid'
</code></pre>

<p>end
```</p>

<p>最后是ListGroupItem的定义：</p>

<p>```
class ListGroupItem &lt; ActiveRecord::Base</p>

<pre><code>self.table_name = 'list_group_item'
self.primary_key = 'list_group_item_id'

belongs_to :list_group, 
    :class_name =&gt; 'ListGroup', :foreign_key =&gt; 'list_group_id'
</code></pre>

<p>end
```</p>

<p>这种比较复杂的层级关系在现实中经常见到，而大部分HelloWorld型的介绍又touch不到，因此就将代码全部列于此处，以便索引。</p>

<h4>使用这些model</h4>

<p>```
def main</p>

<pre><code>attr = visitor_attr('juntao.qiu#thoughtworks.com')
visitor = Visitor.new attr
visitor.visitor_uid = attr[:visitor_uid]
visitor.save

visitors = Visitor.find(:all)
visitors.each do |visitor|
    p visitor[:visitor_login_id]
end
</code></pre>

<p>end
```
这里即可任意的使用诸如new/save,find等ActiveRecord为我们包装起来的方法了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[proc in ruby]]></title>
    <link href="http://abruzzi.github.com/2013/05/proc-in-ruby/"/>
    <updated>2013-05-12T16:01:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/proc-in-ruby</id>
    <content type="html"><![CDATA[<h2>block in ruby</h2>

<p>block在ruby中，相当于JavaScript中的匿名函数，可以用来实现诸如高阶函数等。高阶函数最好用的一个特点就是它很好的将“动作”（action）本身抽象成了一个对象来传递。</p>

<p>block本身不是对象，但是可以被转换成Proc类的实例，然后以一种特别的方式执行。</p>

<p>```</p>

<blockquote><p>proc = lambda {puts "hello, world"}
 => #&lt;Proc:0x007ff11284d068@(irb):8 (lambda)>
```</p></blockquote>

<p>或者</p>

<p>```</p>

<blockquote><p>proc = lambda do
  puts "hello, world"
end
```</p></blockquote>

<p>从irb打印的信息可以看出，<code>&lt;Proc:0x007ff11284d068@(irb):8 (lambda)&gt;</code>是一个Proc类的实例用lambda生成的block对象，看起来像一个ruby中定义的函数/方法一样，但是执行的时候需要特别的调用方式：</p>

<p>```</p>

<blockquote><p>proc.call
hello, world
 => nil
```</p></blockquote>

<p>如果需要参数，可以这样指定：</p>

<p>```</p>

<blockquote><p>proc = lambda {|a, b| a + b}
 => #&lt;Proc:0x007ff114843d40@(irb):14 (lambda)>
proc.call(1,2)
 => 3
proc.call("hello, ","world")
 => "hello, world"
```</p></blockquote>

<h2>proc自身</h2>

<p>ruby中大名鼎鼎的rack应用程序，本质上就只是负责调用一个block来获得结果：</p>

<p><code>
rack_proc = lambda {|env| [200, {}, ["&lt;h1&gt;Hello, world&lt;/h1&gt;"]]}
rack_proc.call({})
</code></p>

<p>也可以使用proc来创建一个Proc：</p>

<p>```</p>

<blockquote><p>x = proc {puts "hello, world"}
 => #&lt;Proc:0x007ff114851698@(irb):18>
x.call
hello, world
 => nil
```</p></blockquote>

<p>也可以将proc实例返回出来，然后提供给其他函数使用，需要注意的是那个call方法：</p>

<p>```
def adder(number)</p>

<pre><code>proc {|x| x + number}
</code></pre>

<p>end</p>

<p>add15 = adder(15)
add15.call(10) == 25</p>

<p>add10 = adder(10)
add10.call(10) == 20
```</p>
]]></content>
  </entry>
  
</feed>
