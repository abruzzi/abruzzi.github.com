<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: command line | I code it]]></title>
  <link href="http://abruzzi.github.com/category/command-line/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2017-01-18T01:36:00+11:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用inotify/fswatch构建自动监控脚本]]></title>
    <link href="http://abruzzi.github.com/2015/03/build-monitor-script-based-on-inotify/"/>
    <updated>2015-03-01T14:12:00+11:00</updated>
    <id>http://abruzzi.github.com/2015/03/build-monitor-script-based-on-inotify</id>
    <content type="html"><![CDATA[<h2>自动告警脚本</h2>

<p>最近项目上有这样一个需求：系统中有一个后台服务会不断的生成监控日志，根据系统的运行情况，它每天会在目录<code>/var/alarms</code>下生成一个文件，文件名带有时间戳，其中内容格式如下：</p>

<p><code>sh
$ cat /var/alarms/alarms-20150228130522.csv
node,summary,occurrence,proiority
VIQ002,heartbeat failure,2/12/2015 01:23 AM,critical
VIQ002,packages are rejected,2/12/2015 01:22 AM,major
VIQ002,connection cannot be established,2/11/2015 01:23 AM,medium
VIQ001,packages are rejected,2/11/2015 01:23 AM,warning
VIQ001,connection cannot be established,2/09/2015 01:23 AM,medium
...
</code></p>

<p>运维团队需要监控这个目录，如果里边的文件发生了变化，就要及时的发送邮件给工程团队解决。我们当然不可能人工的监控该目录，然后编写邮件，再拷贝粘贴，所以需要编写一个脚本来自动化这个任务。</p>

<p>处理方法有两种：</p>

<ol>
<li>编写一个crontab的任务，每隔五分钟轮询一下，然后编写脚本来探测变化，发送邮件</li>
<li>使用操作系统提供的<code>inotify</code>相关API探测变化，编写脚本发送邮件</li>
</ol>


<p>不过作为程序员，第二种方法显然更高级一些。另外相对于检测文件变化（对比目录树，检查时间戳，而且还要记录上一次变更的状态等），编写一个发送邮件的脚本要简单得多。</p>

<h3>使用inotify</h3>

<p>如果在<code>Linux</code>下，我们可以使用<code>inotify</code>相关的工具，你可以使用你正在使用的系统下的包管理工具来安装。也可以直接从源码包编译安装。</p>

<p>安装之后，系统中就有了一个叫做<code>inotifywait</code>的命令，这个命令提供多个参数。默认的<code>inotifywait</code>在接收到指定的事件（文件变化）后，会打印信息并退出。可以使用<code>-m</code>参数让<code>inotifywati</code>处于监听状态。<code>-e</code>参数指定需要监听的事件类型，下面是几个常见的事件类型：</p>

<ol>
<li><code>CREATE</code>，创建</li>
<li><code>MODIFY</code>，修改</li>
<li><code>CLOSE_WRITE,CLOSE</code>，写入成功</li>
</ol>


<p>还可以通过<code>--format</code>来指定事件的输出，<code>%w</code>表示监控的文件名，<code>%f</code>表示如果被监控的对象是目录，则当发生事件时返回文件名。比如下面的命令：</p>

<p><code>sh
$ inotifywait -m -e close_write /var/alarms --format "%w%f"
</code></p>

<p>表示以监控模式（事件发生后不退出，继续监听），监听<code>close_write</code>事件，在<code>/var/alarms</code>目录上，并且输出的格式为<code>%w%f</code>。</p>

<p>这样我们在另一个窗口上模拟事件发生：</p>

<p><code>sh
$ touch /var/alarms/alarms-20150228130522.csv
</code></p>

<p>当前的窗口就会出现<code>/var/alarms/alarms-20150228130522.csv</code>这样的输出。有了这个功能，我们只需要编写一段简单的脚本就可以完成上一小节中的问题了：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>DIR=$1</p>

<p>inotifywait -m -e close_write $DIR --format "%w%f" | while read FILE
do</p>

<pre><code>cat ${FILE} | mail -s "Alarm: $FILE" juntao.qiu@gmail.com
</code></pre>

<p>done
```</p>

<p>命令<code>mail</code>是Linux下默认的邮件客户端，可以完成邮件的发送功能。将上边的脚本命名为<code>monitor.sh</code>，添加可执行权限，并启动监控：</p>

<p><code>sh
$ chmod +x monitor.sh
$ ./monitor.sh /var/alarms
</code></p>

<p>这样，当目标目录<code>/var/alarms</code>发生变化后，我们就可以收到告警邮件了！</p>

<h3>Mac OSX下使用fswatch</h3>

<p>如果是在<code>Mac OSX</code>下，虽然没有了<code>inotify</code>相关的API，但是我们可以使用<code>fswatch</code>来完成同样的工作。</p>

<p>使用<code>brew</code>安装<code>fswatch</code>：</p>

<p><code>sh
$ brew install fswatch
</code></p>

<p>即可。<code>fswatch</code>也有很多选项，我们这里仅使用<code>-0</code>（表示以传统的NUL作为字符串终结符，因为*nix下文件名可以包含任意字符，比如空格）。我们可以很容易的用<code>xargs</code>将检测到的事件进行进一步的处理：</p>

<p><code>sh
fswatch -0 /var/alarms | xargs -0 -n 1 ~/bin/send-notify.sh
</code></p>

<p>其中，<code>-0</code>的意思与<code>fswatch</code>的命令中的<code>-0</code>一致，<code>-n 1</code>表示每条<code>NUL</code>结尾的字符串都执行一次脚本。脚本<code>send-notify.sh</code>的内容如下：</p>

<p>```sh</p>

<h1>!/bin/bash</h1>

<p>FILE=$1
cat $FILE | mail -s "Alarm: $FILE" jutao.qiu@gmail.com
```</p>

<p>这样，当文件发生变化时，脚本就会发送一封邮件到指定邮箱了（由于我自己的laptop的hostname不像是一个合理的主机名，所以Gmail会把这封邮件放到垃圾邮件列表中，这里只是用作示例而已）。</p>

<p><img src="/images/2015/03/mail-resized.png" alt="fswatch" /></p>

<p>当然，由于脚本是我们自己可以编写的，所以理论上当检测到变化之后，我们可以做任何事情，比如<a href="http://icodeit.org/2014/09/simple-idea-and-simple-script/">说几句话</a>，播放一段音乐等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[制作一个更漂亮的svn diff命令]]></title>
    <link href="http://abruzzi.github.com/2015/02/make-a-colorful-svn-diff/"/>
    <updated>2015-02-18T14:14:00+11:00</updated>
    <id>http://abruzzi.github.com/2015/02/make-a-colorful-svn-diff</id>
    <content type="html"><![CDATA[<h3>Code Review</h3>

<p>在<code>ThoughtWorks</code>，我们几乎每天都会进行一个叫<code>code review</code>或者<code>code diff</code>的活动：每天下午5:00，团队成员围坐在一起，将今天的修改大概过一下，这样做的好处非常明显：</p>

<ol>
<li>分享业务知识，了解彼此的工作</li>
<li>分享技术细节，比如有人使用了某种设计模式</li>
<li>帮助别人发现问题，比如逻辑错误等，群策群力</li>
</ol>


<p>经过实践，<code>code reivew</code>可以快速发现问题，而且可以尽可能多的分享知识，是一种<code>ThoughtWorker</code>们喜闻乐见的学习/娱乐形式。</p>

<p>但是随着项目的不同，各个团队使用的版本管理工具都不一样。用惯了<code>git</code>的非常漂亮的<code>diff</code>子命令之后，<code>svn</code>的<code>diff</code>简直就是战五渣。没有高亮，没有进度条，就是黑底白字的一些文本，实在无法让人提起兴趣。</p>

<p>这篇文章分享一个简单的方法，可以让你很容易的把<code>svn</code>的<code>diff</code>打造成一个漂亮的工具：</p>

<p><img src="/images/2015/02/svn-color-diff-resized.png" alt="svn diff" /></p>

<h4>diff格式</h4>

<p>Diff是一种通用的表示文本差异的格式，细节可以看我之前写过一篇<a href="http://icodeit.org/2012/02/diff%E5%92%8Cpatch%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">关于diff和patch的文章</a>。需要说明的是，它作为一种标准格式，很多编辑器都提供对这种格式的高亮显示，比如现在非常流行的<code>Sublime Text</code>编辑器：</p>

<p><img src="/images/2015/02/sublime-diff-resized.png" alt="sublime diff" /></p>

<p>默认的，<code>svn</code>的diff命令会生成这样<strong>朴素</strong>的输出：</p>

<p><img src="/images/2015/02/svn-diff-resized.png" alt="svn diff" /></p>

<h4>命令行的diff高亮显示</h4>

<p>在Mac下，可以通过<code>brew</code>来安装一个命令行工具，这个工具可以将<code>Diff</code>格式高亮显示：</p>

<p><code>sh
$ brew install colordiff
</code></p>

<p>有了这个工具，就可以将<code>svn</code>生成的<code>Diff</code>格式高亮显示出来：</p>

<p><code>sh
$ svn diff | colordiff
</code></p>

<p><img src="/images/2015/02/color-diff-resized.png" alt="color diff" /></p>

<p>但是你可能已经发现这些神奇的<code>^M</code>，这是<code>Windows</code>系统中的换行符在<code>Unix</code>类系统中的展示，我们需要将<code>Diff</code>先转换一次：</p>

<p><code>sh
$ svn diff | dos2unix | colordiff
</code></p>

<p><img src="/images/2015/02/color-diff-converted-resized.png" alt="color diff converted" /></p>

<p>如果你的系统中没有<code>dos2unix</code>，可以用<code>brew</code>来安装：</p>

<p><code>sh
$ brew install dos2unix unix2dos
</code></p>

<h4>分页器</h4>

<p>*nix系统下有两种分页器：<code>more</code>和<code>less</code>，<code>less</code>比<code>more</code>的功能更丰富。<code>less</code>有很多的参数，我们这里选用了3个常见的：</p>

<ol>
<li><code>-s</code>: 压缩连续的空白行为一行</li>
<li><code>-M</code>: 给出更多的提示信息，包含行号，百分比等</li>
<li><code>+Gg</code>: 先跳至要查看文件的末尾，再跳至文件开头，这样从less就可以得到整个流的长度，从而计算出正确的百分比。当然如果是单独文件时，less是明确知道文件长度的，但是如果是从流中重定向过来的文本，less无法在开始时就得知长度。</li>
</ol>


<p>下面这条命令可以将当前目录下的所有<code>html</code>文件分屏显示，并且在每一屏的最后一行显示百分比等信息：</p>

<p><code>sh
$ cat *.html | less -s -M +Gg
</code></p>

<h4>放在一起</h4>

<p>好了，我们将每个部分都已经讲解了一遍了，现在让我们将这些零件串起来，在svn的<code>working copy</code>中执行这条命令就可以得到非常漂亮的，分页显示的Diff：</p>

<p><code>sh
$ svn diff | dos2unix | colordiff | less -s -M +Gg
</code></p>

<p>当然，还可以用一个<code>alias</code>(别名)来节省敲入的字符数：</p>

<p><code>sh
$ alias sd='svn diff | dos2unix | colordiff | less -s -M +Gg'
</code></p>
]]></content>
  </entry>
  
</feed>
