<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: frontend | I code it]]></title>
  <link href="http://abruzzi.github.com/category/frontend/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2017-07-26T16:09:25+08:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[前后端分离了，然后呢？]]></title>
    <link href="http://abruzzi.github.com/2015/06/whats-next-after-separate-frontend-and-backend/"/>
    <updated>2015-06-22T21:29:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/06/whats-next-after-separate-frontend-and-backend</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>前后端分离已经是业界所共识的一种开发/部署模式了。所谓的前后端分离，并<strong>不是</strong>传统行业中的按部门划分，一部分人纯做前端（HTML/CSS/JavaScript/Flex），另一部分人纯做后端，因为这种方式是<strong>不工作</strong>的：比如很多团队采取了后端的模板技术（JSP, FreeMarker, ERB等等），前端的开发和调试需要一个后台Web容器的支持，从而无法做到真正的分离（更不用提在部署的时候，由于动态内容和静态内容混在一起，当设计动态静态分流的时候，处理起来非常麻烦）。关于前后端开发的另一个讨论可以<a href="http://icodeit.org/2015/06/do-we-really-short-for-front-end-developer/">参考这里</a>。</p>

<p>即使通过API来解耦前端和后端开发过程，前后端通过<code>RESTFul</code>的接口来通信，前端的静态内容和后端的动态计算分别开发，分别部署，<strong>集成</strong>仍然是一个绕不开的问题 --- 前端/后端的应用都可以独立的运行，但是集成起来却不工作。我们需要花费大量的精力来调试，直到上线前仍然没有人有信心所有的接口都是工作的。</p>

<h3>一点背景</h3>

<p>一个典型的Web应用的布局看起来是这样的：</p>

<p><img src="/images/2015/06/single-backend-resized.png" alt="typical web application" /></p>

<p>前后端都各自有自己的开发流程，构建工具，测试集合等等。前后端仅仅通过接口来编程，这个接口可能是JSON格式的RESTFul的接口，也可能是XML的，重点是后台只负责数据的提供和计算，而完全不处理展现。而前端则负责拿到数据，组织数据并展现的工作。这样结构清晰，关注点分离，前后端会变得相对独立并松耦合。</p>

<p>上述的场景还是比较理想，我们事实上在实际环境中会有非常复杂的场景，比如异构的网络，异构的操作系统等等:</p>

<p><img src="/images/2015/06/multiple-backend-resized.png" alt="real word application" /></p>

<p>在实际的场景中，后端可能还会更复杂，比如用C语言做数据采集，然后通过Java整合到一个数据仓库，然后该数据仓库又有一层Web Service，最后若干个这样的Web Service又被一个Ruby的聚合Service整合在一起返回给前端。在这样一个复杂的系统中，后台任意端点的失败都可能阻塞前端的开发流程，因此我们会采用mock的方式来解决这个问题：</p>

<p><img src="/images/2015/06/mock-server-resized.png" alt="mock application" /></p>

<p>这个<code>mock</code>服务器可以启动一个简单的HTTP服务器，然后将一些静态的内容serve出来，以供前端代码使用。这样的好处很多:</p>

<ol>
<li>前后端开发相对独立</li>
<li>后端的进度不会影响前端开发</li>
<li>启动速度更快</li>
<li>前后端都可以使用自己熟悉的技术栈（让前端的学maven，让后端的用gulp都会很不顺手）</li>
</ol>


<p>但是当<strong>集成</strong>依然是一个令人头疼的难题。我们往往在集成的时候才发现，本来协商的数据结构变了：<code>deliveryAddress</code>字段本来是一个字符串，现在变成数组了（业务发生了变更，系统现在可以支持多个快递地址）；<code>price</code>字段变成字符串，协商的时候是<code>number</code>；用户邮箱地址多了一个层级等等。这些变动在所难免，而且时有发生，这会花费大量的调试时间和集成时间，更别提修改之后的回归测试了。</p>

<p>所以仅仅使用一个静态服务器，然后提供<code>mock</code>数据是远远不够的。我们需要的<code>mock</code>应该还能做到：</p>

<ol>
<li>前端依赖指定格式的mock数据来进行UI开发</li>
<li>前端的开发和<strong>测试</strong>都基于这些mock数据</li>
<li>后端产生指定格式的mock数据</li>
<li>后端需要测试来确保生成的mock数据正是前端需要的</li>
</ol>


<p>简而言之，我们需要商定一些契约，并将这些契约作为<strong>可以被测试</strong>的中间格式。然后前后端都需要有测试来使用这些契约。一旦契约发生变化，则另一方的测试会失败，这样就会驱动双方协商，并降低集成时的浪费。</p>

<p>一个实际的场景是：前端发现已有的某个契约中，缺少了一个<code>address</code>的字段，于是就在契约中添加了该字段。然后在UI上将这个字段正确的展现了（当然还设置了字体，字号，颜色等等）。但是后台生成该契约的服务并没有感知到这一变化，当运行生成契约部分测试（后台）时，测试会失败了 --- 因为它并没有生成这个字段。于是后端工程师就找前端来商量，了解业务逻辑之后，他会修改代码，并保证测试通过。这样，当集成的时候，就不会出现UI上少了一个字段，但是谁也不知道是前端问题，后端问题，还是数据库问题等。</p>

<p>而且实际的项目中，往往都是多个页面，多个API，多个版本，多个团队同时进行开发，这样的契约会降低非常多的调试时间，使得集成相对平滑。</p>

<p>在实践中，契约可以定义为一个JSON文件，或者一个XML的payload。只需要保证前后端<strong>共享同一个契约集合</strong>来做测试，那么集成工作就会从中受益。一个最简单的形式是：提供一些静态的<code>mock</code>文件，而前端所有发往后台的请求都被某种机制拦截，并转换成对该静态资源的请求。</p>

<ol>
<li><a href="https://github.com/dreamhead/moco">moco</a>，基于Java</li>
<li><a href="http://wiremock.org/index.html">wiremock</a>，基于Java</li>
<li><a href="http://www.sinatrarb.com/">sinatra</a>，基于Ruby</li>
</ol>


<p>看到<code>sinatra</code>被列在这里，可能熟悉<code>Ruby</code>的人会反对：它可是一个<code>后端</code>全功能的的程序库啊。之所以列它在这里，是因为<code>sinatra</code>提供了一套简洁优美的<code>DSL</code>，这个<code>DSL</code>非常契合<code>Web</code>语言，我找不到更漂亮的方式来使得这个<code>mock server</code>更加易读，所以就采用了它。</p>

<h3>一个例子</h3>

<p>我们以这个应用为示例，来说明如何在前后端分离之后，保证代码的质量，并降低集成的成本。这个应用场景很简单：所有人都可以看到一个条目列表，每个登陆用户都可以选择自己喜欢的条目，并为之加星。加星之后的条目会保存到用户自己的<code>个人中心</code>中。用户界面看起来是这样的：</p>

<p><img src="/images/2015/06/bookmarks-resized.png" alt="bookmarks" /></p>

<p>不过为了专注在我们的中心上，我去掉了诸如登陆，个人中心之类的页面，假设你是一个已登录用户，然后我们来看看如何编写测试。</p>

<h4>前端开发</h4>

<p>根据通常的做法，前后端分离之后，我们很容易<code>mock</code>一些数据来自己测试：</p>

<p>```json
[</p>

<pre><code>{
    "id": 1,
    "url": "http://abruzzi.github.com/2015/03/list-comprehension-in-python/",
    "title": "Python中的 list comprehension 以及 generator",
    "publicDate": "2015年3月20日"
},
{
    "id": 2,
    "url": "http://abruzzi.github.com/2015/03/build-monitor-script-based-on-inotify/",
    "title": "使用inotify/fswatch构建自动监控脚本",
    "publicDate": "2015年2月1日"
},
{
    "id": 3,
    "url": "http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery/",
    "title": "使用underscore.js构建前端应用",
    "publicDate": "2015年1月20日"
}
</code></pre>

<p>]
```</p>

<p>然后，一个可能的方式是通过请求这个json来测试前台：</p>

<p>```js
$(function() {</p>

<pre><code>$.get('/mocks/feeds.json').then(function(feeds) {
    var feedList = new Backbone.Collection(extended);
    var feedListView = new FeedListView(feedList);

    $('.container').append(feedListView.render());
});
</code></pre>

<p>});
```</p>

<p>这样当然是可以工作的，但是这里发送请求的<code>url</code>并不是最终的，当集成的时候我们又需要修改为真实的<code>url</code>。一个简单的做法是使用<code>Sinatra</code>来做一次url的转换：</p>

<p>```rb
get '/api/feeds' do</p>

<pre><code>content_type 'application/json'
File.open('mocks/feeds.json').read
</code></pre>

<p>end
```</p>

<p>这样，当我们和实际的服务进行集成时，只需要连接到那个服务器就可以了。</p>

<p>注意，我们现在的核心是<code>mocks/feeds.json</code>这个文件。这个文件现在的角色就是一个契约，至少对于前端来说是这样的。紧接着，我们的应用需要渲染<code>加星</code>的功能，这就需要另外一个契约：找出当前用户加星过的所有条目，因此我们加入了一个新的契约：</p>

<p>```json
[</p>

<pre><code>{
    "id": 3,
    "url": "http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery/",
    "title": "使用underscore.js构建前端应用",
    "publicDate": "2015年1月20日"
}
</code></pre>

<p>]
```</p>

<p>然后在<code>sinatra</code>中加入一个新的映射：</p>

<p>```rb
get '/api/fav-feeds/:id' do</p>

<pre><code>content_type 'application/json'
File.open('mocks/fav-feeds.json').read
</code></pre>

<p>end
```</p>

<p>通过这两个请求，我们会得到两个列表，然后根据这两个列表的交集来绘制出所有的星号的状态（有的是空心，有的是实心）：</p>

<p>```js
$.when(feeds, favorite).then(function(feeds, favorite) {</p>

<pre><code>var ids = _.pluck(favorite[0], 'id');
var extended = _.map(feeds[0], function(feed) {
    return _.extend(feed, {status: _.includes(ids, feed.id)});
});

var feedList = new Backbone.Collection(extended);
var feedListView = new FeedListView(feedList);

$('.container').append(feedListView.render());
</code></pre>

<p>});
```</p>

<p>剩下的一个问题是当点击红心时，我们需要发请求给后端，然后更新红心的状态：</p>

<p>```js
toggleFavorite: function(event) {</p>

<pre><code>event.preventDefault();
var that = this;
$.post('/api/feeds/'+this.model.get('id')).done(function(){
    var status = that.model.get('status');
    that.model.set('status', !status);
});
</code></pre>

<p>}
```</p>

<p>这里又多出来一个请求，不过使用Sinatra我们还是可以很容易的支持它：</p>

<p><code>rb
post '/api/feeds/:id' do
end
</code></p>

<p>可以看到，在没有后端的情况下，我们一切都进展顺利 --- 后端甚至还没有开始做，或者正在由一个进度比我们慢的团队在开发，不过无所谓，他们不会影响我们的。</p>

<p>不仅如此，当我们写完前端的代码之后，可以做一个<code>End2End</code>的测试。由于使用了mock数据，免去了数据库和网络的耗时，这个<code>End2End</code>的测试会运行的非常快，并且它确实起到了端到端的作用。这些测试在最后的集成时，还可以用来当UI测试来运行。所谓一举多得。</p>

<p>```rb</p>

<h1>encoding: utf-8</h1>

<p>require 'spec_helper'</p>

<p>describe 'Feeds List Page' do</p>

<pre><code>let(:list_page) {FeedListPage.new}

before do
    list_page.load
end

it 'user can see a banner and some feeds' do
    expect(list_page).to have_banner
    expect(list_page).to have_feeds
end

it 'user can see 3 feeds in the list' do
    expect(list_page.all_feeds).to have_feed_items count: 3
end

it 'feed has some detail information' do
    first = list_page.all_feeds.feed_items.first
    expect(first.title).to eql("Python中的 list comprehension 以及 generator")
end
</code></pre>

<p>end
```</p>

<p><img src="/images/2015/06/e2e-resized.png" alt="end 2 end" /></p>

<p>关于如何编写这样的测试，可以参考之前写的<a href="http://icodeit.org/2015/01/page-object-with-site-prism/">这篇文章</a>。</p>

<h4>后端开发</h4>

<p>我在这个示例中，后端采用了<code>spring-boot</code>作为示例，你应该可以很容易将类似的思路应用到Ruby或者其他语言上。</p>

<p>首先是请求的入口，<code>FeedsController</code>会负责解析请求路径，查数据库，最后返回JSON格式的数据。</p>

<p>```java
@Controller
@RequestMapping("/api")
public class FeedsController {</p>

<pre><code>@Autowired
private FeedsService feedsService;

@Autowired
private UserService userService;

public void setFeedsService(FeedsService feedsService) {
    this.feedsService = feedsService;
}

public void setUserService(UserService userService) {
    this.userService = userService;
}

@RequestMapping(value="/feeds", method = RequestMethod.GET)
@ResponseBody
public Iterable&lt;Feed&gt; allFeeds() {
    return feedsService.allFeeds();
}


@RequestMapping(value="/fav-feeds/{userId}", method = RequestMethod.GET)
@ResponseBody
public Iterable&lt;Feed&gt; favFeeds(@PathVariable("userId") Long userId) {
    return userService.favoriteFeeds(userId);
}
</code></pre>

<p>}
```</p>

<p>具体查询的细节我们就不做讨论了，感兴趣的可以在文章结尾处找到代码库的链接。那么有了这个Controller之后，我们如何测试它呢？或者说，如何让契约变得实际可用呢？</p>

<p><code>spring-test</code>提供了非常优美的DSL来编写测试，我们仅需要一点代码就可以将契约用起来，并实际的<strong>监督</strong>接口的修改：</p>

<p>```java
private MockMvc mockMvc;
private FeedsService feedsService;
private UserService userService;</p>

<p>@Before
public void setup() {</p>

<pre><code>feedsService = mock(FeedsService.class);
userService = mock(UserService.class);

FeedsController feedsController = new FeedsController();
feedsController.setFeedsService(feedsService);
feedsController.setUserService(userService);

mockMvc = standaloneSetup(feedsController).build();
</code></pre>

<p>}
```</p>

<p>建立了mockmvc之后，我们就可以编写Controller的单元测试了：</p>

<p>```java
@Test
public void shouldResponseWithAllFeeds() throws Exception {</p>

<pre><code>when(feedsService.allFeeds()).thenReturn(Arrays.asList(prepareFeeds()));

mockMvc.perform(get("/api/feeds"))
        .andExpect(status().isOk())
        .andExpect(content().contentType("application/json;charset=UTF-8"))
        .andExpect(jsonPath("$", hasSize(3)))
        .andExpect(jsonPath("$[0].publishDate", is(notNullValue())));
</code></pre>

<p>}
```</p>

<p>当发送<code>GET</code>请求到<code>/api/feeds</code>上之后，我们期望返回状态是200，然后内容是<code>application/json</code>。然后我们预期返回的结果是一个长度为3的数组，然后数组中的第一个元素的<code>publishDate</code>字段不为空。</p>

<p>注意此处的<code>prepareFeeds</code>方法，事实上它会去加载<code>mocks/feeds.json</code>文件 --- 也就是前端用来测试的mock文件：</p>

<p>```java
private Feed[] prepareFeeds() throws IOException {</p>

<pre><code>URL resource = getClass().getResource("/mocks/feeds.json");
ObjectMapper mapper = new ObjectMapper();
return mapper.readValue(resource, Feed[].class);
</code></pre>

<p>}
```</p>

<p>这样，当后端修改<code>Feed</code>定义（添加/删除/修改字段），或者修改了mock数据等，都会导致测试失败；而前端修改mock之后，也会导致测试失败 --- 不要惧怕失败 --- 这样的失败会促进一次协商，并驱动出最终的service的契约。</p>

<p>对应的，测试<code>/api/fav-feeds/{userId}</code>的方式类似：</p>

<p>```java</p>

<p>@Test
public void shouldResponseWithUsersFavoriteFeeds() throws Exception {</p>

<pre><code>when(userService.favoriteFeeds(any(Long.class)))
    .thenReturn(Arrays.asList(prepareFavoriteFeeds()));

mockMvc.perform(get("/api/fav-feeds/1"))
        .andExpect(status().isOk())
        .andExpect(content().contentType("application/json;charset=UTF-8"))
        .andExpect(jsonPath("$", hasSize(1)))
        .andExpect(jsonPath("$[0].title", is("使用underscore.js构建前端应用")))
        .andExpect(jsonPath("$[0].publishDate", is(notNullValue())));
</code></pre>

<p>}
```</p>

<h3>总结</h3>

<p>前后端分离是一件容易的事情，而且团队可能在短期可以看到很多好处，但是如果不认真处理集成的问题，分离反而可能会带来更长的集成时间。通过面向契约的方式来组织各自的测试，可以带来很多的好处：更快速的<code>End2End</code>测试，更平滑的集成，更安全的分离开发等等。</p>

<h3>代码</h3>

<p>前后端的代码我都放到了Gitbub上，感兴趣的可以clone下来自行研究：</p>

<ol>
<li><a href="https://github.com/abruzzi/bookmarks-frontend">bookmarks-frontend</a></li>
<li><a href="https://github.com/abruzzi/bookmarks-server">bookmarks-server</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用underscore.js构建前端应用]]></title>
    <link href="http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery/"/>
    <updated>2015-02-21T21:21:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery</id>
    <content type="html"><![CDATA[<h2>一个监控系统</h2>

<p>我们今天要使用<code>underscore.js</code>和<code>jQuery</code>来构建一个客户端的应用，这个应用是一个监控系统的前端，设计师已经给出了界面设计：</p>

<p><img src="/images/2015/02/alarms-design-resized.png" alt="alarms design" /></p>

<p>而对应的服务器端的API也已经就绪了：</p>

<p><code>sh
$ curl http://localhost:9527/alarms.json -s | jq .
</code></p>

<p>会看到诸如这样的返回值：</p>

<p>```json
[
  {</p>

<pre><code>"proiority": "critical",
"occurrence": "2/12/2015 01:23 AM",
"summary": "heartbeat failure",
"node": "VIQ002"
</code></pre>

<p>  },
  {</p>

<pre><code>"proiority": "major",
"occurrence": "2/12/2015 01:22 AM",
"summary": "packages are rejected",
"node": "VIQ002"
</code></pre>

<p>  },
  {</p>

<pre><code>"proiority": "medium",
"occurrence": "2/11/2015 01:23 AM",
"summary": "connection cannot be established",
"node": "VIQ002"
</code></pre>

<p>  }
]</p>

<p>```</p>

<p>每条告警信息都包含：优先级，发生时间，描述信息，以及发生告警的节点名称。</p>

<p>我们要将这些信息整合，并展示在页面上。</p>

<h3>mockup</h3>

<p>我在<a href="juntao.gitbooks.io/3-web-designs-in-3-weeks/">《3周3页面》</a>中讨论过现代前端开发的方式，你也可以参考<a href="http://icodeit.org/2014/11/modern-ui-development-workflow/">这篇文章</a>以及<a href="http://">这篇文章</a>。我们这里还是采用相同的方式来实现这个<code>mockup</code>，也就是静态页面。</p>

<p>首先我们在<code>index.html</code>中编写HTML：</p>

<p>```html</p>

<div class="container">
    <h1>Active Event List in transmission</h1>
    <ul class="events">
        <li>
            <div class="event critical">
                <h3>heartbeat failure @ VIQ002</h3>
                <span class="date">2/12/2015 01:23 AM</span>
            </div>
        </li>
        <li>
            <div class="event major">
                <h3>packages are rejected</h3>
                <span class="date">2/12/2015 01:23 AM</span>
            </div>
        </li>
        <li>
            <div class="event medium">
                <h3>connection cannot be established</h3>
                <span class="date">2/12/2015 01:23 AM</span>
            </div>
        </li>
        <!-- ... -->
    </ul>

    <ul class="legend">
        <li>
            <div class="count critical">
                <i class="alarm"></i>
                <span>critical: 20</span>
            </div>
        </li>
        <li>
            <div class="count major">
                <i class="alarm"></i>
                <span>major: 13</span>
            </div>
        </li>
        <li>
            <div class="count medium">
                <i class="alarm"></i>
                <span>medium: 20</span>
            </div>
        </li>
        <li>
            <div class="count warning">
                <i class="alarm"></i>
                <span>warning: 30</span>
            </div>
        </li>
        <li>
            <div class="count indeterminate">
                <i class="alarm"></i>
                <span>indeterminate: 6</span>
            </div>
        </li>
    </ul>
</div>


<p>```</p>

<p><code>events</code>中包含了所有告警信息，每一条告警根据等级不同显示了不同的颜色：红色表示严重，橘红表示主要，橘色表示一般等。告警信息包含了一个描述信息，并且包含了一个时间戳，表示告警发生的时间。</p>

<p><code>legend</code>部分是一个图例，其中包含了各个颜色的说明，并且包含了不同级别的告警信息的数目，比如截止目前为止，共有<strong>20</strong>个严重的告警，13个主要告警等。</p>

<p>对应的<code>scss</code>内容如下，首先定义了一些通用的CSS类：</p>

<p>```scss
@import "compass/reset";
@import "compass/css3";</p>

<p>body {</p>

<pre><code>font-size: 62.5%;
font-family: "Open Sans", serif;
text-align: center;
</code></pre>

<p>}</p>

<p>.critical {</p>

<pre><code>background-color: red;
color: white;
</code></pre>

<p>}</p>

<p>.major {</p>

<pre><code>background-color: orangered;
color: white;
</code></pre>

<p>}</p>

<p>.medium {</p>

<pre><code>background-color: orange;
color: white;
</code></pre>

<p>}</p>

<p>.warning {</p>

<pre><code>background-color: #2C75DB;
color: white;
</code></pre>

<p>}</p>

<p>.indeterminate {</p>

<pre><code>background-color: #29D4BA;
color: white;
</code></pre>

<p>}
```</p>

<p>然后定义<code>container</code>中的各个元素的样式：</p>

<p>```scss
.container {</p>

<pre><code>padding: 1em 0;
width: 800px;
margin: 0 auto;

h1 {
    font-size: 3em;
    text-transform: uppercase;
    margin: 1em 0;
}

.event {
    position: relative;

    h3 {
        text-align: left;
        font-size: 1.5em;
        padding: .6em .5em;
        text-transform: capitalize;
    }

    .date {
        position: absolute;
        top: 50%;
        right: 1em;
        font-size: 1em;
        font-style: italic;
        color: #eeeeee;
    }
}

.legend {
    margin: 1em 0;
    li {
        width: 20%;
        float: left;

        .count {
            padding: .6em;
            text-transform: capitalize;
        }
    }
}
</code></pre>

<p>}
```</p>

<h3>应用程序</h3>

<p>首先我们下载<code>underscore.js</code>和<code>jquery.js</code>，并将它们放在当前目录下的<code>scripts/libs</code>下，并在<code>scripts</code>下创建一个<code>app.js</code>文件。</p>

<p>这时候的目录结构如下：</p>

<p>```
├── index.html
├── sass
│   └── style.scss
├── scripts
│   ├── app.js
│   └── libs
│       ├── jquery.min.js
│       └── underscore.js
└── stylesheets</p>

<pre><code>└── style.css
</code></pre>

<p>```</p>

<p>然后我们在<code>index.html</code>中引入上列的文件：</p>

<p>```html</p>

<script src="scripts/libs/jquery.min.js"></script>


<script src="scripts/libs/underscore.js"></script>


<script src="scripts/app.js"></script>


<p>```</p>

<p>我们的应用程序需要做的事情很简单：</p>

<ol>
<li>请求服务器获得数据</li>
<li>处理数据（如果需要的话）</li>
<li>将加工过的数据与模板结合，渲染在页面上</li>
</ol>


<p><code>underscore.js</code>中有一个用来处理模板的函数，叫做<code>template</code>：</p>

<p>```js
var compiled = _.template("<h1>&lt;%= title %></h1>");
compiled({"title": "Heartbeat Failure @ VIQ002"});</p>

<p>//<h1>Heartbeat Failure @ VIQ002</h1>
```</p>

<p>注意上式中的<code>&lt;%= variable %&gt;</code>，这个表达式表示打印<code>variable</code>的值。而如果只是执行JavaScript代码，表达式则为<code>&lt;% expression; %&gt;</code>。</p>

<p>比如我们可以使用<code>for</code>循环：</p>

<p>```js
var template =</p>

<pre><code>"&lt;% _.each(alarms, function(alarm){ %&gt;" +
    "&lt;h3&gt;&lt;%= alarm.summary %&gt;&lt;/h3&gt;" +
"&lt;% }); %&gt;";
</code></pre>

<p>var compilded = _.template(template);
compilded({"alarms": [
  {</p>

<pre><code>"proiority": "critical",
"occurrence": "2/12/2015 01:23 AM",
"summary": "heartbeat failure",
"node": "VIQ002"
</code></pre>

<p>  },
  {</p>

<pre><code>"proiority": "major",
"occurrence": "2/12/2015 01:22 AM",
"summary": "packages are rejected",
"node": "VIQ002"
</code></pre>

<p>  },
  {</p>

<pre><code>"proiority": "medium",
"occurrence": "2/11/2015 01:23 AM",
"summary": "connection cannot be established",
"node": "VIQ002"
</code></pre>

<p>  }
]});</p>

<p>//<h3>heartbeat failure</h3><h3>packages are rejected</h3><h3>connection cannot be established</h3>
```</p>

<p>注意上边代码中的<code>_.each</code>语句。</p>

<h3>实现</h3>

<p>首先我们在页面上定义一个模板，定义在id为<code>events</code>的<code>script</code>标签中，注意这个script的type为<code>template</code>，这样既可以避免浏览器解释它，又可以为我们临时保存一段文本。</p>

<p>```html</p>

<script type="template" id="events">
    <% _.each(alarms, function(alarm) { %>
        <li>
            <div class="event <%= alarm.proiority%>">
                <h3><%= alarm.summary%> @ <%= alarm.node %></h3>
                <span class="date"><%= alarm.occurrence %></span>
            </div>
        </li>
    <% }); %>
</script>


<p>```</p>

<p>然后在<code>app.js</code>中只需要请求<code>alarms.json</code>，然后编译模板，并绑定数据：</p>

<p>```js
$(function() {</p>

<pre><code>$.get("/alarms.json").done(function(alarms) {
    var compiled = _.template($("#events").html());
    var html = compiled({"alarms": alarms});

    $(".events").html(html);
});
</code></pre>

<p>});
```</p>

<p>刷新页面，就可以看到来自于后台的实际数据了（当然，我们这里使用了一个静态的<code>alarms.json</code>来模拟后台的API）：</p>

<p><img src="/images/2015/02/fetch-data-resized.png" alt="fetch data from server" /></p>

<h4>处理数据</h4>

<p>你可能已经看到了，由于后台数据采集的问题，前端请求到的数据不一定每次都是按照日期排好序的，因此我们需要在拿到数据之后先排序在展示。好在我们之前已经学习了如何做到这一点：</p>

<p>```js
$(function() {</p>

<pre><code>$.get("/alarms.json").done(function(alarms) {
    var eventCompiled = _.template($("#events").html());

    var events = _(alarms).sortBy("occurrence").reverse();
    var eventHTML = eventCompiled({"alarms": events});

    $(".events").html(eventHTML);
});
</code></pre>

<p>});
```</p>

<p>剩下的就是页面最底部的图例部分了，这部分会统计各种类型告警的合计信息，这些信息需要进一步的汇总。首先我们将<code>legend</code>封装成模板：</p>

<p>```html</p>

<script type="template" id="legend">
    <% _.each(legends, function(legend) { %>
        <li>
            <div class="count <%= legend.proiority %>">
                <i class="alarm"></i>
                <span><%= legend.proiority %>: <%= legend.count %></span>
            </div>
        </li>
    <% }); %>
</script>


<p>```</p>

<p>也即，我们需要这样一个结果集：</p>

<p>```js</p>

<p>[</p>

<pre><code>{
    "proiority": "critical",
    "count": 3
},
{
    "proiority": "major",
    "count": 2
}
</code></pre>

<p>]
```</p>

<p>不过使用<code>underscore.js</code>，我们可以很容易的得到这个格式的数据：</p>

<p>```js
var legends = _.chain(alarms)</p>

<pre><code>.groupBy("proiority")
.map(function(value, key) {
    return {proiority: key, count: value.length};
}).value();
</code></pre>

<p>```</p>

<p>其中，<code>groupBy</code>是一个新的API，和<code>SQL</code>中的<code>group by</code>子句一样，它可以将符合条件的项目合并为不同的组：</p>

<p>```js
var contacts = [
  {</p>

<pre><code>  "name": "Juntao",
  "age": 29
</code></pre>

<p>  },
  {</p>

<pre><code>  "name": "Abruzzi",
  "age": 30
</code></pre>

<p>  },
  {</p>

<pre><code>  "name": "Sara",
  "age": 29
</code></pre>

<p>  }
];</p>

<p>var result = _(contacts).groupBy("age");
```</p>

<p>会得到这样的结果：</p>

<p>```json
{</p>

<pre><code>"29": [
    {
        "name": "Juntao",
        "age": 29
    },
    {
        "name": "Sara",
        "age": 29
    }
],
"30": [
    {
        "name": "Abruzzi",
        "age": 30
    }
]
</code></pre>

<p>}
```</p>

<p>因此我们通过上面的计算就可以得到需要的结果了：</p>

<p><img src="/images/2015/02/with-legend-resized.png" alt="with legend" /></p>
]]></content>
  </entry>
  
</feed>
