<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Frontend | I code it]]></title>
  <link href="http://abruzzi.github.com/category/frontend/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2015-02-20T23:09:46+11:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[现代Web页面开发流程]]></title>
    <link href="http://abruzzi.github.com/2014/11/modern-ui-development-workflow/"/>
    <updated>2014-11-25T14:11:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/11/modern-ui-development-workflow</id>
    <content type="html"><![CDATA[<h3>现代Web页面开发流程</h3>

<p>通常来说，Web页面开发的流程大致是这样的：设计师（设计师不是美工，就像程序员不是码农一样）提供设计稿，通常是图片格式。然后前端的开发人员（在ThoughtWorks我们称之为UI Dev）来手工的将图片转换为对应的HTML+CSS，往往还需要在各个浏览器中调试等。</p>

<p>大多数时候，设计师会提供色卡，或者至少前景色/背景色/高亮色的值给开发人员。如果没有的话，开发人员会用到一些工具如<code>colorpicker</code>, <code>ruler</code>之类来确保最终的效果和设计稿是一致的。</p>

<p>如果你观察过UI Dev的工作流程的话，你会发现基本的上是这样的：使用编辑器（或者IDE）编写HTML代码，CSS代码，保存修改内容，切换到浏览器窗口，按<code>F5</code>或者<code>Ctrl-R</code>刷新，然后对比设计稿和实现，如果发现不一致的地方，再切换到编辑器中修改代码，如是往复。</p>

<h4>避免手工劳动</h4>

<p>纯手工的方式来编辑HTML/CSS会非常耗时，特别是作为标记语言的HTML，开发者需要时刻关注关闭已经打开的标签。比如一个标题元素，你需要：</p>

<p>```html</p>

<h1>This is the page title</h1>


<p>```</p>

<p>几乎从一开始，人们就想到了各种办法来避免自己重复的键入，比如Vim的<a href="https://github.com/ervandew/supertab">SuperTab</a>以及<a href="https://github.com/garbas/vim-snipmate">Snipmate</a>插件，可以通过输入<code>标签名</code>+<code>Tab</code>来补全所有的标签等，又或者DreamWaver提供的<code>代码生成</code>的方式来简化这一流程。</p>

<p>Sublime的编辑器上的著名插件<a href="https://sublime.wbond.net/packages/Emmet">Emmet</a>可以帮助开发人员飞速的开发HTML/CSS，这里有一个小例子。假设我们需要实现的页面是这样的：</p>

<p><img src="/images/2014/11/web-design-resized.png" alt="web design" /></p>

<p>那么对应的HTML结构可能会是：</p>

<p>```html</p>

<ul>
    <li>
        <div class="feature">
            <span class="number"></span>
            <i></i>
            <h4></h4>
            <p></p>
        </div>
    </li>
    ...
</ul>


<p>```</p>

<p>使用Emmet，则只需要给出表达式，然后按一下<code>Tab</code>键就可以补全为上述的结构了：</p>

<p><code>
ul&gt;li*3&gt;.feature&gt;span.number+i+h4+p
</code></p>

<p>上边的这条命令可以读作："创建一个UL，该UL下有3个LI，每个LI下有一个class为feature的DIV（不指定元素名称的话，默认生成div），每个DIV内，有一个类为.number的SPAN，一个i元素，一个H4元素和一个P元素"</p>

<p>完整的技巧可以参看<a href="http://docs.emmet.io/cheat-sheet/">官方文档</a>。</p>

<h4>避免重复劳动</h4>

<p>上边提到的频繁的F5刷新，可以通过<code>LiveReload+Guard</code>两个工具的组合来解决。<a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">LiveReload</a>是一个浏览器的插件，通过协议与后台的服务器进行通信。当后台文件发生变化时，LiveReload会自动刷新页面。</p>

<p><a href="https://github.com/guard/guard">Guard</a>会使用操作系统的API来感知本地文件的变化，当文件变化后，它可以通知LiveReload进行刷新，当然Guard可以做其他一些事情，比如等SCSS发生变化时，自动编译CSS等。</p>

<p>两者结合之后，就可以节省我们大量的时间，而把精力主要投放在开发这件事情本身上。</p>

<h4>样板工程</h4>

<p>我在Github上公开了一个样板工程，这是一个开箱即用的工程，其中提供了这样一些配置：</p>

<ol>
<li>SCSS的编译环境（使用compass）</li>
<li>Guard配置（当你的SCSS文件或者HTML文件修改之后，自动通知LiveReload来刷新浏览器）</li>
<li>一个标准的HTML5样板文档</li>
<li>一个基本的style.scss</li>
</ol>


<p>Guardfile的配置中，如果<code>index.html</code>发生变化，或者<code>stylesheets</code>中的css文件发生变化，或者<code>scripts</code>目录中的js文件发生变化，都会触发<code>livereload</code>任务（通知浏览器）。</p>

<p>```rb
guard 'livereload' do
  watch('index.html')
  watch(%r{stylesheets/.+.(css)})
  watch(%r{scripts/.+.(js)})
end</p>

<p>guard :compass
```</p>

<p>你只需要简单的将这个工程克隆到本地：</p>

<p><code>sh
$ git clone git@github.com:abruzzi/design-boilerplate.git mydesign
</code></p>

<p>然后在该目录中执行<code>bundle install</code>即可：</p>

<p><code>sh
$ cd mydesign
$ bundle install
</code></p>

<p>这里有两点假设：
1.  你已经安装了<a href="http://rvm.io/">rvm</a>
2.  你已经使用rvm安装了某个版本的ruby，即<code>bundler</code>这个gem</p>

<h4>开发流程</h4>

<p>我通常会启动两个终端，一个用来运行<code>Guard</code>，另一个用来运行<code>HTTP Server</code>，然后是一个浏览器：</p>

<p><img src="/images/2014/11/workflow-resized.png" alt="workflow" /></p>

<p>当在编辑器中进行编辑之后，保存文件，浏览器会自动刷新，这样的快速反馈可以告诉我下一步应该如何修改：将背景色调整的再淡一点，还是把会h2的字体变得更大，或者图片和文字的上边缘没有对齐等等。</p>

<p>这种开发流程和后台开发人员进行TDD的方式非常类似：<code>实时反馈，小步前进</code>！如果你的桌子上有两个显示器的话，那就更好了，你可以在一台显示器上显示设计稿，另一台上分屏显示编辑器和浏览器，这样就可以非常舒服的进行UI开发了：</p>

<p><img src="/images/2014/11/two-displays-resized.png" alt="two displays" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逐步编写一个jQuery插件(todoify)]]></title>
    <link href="http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step/"/>
    <updated>2013-07-20T13:04:00+10:00</updated>
    <id>http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step</id>
    <content type="html"><![CDATA[<h3>最终结果</h3>

<p>这篇文章将讨论如何编写一个简单的jQuery插件的基本步骤和实践，最后完成的时候，我们会得到一个管理todo的插件（而且还是一个比较灵活，易于定制的todo插件）。事实上，这个插件可以工作在所有与管理todo类似的应用场景中，比如gmail的搜索框中的token等，豆瓣读书里的tags管理等等。</p>

<p><img src="http://abruzzi.github.com/images/2013/07/todo-origin.resized.png" alt="默认设置" /></p>

<p>上例中HTML结构如下：</p>

<p>```</p>

<div id="container">
    <input type="text" id="input" />
    <div id="todos" />
</div>
```

下面的JavaScript代码将会找到id为*input*的输入框，并将它**变为**一个todolist的控制器，并将新加入的内容添加到id为*todos*的容器中：

```
$("#input").todoify({
    container: "#todos"
});
```

如果需要定制item的外观，可以定义模板并自定义渲染函数：

```
$("#thing-input").todoify({
    container: "#thing-todos",
    template: "<section class='todoItem'><header><%= todo %></header><a>remove</a></section>",
    renderItem: function(item) {
        var cont = this.renderTemplate(item);

        cont.find("a").click(function(event){
            cont.remove();
        });

        return cont;
    }
});
```

![Item定制](http://abruzzi.github.com/images/2013/07/todo-customized.resized.png)

### jQuery插件基础知识

#### 简单流程
通常使用jQuery的流程是这样的：通过选择器选择出一个jQuery对象（集合），然后为这个对象应用一些预定义的函数，如：

```
$(".artile .title").mouseover(function(){
    $(this).css({
        "background-color": "red",
        "color": "white"
    });
});
```

我们如果要定义自己的插件，预期其被调用的方式和此处的*mouseover*并无二致。这需要将我们定义的函数attach到jQuery对象的fn属性上：

```
$.fn.hltitle = function() {
    this.mouseover(function(){
        $(this).css({
            "background-color": "red",
            "color": "white"
        })
    })
}

$('.article .title').hltitle();
```

jQuery的一个很明显的特点是其链式操作，即每次调用完成一个函数/插件之后仍然会返回jQuery对象本身，这个需要我们在插件函数的最后一行返回*this*。这样插件的使用者会像使用其他函数/插件一样很方便的将调用连起来。

另外一个问题是注意命名冲突（$是一个合法的标示符，而且被众多的JavaScript库在使用），所以可以通过匿名执行函数来避免：

```
(function($){
    $.fn.hltitle = function() {
        //...
    }
}(jQuery));
```

#### 需要注意的问题

上面是一个最简单的插件定义，为了插件更加灵活，我们需要尽可能多的将配置项暴露给插件的用户，比如提供一些默认选项，如果用户不提供配置，则插件按照默认配置来工作，但是用户可以通过修改配置来定制插件的行为：

```
(function($){
    $.fn.hltitle = function(options) {
        var defaults = {
            "background-color": "red",
            "color": "white"                
        };
        
        var settings = $.extend(defaults, options);
        
        return this.mouseover(...);
    }
}(jQuery));

```

### Todoify

我们的插件是一个遵循上述原则的简单插件，基本的步骤如下：

-   将给定的input包装成一个jQuery对象
-   需要一个默认的放置todolist的容器元素
-   为input注册keypress事件（如果用户按Enter，则触发add事件，添加一个新条目到容器）

```
(function($){
    $.fn.todoify = function(options) {
        var settings = $.extend({
            container: "body",
            template: "<span class='todo-item'><%= todo %></span>",
            renderItem: function(item) {
                return $(_.template(this.template, {todo: item}));
            }
        }, options);

        $(this).keypress(function(event){
            if(event.keyCode == 13) {
                var item = $(this).val();
                $(settings.container).append(settings.renderItem(item));
                $(this).val("").focus();
            }
        });

        return this;
    }
}(jQuery));
```

此处为了防止创建众多的DOM元素，然后依次插入到正确地节点上，我使用了underscore.js的template，不过此处并非重点，略微一提。

如果用户想要更好地定制性，比如用户想要apply自己的class，定义自己的模板，或者注册新的事件（删除一条todo），显然我们需要更多的options：

```
var settings = $.extend({
    data: [],
    template: "<div class='todo'><h3><%= todo %></h3><span>X</span></div>",
    container: "body",
    renderTemplate: function(item) {
        return $(_.template(this.template, {todo: item}));
    },
    renderItem: function(item) {
        var cont = this.renderTemplate(item);
        cont.find("span").click(function(event) {
            cont.remove();
        });
        return cont;
    }
}, options);
```

这里定义了默认的close事件需要attach到span（定义在模板中）上，如果插件的用户需要自己绘制模板，并且注册事件，那么会像文章开头的那个实例一样：

```
$("#thing-input").todoify({
    container: "#thing-todos",
    template: "<section class='todoItem'><header><%= todo %></header><a>remove</a></section>",
    renderItem: function(item) {
        var cont = this.renderTemplate(item);

        cont.find("a").click(function(event){
            cont.remove();
        });

        return cont;
    }
});
```

###进一步改进

目前，todoify还没有与后台进行任何的通信，如果可以和后台的RESTFul的API集成的话，这个插件将会有更多的使用场景。

简单来讲，只需要为插件提供更多选项，并提供回调函数即可，比如：

```
$("#input").todoify({
    restful: 'http://app/todos',
    onadd: function(item){
        //...
    },
    ondelete: function(item){
        //...
    }
})
```

然后加入一些ajax的调用即可。

]]></content>
  </entry>
  
</feed>
