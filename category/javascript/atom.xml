<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | I code it]]></title>
  <link href="http://abruzzi.github.com/category/javascript/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2018-01-13T16:18:13+08:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[反馈拯救世界]]></title>
    <link href="http://abruzzi.github.com/2018/01/feedback-saves-the-world/"/>
    <updated>2018-01-13T12:07:00+08:00</updated>
    <id>http://abruzzi.github.com/2018/01/feedback-saves-the-world</id>
    <content type="html"><![CDATA[<h3>心流</h3>

<p>你可能有过这样的体验：在玩一个很有趣的游戏时，时间会飞快的流逝，等你终于通关之后才发现已经是凌晨，而你的午饭和晚饭还都没吃。虽然可能饿着肚子，但是你内心却有一种很兴奋，很神清气爽的感觉。而当你在做一些不得不完成的工作/作业时（比如写年终总结报告），时间又会过得很慢，你的心情也常常变得焦虑或者暴躁。</p>

<p>通常来说，人的心情总是会在各种情绪中起伏不定，不过毋庸置疑，我们都希望永远或者至少是尽可能多的保持第一个场景中的状态。</p>

<p><img src="/images/2018/01/playing-game-resized.png" alt="" /></p>

<p>这种精神高度集中，通过自己的努力不断完成挑战，并常常会有忘记时间流逝，甚至忘记自身存在，只剩下“做事情”本身的状态，在心理学上被称之为<a href="https://en.wikipedia.org/wiki/Flow_(psychology">心流（Flow）</a>)。人们虽然很早就发现了这种现象，但是直到1975年，心理学家米哈里·齐克森米哈里（<a href="https://en.wikipedia.org/wiki/Mih%C3%A1ly_Cs%C3%ADkszentmih%C3%A1lyi">Mihaly Csikszentmihalyi</a>）才将其概念化并通过科学的方式来研究。</p>

<blockquote><p>心流（英语：Flow），也有别名以化境(Zone)表示，亦有人翻译为神驰状态，定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生时同时会有高度的兴奋及充实感。</p></blockquote>

<p>进入心流之后会有很多特征：</p>

<ul>
<li>愉悦</li>
<li>全身心投入</li>
<li>忘我，与做的事情融为一体</li>
<li>主观的时间感改变</li>
</ul>


<p>心流被普遍认为是一种绝佳的精神体验。根据齐克森米哈里的理论，与心流对应的，还有一些其他的心理状态：</p>

<p><img src="/images/2018/01/300px-Challenge_vs_skill.svg.png" alt="" /></p>

<p>当自身能力很高，但是做的事情很简单的话，你做起来会比较无聊；而当能力不足，要做的事情很困难的话，你又会陷入焦虑。有意思的是，如果你技能不足，而做的事情又比较简单的话，并不会产生“心流”体验。恰恰相反，这种状态（<strong>apathy</strong>）是很消极的，做事情的过程中，你既没有运用任何技能，也并没有接受到任何的挑战。</p>

<h3>如何进入心流状态</h3>

<p>齐克森米哈里要进入心流状态，需要满足至少三点：</p>

<ul>
<li>有清晰的目标</li>
<li>有明确且事实的反馈</li>
<li>能力和挑战的平衡（都处于比较高的状态）</li>
</ul>


<p>比如，玩游戏的时候，目标是明确的，不论是简单的通过策略消灭对方，还是将三个同一颜色的宝石移动到同一行）；反馈也是实时的，同色宝石连在一起是发出的声音以及屏幕上闪过的炫目的光芒，敌人在被你手中武器杀死时的惨叫，你自己的血槽等等；最后，游戏不能过于简单，如果太简单，你很快会觉得无聊，又不能太难，这样你会觉得挑战太大。</p>

<p>不过要在工作上进入心流状态，远远比玩游戏要复杂。比如不明确的目标，冗长的反馈周期，能力与挑战的不均衡等等。</p>

<h3>基于反馈的开发</h3>

<p>2014年底，我在<code>ThoughtWorks</code>组织<a href="http://icodeit.org/3-pages-in-3-weeks/">3周3页面</a>工作坊的时候，发现了一个很有意思的现象：通常公司内部的培训/工作坊都会出现这种现象：报名的人很多，前几次课会来很多人，慢慢的人数会减少，能坚持到最后的人很少，能完成作业的就更少了。而在<a href="http://icodeit.org/3-pages-in-3-weeks/">3周3页面</a>中，参加的人数越来越多，而且作业的完成率非常高（接近100%）。</p>

<p>回想起来，我在培训的最开始就设置了一些机制，保证学员可以有一个非常容易沉浸其中的环境：</p>

<ul>
<li>通过watch、livereload等机制，保证每次修改的CSS/HTML都可以在1秒钟内在浏览器上自动刷新</li>
<li>通过对比mockup和自己实现的样式的差异，来调整自己的目标</li>
<li>将这些工具做成<a href="https://github.com/abruzzi/design-boilerplate">开箱即用</a>的，这样经验不足者不至于被技术细节阻塞</li>
<li>做完之后，学员们的作品直接发布到<a href="https://pages.github.com/">github的pages</a>上</li>
</ul>


<p><img src="/images/2018/01/3p3w-resized.png" alt="" /></p>

<p>事实上，这些实践恰好满足了上述的几个条件：</p>

<ul>
<li>目标明确</li>
<li>快速且准确的反馈</li>
<li>技能与挑战的平衡</li>
</ul>


<p>由于工作坊是在周内下班后（8点结束），我见到很多学员在课后（很晚的时候）还在写代码、调样式，完全沉浸其中，忘记时间。到最后，参加培训的学员们被要求通过设计原则自己实际一个Web Site，很多没有前段开发背景的同事也做出了非常有“设计感”的作品。</p>

<p><img src="/images/2018/01/3p3w-showcase-resized.png" alt="" /></p>

<h3>编程语言的壁垒</h3>

<p>使用<code>JavaScript</code>或者<code>Ruby</code>这种解释型语言的开发人员，在第一次接触之后就会深深的爱上它，并再也无法回到编译型语言中去了。想一想要用<code>Java</code>打印一行<code>Hello World</code>你得费多大劲？</p>

<p>解释型语言中，你很容易可以采用<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>环境，写代码会变成一个做实验的过程：函数名写错了，参数传错了，某个函数没有定义等等错误/手误，都可以在1秒钟内得到反馈，然后你再根据反馈来修正方向。</p>

<p>举个小例子，写一个字符串处理函数：将字符串”qiu,juntao”转换成“Qiu Juntao”，你会怎么做？你大概知道有这样一些原生的API：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">String.indexOf</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">String.replace</a></li>
<li><a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">大小写转换</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>（可选）</li>
</ul>


<p>如果用JavaScript来实现的话，你可以在<code>Chrome</code>的<code>DevTools</code>中完成大部分的工作：</p>

<p><img src="/images/2018/01/chrome-dev-tools-resized.png" alt="" /></p>

<p>注意这里的每次操作的反馈（特别是出错的情况），你可以在1秒钟内就知道明确的反馈，而不是等等待漫长的编译过程。DevTools里的console提供的REPL（read-eval-print-loop）可以帮助你建立流畅的编码体验。</p>

<p>如果用<code>Java</code>来做，你需要一大堆的准备工作，抛开<code>JDK</code>的安装，<code>JAVA_HOME</code>的设置等，你还需要编译代码，需要定义一个类，然后在类中定义main方法，然后可能要查一些API来完成函数的编写。而每一个额外的步骤都会延长反馈的时间。</p>

<h3>测试驱动开发</h3>

<p>那么在编译型语言中如何获得这种体验呢？又如何缩短反馈周期呢？答案是使用<strong>测试驱动开发</strong>（Test Driven Development）！</p>

<p>通常<code>TDD</code>会包含这样几个步骤：</p>

<ol>
<li>根据用户故事做任务分解</li>
<li>根据分解后的<code>Task</code>设计测试</li>
<li>编写测试</li>
<li>编写可以通过测试的实现</li>
<li>重构</li>
</ol>


<p><img src="/images/2018/01/tasking-resized.png" alt="" /></p>

<p>步骤3-5可能会不断重复，直到所有的Task都完成，用户故事也就完成了。如果仔细分析，这些步骤也恰好符合产生心流的条件：</p>

<ul>
<li>划分任务</li>
<li>清晰每一个小任务</li>
<li>通过测试得到快速而明确的反馈</li>
</ul>


<p>虽然对上边字符串转换的例子来说，<code>TDD</code>的方式还是比较重量级，不过反馈更明确，你可以在写完一个函数之后立即得到测试成功或者失败的反馈（编译过程并没有省略，不过我们通过测试的红和绿来不断强化反馈）。</p>

<p>而且这种方法的好处在于：对于更加复杂的需求来说，它仍然适用。如果开发者的技能和需求的难度都比较高的话，这种方式很容易达到心流的状态。</p>

<h3>小结</h3>

<p>要想在工作中让自己过得更舒服一些，你需要创造条件让自己进入心流状态。在这些条件中，最重要的是要建立其一套快速反馈的机制，这个机制可以是：</p>

<ul>
<li>一个可以自动运行的测试套件</li>
<li>一个可以迭代的页面原型</li>
<li>一个watch所有HTML/SCSS的脚本+live-reload</li>
<li>一个和你一起写代码的同事（结对编程）</li>
</ul>


<p><img src="/images/2018/01/gulp-serve-resized.png" alt="" /></p>

<p>另一方面，你需要不断的学习和练习，提升自己的技能，这样在遇到新的问题时才可能比较从容应对。不要忘了，<strong>更熟练的技能</strong>本身也是进入心流的重要条件之一。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你为什么应该试一试Reflux？]]></title>
    <link href="http://abruzzi.github.com/2015/11/get-started-with-reflux/"/>
    <updated>2015-11-09T23:03:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/11/get-started-with-reflux</id>
    <content type="html"><![CDATA[<h3>一点背景</h3>

<p>React在设计之初就只关注在View本身上，其余部分如<code>数据的获取</code>，<code>事件处理</code>等，全然不在考虑之内。不过构建大型的Web前端应用，这些点又实在不可避免。所以Facebook的工程师提出了前端的<code>Flux</code>架构，这个架构的最大特点是<code>单向数据流</code>（后面详述）。但是<code>Flux</code>本身的实现有很多不合理的地方，比如单例的Dispatcher会在系统中有多种事件时导致臃肿的<code>switch-cases</code>等。</p>

<p>这里是Facebook官方提供的提供<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc#structure-and-data-flow">Flux的结构图</a>。</p>

<p><img src="/images/2015/11/flux-diagram-resized.png" alt="Flux Diagram" /></p>

<p>其实整个Flux背后的思想也<a href="http://bitquabit.com/post/the-more-things-change/">不是什么新东西</a>。在很久之前，Win32的消息机制（以及很多的GUI系统）就在使用这个模型，而且这也是一种被证实可以用来构建大型软件的模型。</p>

<p>鉴于Flux本身只是一个架构，而且Facebook提供的参考实现又有一些问题，所以社区有了很多版本的Flux实现。比如我们这里会用到的<a href="http://spoike.ghost.io/deconstructing-reactjss-flux/">Reflux</a>。</p>

<h3>Reflux简介</h3>

<p>简而言之，<a href="https://github.com/reflux/refluxjs">Reflux</a>里有两个组件：Store和Action。Store负责和数据相关的内容：从服务器上获取数据，并更新与其绑定的React组件（view controller）;Action是一个事件的集合。Action和Store通过convention来连接起来。</p>

<p>具体来说，一个典型的过程是：</p>

<ol>
<li>用户的动作(或者定时器)在组件上触发一个Action</li>
<li>Reflux会调用对应的Store上的callback（自动触发）</li>
<li>这个callback在执行结束之后，会显式的触发（trigger）一个数据</li>
<li>对应的组件（可能是多个）的state会被更新</li>
<li>React组件检测到state的变化后，会自动重绘自身</li>
</ol>


<p><img src="/images/2015/11/reflux-data-flow.png" alt="reflux data flow" /></p>

<h3>一个例子</h3>

<p>我们这里将使用React/Reflux开发一个实际的例子，从最简单的功能开始，逐步将其构建为一个较为复杂的应用。</p>

<p>这个应用是一个书签展示应用（数据来源于我的Google Bookmarks）。第一个版本的界面是这样的：</p>

<p><img src="/images/2015/11/bookmarks-list-resized.png" alt="bookmarks list" /></p>

<p>要构建这样一个列表应用，我们需要这样几个部分：</p>

<ol>
<li>一个用来<code>fetch</code>数据，存储数据的store （BookmarkStore）</li>
<li>一个用来表达事件的<code>Action</code>（BookmarkActions）</li>
<li>一个列表组件（BookmarkList）</li>
<li>一个组件条目组件（Bookmark）</li>
</ol>


<h4>定义Actions</h4>

<p>```js
var Reflux = require('reflux');
var BookmarkActions = Reflux.createActions([</p>

<pre><code>'fetch'
</code></pre>

<p>]);</p>

<p>module.exports = BookmarkActions;
```</p>

<p>第一个版本，我们只需要定义一个<code>fetch</code>事件即可。然后在<code>Store</code>中编写这个Action的回调：</p>

<h4>定义Store</h4>

<p>```js
var $ = require('jquery');
var Reflux = require('reflux');
var BookmarkActions = require('../actions/bookmark-actions');</p>

<p>var Utils = require('../utils/fetch-client');</p>

<p>var BookmarkStore = Reflux.createStore({</p>

<pre><code>listenables: [BookmarkActions],

init: function() {
    this.onFetch();
},

onFetch: function() {
    var self = this;
    Utils.fetch('/bookmarks').then(function(bookmarks) {
        self.trigger({
            data: bookmarks,
            match: ''
        });
    });
}
</code></pre>

<p>});</p>

<p>module.exports = BookmarkStore;
```</p>

<p>此处，我们使用<code>listenables: [BookmarkActions]</code>来将Store和Action关联起来，根据<code>convention</code>，<code>on</code>+事件名称就是回调函数的名称。这样当<code>Action</code>被触发的时候，<code>onFetch</code>会被调用。当获取到数据之后，这里会显式的<code>trigger</code>一个数据。</p>

<h4>List组件</h4>

<p>```js
var React = require('react');
var Reflux = require('reflux');</p>

<p>var BookmarkStore = require('../stores/bookmark-store.js');
var Bookmark = require('./bookmark.js');</p>

<p>var BookmarkList = React.createClass({</p>

<pre><code>mixins: [Reflux.connect(BookmarkStore, 'bookmarks')],

getInitialState: function() {
    return {
        bookmarks: {data: []}
    }
},

render: function() {
    var list = [];
    this.state.bookmarks.data.forEach(function(item) {
      list.push(&lt;Bookmark title={item.title} created={item.created}/&gt;)
    });

    return &lt;ul&gt;
        {list}
    &lt;/ul&gt;
}
</code></pre>

<p>});</p>

<p>module.exports = BookmarkList;
```</p>

<p>在组件中，我们通过<code>mixins: [Reflux.connect(BookmarkStore, 'bookmarks')]</code>将Store和组件关联起来，这样List组件<code>state</code>上的<code>bookmarks</code>就和<code>BookmarkStore</code>连接起来了。当<code>state.bookmarks</code>变化之后，<code>render</code>方法就会被自动调用。</p>

<p>对于每一个书签，就只是简单的展示内容即可：</p>

<h4>Bookmark组件</h4>

<p>```js
var React = require('react');
var Reflux = require('reflux');
var moment = require('moment');</p>

<p>var Bookmark = React.createClass({</p>

<pre><code>render: function() {
    var created = new Date(this.props.created * 1000);
    var date = moment(created).format('YYYY-MM-DD');

    return &lt;li&gt;
        &lt;div className='bookmark'&gt;
            &lt;h5 className='title'&gt;{this.props.title}&lt;/h5&gt;
            &lt;span className='date'&gt;Created @ {date}&lt;/span&gt;
        &lt;/div&gt;
    &lt;/li&gt;;
}
</code></pre>

<p>});</p>

<p>module.exports = Bookmark;
```</p>

<p>这里我使用了<code>moment</code>库将<code>unix timestamp</code>转换为日期字符串，然后写在页面上。</p>

<p>最后，<code>Utils</code>只是一个对<code>jQuery</code>的包装：</p>

<p>```js
var $ = require('jquery');
var Promise = require('promise');</p>

<p>module.exports = {</p>

<pre><code>fetch: function(url) {
    var promise = new Promise(function (resolve, reject) {
        $.get(url).done(resolve).fail(reject);
    });

    return promise;
}
</code></pre>

<p>}
```</p>

<p>我们再来总结一下，<code>BookmarkStore</code>在初始化的时候，显式地调用了<code>onFetch</code>，这个动作会导致<code>BookmarkList</code>组件的<code>state</code>的更新，这个更新会导致<code>BookmarkList</code>的重绘，<code>BookmarkList</code>会依次迭代所有的<code>Bookmark</code>。</p>

<h3>更复杂一些</h3>

<p>当然，Reflux的好处不仅仅是上面描述的这种单向数据流。当<code>Store</code>，<code>Actions</code>以及具体的<code>组件</code>被解耦之后，构建大型的应用才能成为可能。我们来对上面的应用做一下扩展：我们为列表添加一个搜索功能。</p>

<p>随着用户的键入，我们发送请求到服务器，将过滤后的数据渲染为新的列表。我们需要这样几个东西</p>

<ol>
<li>一个SearchBox组件</li>
<li>一个新的<code>Action</code>：<code>search</code></li>
<li><code>BookmarkStore</code>上的一个新方法<code>onSearch</code></li>
<li>组件<code>SearchBox</code>需要和<code>BookmarkActions</code>关联起来</li>
</ol>


<p>为了让用户看到匹配的效果，我们需要将匹配到的关键字高亮起来，这样我们需要在<code>Bookmark</code>组件中监听<code>BookmarkStore</code>，当<code>BookmarkStore</code>发生变化之后，我们就可以即时修改书签的<code>title</code>了。</p>

<h4>搜索框组件</h4>

<p>```js
var React = require('react');
var BookmarkActions = require('../actions/bookmark-actions');</p>

<p>var SearchBox = React.createClass({</p>

<pre><code>performSearch: function() {
    var keyword = this.refs.keyword.value;
    BookmarkActions.search(keyword);
},

render: function() {
    return &lt;div className="search"&gt;
        &lt;input type='text' 
            placeholder='type to search...' 
            ref="keyword"
            onChange={this.performSearch} /&gt;    
    &lt;/div&gt;
}
</code></pre>

<p>});</p>

<p>module.exports = SearchBox;
```</p>

<h4>BookmarkStore</h4>

<p>```js
var $ = require('jquery');
var Reflux = require('reflux');
var BookmarkActions = require('../actions/bookmark-actions');</p>

<p>var Utils = require('../utils/fetch-client');</p>

<p>var BookmarkStore = Reflux.createStore({</p>

<pre><code>listenables: [BookmarkActions],

init: function() {
    this.onFetch();
},

onFetch: function() {
    var self = this;
    Utils.fetch('/bookmarks').then(function(bookmarks) {
        self.trigger({
            data: bookmarks,
            match: ''
        });
    });
},

onSearch: function(keyword) {
    var self = this;

    Utils.fetch('/bookmarks?keyword='+keyword).then(function(bookmarks) {
        self.trigger({
            data: bookmarks,
            match: keyword
        });
    });
}
</code></pre>

<p>});</p>

<p>module.exports = BookmarkStore;
```</p>

<p>我们在<code>BookmarkStore</code>中添加了<code>onSearch</code>方法，它会根据关键字来调用后台API进行搜索，并将结果<code>trigger</code>出去。由于数据本身的结构并没有变化（只是数量会由于过滤而变少），因此<code>BookmarkList</code>是无需修改的。</p>

<h4>书签高亮</h4>

<p>当搜索匹配之后，我们可以将对应的关键字高亮起来，这时候我们需要修改<code>Bookmark</code>组件：</p>

<p>```js
var React = require('react');
var Reflux = require('reflux');
var moment = require('moment');</p>

<p>var BookmarkStore = require('../stores/bookmark-store.js');</p>

<p>var Bookmark = React.createClass({</p>

<pre><code>mixins: [Reflux.listenTo(BookmarkStore, 'onMatch')],

onMatch: function(data) {
    this.setState({
        match: data.match
    });
},

getInitialState: function() {
    return {
        match: ''
    }
},

render: function() {
    var created = new Date(this.props.created * 1000);
    var date = moment(created).format('YYYY-MM-DD');

    var title = this.props.title;
    if(this.state.match.length &gt; 0) {
        title = &lt;span
            dangerouslySetInnerHTML={{
              __html : this.props.title.replace(new RegExp('('+this.state.match+')', "gi"), '&lt;span class="highlight"&gt;$1&lt;/span&gt;')
            }} /&gt;
    }

    return &lt;li&gt;
        &lt;div className='bookmark'&gt;
            &lt;h5 className='title'&gt;{title}&lt;/h5&gt;
            &lt;span className='date'&gt;Created @ {date}&lt;/span&gt;
        &lt;/div&gt;
    &lt;/li&gt;;
}
</code></pre>

<p>});</p>

<p>module.exports = Bookmark;
```</p>

<p><code>mixins: [Reflux.listenTo(BookmarkStore, 'onMatch')]</code>表示，我们需要监听<code>BookmarkStore</code>的变化，当变化发生时，调用<code>OnMatch</code>方法。<code>OnMatch</code>会修改组件的<code>match</code>属性，从而触发<code>render</code>。</p>

<p>在<code>render</code>中，我们替换关键字为<code>&lt;span class="highlight"&gt;$keyword&lt;/span&gt;</code>，这样就可以达到预期的效果了：</p>

<p><img src="/images/2015/11/bookmark-search-resized.png" alt="bookmark search" /></p>

<h3>结论</h3>

<p>从上面的例子可以看到，我们从一开始就引入了Reflux。虽然第一个版本和React原生的写法差异并不是很大，但是当加入<code>SearchBox</code>功能之后，需要修改的地方非常清晰：添加<code>Actions</code>，在对应的<code>Store</code>中添加callback，然后在组件中使用。这种方法不仅可以最大程度的使用<code>React</code>的长处（diff render），而且使得代码逻辑变得较为清晰。</p>

<p>随着业务代码的不断增加，Reflux提供的方式确实可以在一定程度上控制代码的复杂性和可读性。</p>

<p>完整的<a href="https://github.com/abruzzi/react-reflux-demo">代码地址在这里</a>。</p>

<h3>其他参考</h3>

<ul>
<li><a href="http://www.bunniesandbeatings.com/RefluxManifesto/">Reflux“宣言”</a></li>
<li><a href="https://news.ycombinator.com/item?id=10381015">Flux is the new WndProc</a></li>
<li><a href="https://ochronus.com/react-reflux-example/">React Reflux Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工程中的编译原理 -- Mapfile解析器]]></title>
    <link href="http://abruzzi.github.com/2015/10/mapfile-parser/"/>
    <updated>2015-10-05T12:59:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/10/mapfile-parser</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>Mapfile是<code>MapServer</code>用来描述一个地图的配置文件。它是一个很简单的<code>声明式</code>语言，一个地图（Map）可以有多个层（Layer），每个层可以有很多属性（键值对）。在一个层的定义中，还可以定义若干个类（Class），这个类用以管理不同的样式（Style）。而每个类或者样式都可以由若干个属性（键值对）。</p>

<p>这里有一个实际的例子：</p>

<p>```
LAYER
  NAME         "counties"
  DATA         "counties-in-shaanxi-3857"
  STATUS       default
  TYPE         POLYGON
  TRANSPARENCY 70</p>

<p>  CLASS</p>

<pre><code>NAME       "polygon"
STYLE
  COLOR     255 255 255
  OUTLINECOLOR 40 44 52
END
</code></pre>

<p>  END
END
```</p>

<h4>最简单的层的定义</h4>

<p>最简单的情形是，我们定义了一个层<code>Layer</code>，但是没有指定任何的属性：</p>

<p><code>
LAYER
END
</code></p>

<p>我们期望parser可以输出：</p>

<p><code>js
{layer: null}
</code></p>

<p>要做到这一步，首先需要定义符号<code>LAYER</code>和<code>END</code>，以及一些对空格，非法字符的处理等：</p>

<p><code>js
\s+                     /* skip whitespace */
\n|\r\n                 /* skip whitespace */
"LAYER"                 return "LAYER"
"END"                   return "END"
&lt;&lt;EOF&gt;&gt;                 return 'EOF'
.                       return 'INVALID'
</code></p>

<p>对于，空格，回车换行等，我们都直接跳过。对应的<code>BNF</code>也非常简单：</p>

<p>```js
expressions</p>

<pre><code>: decls EOF {return $1;}
;
</code></pre>

<p>decls</p>

<pre><code>: LAYER END {$$ = {layer: null}}
;
</code></pre>

<p>```</p>

<h4>为层添加属性</h4>

<p>接下来我们来为层添加<code>Name</code>属性，首先还是添加符号<code>NAME</code>和对字符串的定义。这里的字符串被定义为：由双引号括起来的所有内容。</p>

<p><code>js
"NAME"                  return "NAME"
'"'("\\"["]|[^"])*'"'   return 'STRING'
[a-zA-Z]+               return 'WORD'
</code></p>

<p>然后我们就可以为<code>BNF</code>添加一个新的节：</p>

<p>```js
decls:
  LAYER decl END
  {$$ = {layer: $2}}
  ;</p>

<p>decl:
  NAME STRING
  {$$ = $2.substring(1, $2.length - 1)};
```</p>

<p>在<code>decl</code>中，我们将获得的字符串两头的引号去掉<code>$2.substring</code>。这样<code>decl</code>的值就会是字符串本身，而不是带着双引号的字符串了。修改之后的代码可以解析诸如这样的声明：</p>

<p>```
LAYER</p>

<pre><code>NAME "counties"
</code></pre>

<p>END
```</p>

<p>并产生这样的输出：</p>

<p><code>js
{ layer: 'counties' }
</code></p>

<p>但是如果我们用来解析两个以上的属性：</p>

<p><code>js
LAYER
  NAME         "counties"
  DATA         "counties-in-shaanxi-3857"
END
</code></p>

<p>解析器会报告一个错误：</p>

<p>```sh
$ node map.js expr</p>

<p>/Users/jtqiu/develop/ideas/jison-demo/mapfile/map.js:106</p>

<pre><code>    throw new Error(str);
          ^
</code></pre>

<p>Error: Parse error on line 2:
...       "counties"  DATA         "counti
----------------------^
Expecting 'END', got 'WORD'</p>

<pre><code>at Object.parseError (/Users/jtqiu/develop/ideas/jison-demo/mapfile/map.js:106:15)
at Object.parse (/Users/jtqiu/develop/ideas/jison-demo/mapfile/map.js:171:22)
at Object.commonjsMain [as main] (/Users/jtqiu/develop/ideas/jison-demo/mapfile/map.js:620:27)
at Object.&lt;anonymous&gt; (/Users/jtqiu/develop/ideas/jison-demo/mapfile/map.js:623:11)
at Module._compile (module.js:456:26)
at Object.Module._extensions..js (module.js:474:10)
at Module.load (module.js:356:32)
at Function.Module._load (module.js:312:12)
at Function.Module.runMain (module.js:497:10)
at startup (node.js:119:16)
</code></pre>

<p>```</p>

<p>即，期望一个<code>END</code>符号，但是却看到了一个<code>WORD</code>符号。我们只需要稍事修改，就可以让当前的语法支持多个属性的定义：</p>

<p>```js
decls:
  LAYER pairs END
  {$$ = {layer: $2}}
  ;</p>

<p>pairs:
  pair
  {$$ = $1}
  |
  pairs pair
  {$$ = merge($1, $2)}
  ;</p>

<p>pair:
  NAME STRING
  {$$ = {name: $2.substring(1, $2.length - 1)}}
  | DATA STRING
  {$$ = {data: $2.substring(1, $2.length - 1)}};
```</p>

<p>先看，<code>pair</code>的定义，它由<code>NAME STRING</code>或者<code>DATA STRING</code>组成，是我们语法中的终结符。再来看<code>pairs</code>的定义：</p>

<p><code>js
pairs: pair | pairs pair;
</code></p>

<p>这个递归的定义可以保证我们可以写一条<code>pair</code>或者多条<code>pairs pair</code>属性定义语句。而对于多条的情况，我们需要将这行属性<code>规约</code>在一起，即当遇到这样的情形时：</p>

<p><code>
NAME         "counties"
DATA         "counties-in-shaanxi-3857"
</code></p>

<p>我们需要产生这样的输出：<code>{name: "counties", data: "counties-in-shaanxi-3857"}</code>。但是由于符号是逐个匹配的，我们会得到这样的匹配结果：<code>{name: "counties"}</code>和<code>{data: "counties-in-shaanxi-3857"}</code>，因此我们需要编写一个简单的函数来合并这些属性：</p>

<p>```js
  function merge(o1, o2) {</p>

<pre><code>var obj = {};

for(var k in o1) {
  obj[k] = o1[k];
}
for(var v in o2) {
  obj[v] = o2[v];
}

return obj;
</code></pre>

<p>  }
```</p>

<p>按照惯例，这种自定义的函数需要被定义在<code>%{</code>和<code>}%</code>括起来的<code>section</code>中：</p>

<p>```js
...
[a-zA-Z]+               return 'WORD'
[0-9]+("."[0-9]+)?      return 'NUMBER'
&lt;<EOF>>                 return 'EOF'
.                       return 'INVALID'</p>

<p>/lex</p>

<p>%{
  function merge(o1, o2) {</p>

<pre><code>var obj = {};

for(var k in o1) {
  obj[k] = o1[k];
}
for(var v in o2) {
  obj[v] = o2[v];
}

return obj;
</code></pre>

<p>  }
%}</p>

<p>%start expressions</p>

<p>%% /<em> language grammar </em>/
...</p>

<p>```</p>

<p>现在我们的解析器就可以识别多条属性定义了：</p>

<p><code>sh
$ node map.js expr
{ layer: { name: 'counties', data: 'counties-in-shaanxi-3857' } }
</code></p>

<h4>嵌套的结构</h4>

<p>现在新的问题又来了，我们的解析器现在可以识别对层的对个属性的解析了，不过由于<code>CLASS</code>并不是由简单的键值对定义的，所以还需要进一步的修改：</p>

<p><code>js
classes:
  CLASS pairs END
  {$$ = {class: $2}}
  ;
</code></p>

<p>类由<code>CLASS</code>关键字和<code>END</code>关键字定义，而类的属性定义和<code>Layer</code>的属性定义并无二致，都可以使用<code>pairs</code>（多条属性）。而<code>classes</code>事实上是<code>pair</code>的另一种形式，就像对属性的定义一样，所以：</p>

<p><code>js
pair:
  NAME STRING
  {$$ = {name: $2.substring(1, $2.length - 1)}}
  | DATA STRING
  {$$ = {data: $2.substring(1, $2.length - 1)}}
  | classes
  {$$ = $1};
</code></p>

<p>这样，解析器就可以识别<code>CLASS</code>子句了。我们注意到，在<code>CLASS</code>中，还可以定义<code>STYLE</code>，因此又需要稍作扩展：</p>

<p>```js
pair:
  NAME STRING
  {$$ = {name: $2.substring(1, $2.length - 1)}}
  | DATA STRING
  {$$ = {data: $2.substring(1, $2.length - 1)}}
  | classes
  {$$ = $1}
  | styles
  {$$ = $1};</p>

<p>styles:
  STYLE pairs END
  {$$ = {style: $2}}
  ;
```</p>

<p>这样，我们的解析器就可以处理样例中的所有语法了：</p>

<p>```sh
node map.js expr
{ layer:
   { name: 'counties',</p>

<pre><code> data: 'counties-in-shaanxi-3857',
 status: 'default',
 type: 70,
 class: { name: 'polygon', style: [Object] } } }
</code></pre>

<p>```</p>

<p>完整的代码在github上的<a href="https://github.com/abruzzi/jison-demos">这个repo中</a>。</p>

<h3>总结</h3>

<p>使用<code>BNF</code>定义一个复杂配置文件的规则，事实上一个比较容易的工作。要手写这样一个解析器需要花费很多的时间，而且当你需要parser多种配置文件时，这将是一个非常无聊且痛苦的事情。学习<code>jison</code>可以帮助你很快的编写出小巧的解析器，在上面的<code>Mapfile</code>的例子中，所有的代码还不到<code>100</code>行。下一次再遇到诸如复杂的文本解析，配置文件读取的时候，先不要忙着编写<code>正则表达式</code>，试试更高效，更轻便的<code>jison</code>吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工程中的编译原理 -- Jison入门篇]]></title>
    <link href="http://abruzzi.github.com/2015/09/write-a-parser/"/>
    <updated>2015-09-30T18:45:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/09/write-a-parser</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>在代码编写中，很多时候我们都会处理字符串：发现字符串中的某些规律，然后将想要的部分抽取出来。对于发杂一些的场景，我们会使用<code>正则表达式</code>来帮忙，正则表达式强大而灵活，主流的变成语言如<code>Java</code>，<code>Ruby</code>的标准库中都对其由很好的支持。</p>

<p>但是有时候，当接收到的字符串结构更加复杂（往往会这样）的时候，正则表达式要么会变的不够用，要么变得超出我们能理解的复杂度。这时候，我们可能借助一些更为强大的工具。</p>

<p>下面是一个实际的例子，这个代码片段是MapServer的配置文件，它用来描述地图中的一个层，其中包含了嵌套的<code>CLASS</code>，而<code>CLASS</code>自身又包含了一个嵌套的<code>STYLE</code>节。显然，正则表达式在解释这样复杂的结构化数据方面，是无法满足需求的。</p>

<p>```
LAYER
  NAME         "counties"
  DATA         "counties-in-shaanxi-3857"
  STATUS       default
  TYPE         POLYGON
  TRANSPARENCY 70</p>

<p>  CLASS</p>

<pre><code>NAME       "polygon"
STYLE
  COLOR     255 255 255
  OUTLINECOLOR 40 44 52
END
</code></pre>

<p>  END
END
```</p>

<p>在UNIX世界，很早的时候，人们就开发出了很多用来生成<code>解释器</code>(parser)的工具，比如早期的<a href="https://en.wikipedia.org/wiki/Lex_(software">lex</a>)/<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>之类的工具和后来的<a href="https://en.wikipedia.org/wiki/GNU_bison">bison</a>。通过这些工具，程序员只需要定义一个结构化的文法，工具就可以自动生成解释器的C代码，非常容易。在JavaScript世界中，有一个非常类似的工具，叫做<a href="https://zaach.github.io/jison/">jison</a>。在本文中，我将以jison为例，说明在JavaScript中自定义一个解释器是何等的方便。</p>

<p><strong>注意</strong>，我们这里说的<code>解释器</code>不是一个编译器，编译器有非常复杂的后端（抽象语法树的生成，虚拟机器指令，或者机器码的生成等等），我们这里仅仅讨论一个编译器的<strong>前端</strong>。</p>

<h3>一点理论知识</h3>

<p>本文稍微需要一点理论知识，当年编译原理课的时候，各种名词诸如<code>规约</code>，<code>推导式</code>，<code>终结符</code>，<code>非终结符</code>等等，</p>

<h4>上下文无关文法（Context Free Grammar）</h4>

<p>先看看维基上的这段定义：</p>

<blockquote><p>在计算机科学中，若一个形式文法 G = (N, Σ, P, S) 的产生式规则都取如下的形式：V -> w，则称之为上下文无关文法（英语：context-free grammar，缩写为CFG），其中 V∈N ，w∈(N∪Σ)* 。上下文无关文法取名为“上下文无关”的原因就是因为字符 V 总可以被字串 w 自由替换，而无需考虑字符 V 出现的上下文。</p></blockquote>

<p>基本上跟没说一样。要定义一个上下文无关文法，数学上的精确定义是一个在4元组：<code>G = (N, Σ, P, S)</code>，其中</p>

<ol>
<li>N是“非终结符”的集合</li>
<li>Σ是“终结符”的集合，与N的交集为空（不想交）</li>
<li>P表示规则集（即N中的一些元素以何种方式）</li>
<li>S表示起始变量，是一个“非终结符”</li>
</ol>


<p>其中，规则集P是重中之重，我们会在下一小节解释。经过这个形式化的解释，基本还是等于没说，在继续之前，我们先来看一下BNF，然后结合一个例子来帮助理解。</p>

<p>话说我上一次写这种<a href="http://www.cnblogs.com/abruzzi/archive/2009/06/06/1497449.html">学院派的文章</a>还是2009年，时光飞逝。</p>

<h4>巴科斯范式（Backus Normal Form）</h4>

<p>维基上的解释是：</p>

<blockquote><p>巴科斯范式（英语：Backus Normal Form，缩写为 BNF），又称为巴科斯-诺尔范式（英语：Backus-Naur Form，也译为巴科斯-瑙尔范式、巴克斯-诺尔范式），是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。</p></blockquote>

<p>简而言之，它是由推导公式的集合组成，比如下面这组公式：</p>

<p><code>
S -&gt; T + T | T - T | T
T -&gt; F * F | F / F | F
F -&gt; NUMBER | '(' S ')'
NUMBER -&gt;  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></p>

<p>可以被“继续分解”的元素，我们称之为“非终结符”，如上式中的<code>S</code>, <code>T</code>, <code>NUMBER</code>，而无法再细分的如<code>0..9</code>，<code>(</code>，<code>)</code>则被称之为终结符。<code>|</code>表示或的关系。在上面的公式集合中，<code>S</code>可以被其右边的<code>T+T</code>替换，也可以被<code>T-T</code>替换，还可以被<code>T</code>本身替换。回到上一小节最后留的悬疑，在这里：</p>

<ol>
<li>N就是{<code>S</code>, <code>T</code>, <code>F</code>, <code>NUMBER</code>}</li>
<li>Σ就是{<code>0</code>, <code>1</code>, ..., <code>9</code>, <code>(</code>, <code>)</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>}</li>
<li>P就是上面的BNF式子</li>
<li>S就是这个的<code>S</code>(第一个等式的左边状态)</li>
</ol>


<p>上面的BNF其实就是四则运算的形式定义了，也就是说，由这个BNF可以解释一切出现在四则运算中的文法，比如：</p>

<p><code>
1+1
8*2+3
(10-6)*4/2
</code></p>

<p>而所谓上下文无关，指的是在推导式的左边，都是非终结符，并且可以<strong>无条件</strong>的被其右边的式子替换。此处的<strong>无条件</strong>就是上下文无关。</p>

<h3>实现一个四则运算计算器</h3>

<p>我们这里要使用<a href="https://zaach.github.io/jison/">jison</a>，jison是一个npm包，所以安装非常容易：</p>

<p><code>sh
npm install -g jison
</code></p>

<p>安装之后，你本地就会有一个命令行工具<code>jison</code>，这个工具可以将你定义的<code>jison</code>文件编译成一个<code>.js</code>文件，这个文件就是解释器的源码。我们先来定义一些<code>符号</code>(token)，所谓<code>token</code>就是上述的<code>终结符</code>：</p>

<h4>第一步：识别数字</h4>

<p>创建一个新的文本文件，假设就叫<code>calc.jison</code>，在其中定义一段这样的符号表:</p>

<p><code>js
\s+                   /* skip whitespace */
[0-9]+("."[0-9]+)?    return 'NUMBER'
&lt;&lt;EOF&gt;&gt;               return 'EOF'
.                     return 'INVALID'
</code></p>

<p>这里我们定义了4个符号，所有的空格（<code>\s+</code>），我们都跳过；如果遇到数字，则返回<code>NUMBER</code>；如果遇到文件结束，则返回<code>EOF</code>；其他的任意字符(.)都返回<code>INVALID</code>。</p>

<p>定义好符号之后，我们就可以编写<code>BNF</code>了：</p>

<p>```js
expressions</p>

<pre><code>: NUMBER EOF
    {
    console.log($1);
    return $1;
    }
;
</code></pre>

<p>```</p>

<p>这里我们定义了一条规则，即<code>expressions -&gt; NUMBER EOF</code>。在<code>jison</code>中，当匹配到规则之后，可以执行一个代码块，比如此处的输出语句<code>console.log($1)</code>。这个产生式的右侧有几个元素，就可以用<code>$加序号</code>来引用，如<code>$1</code>表示<code>NUMBER</code>实际对应的值，<code>$2</code>为<code>EOF</code>。</p>

<p>通过命令</p>

<p><code>sh
jison calc.jison
</code></p>

<p>可以在当前目录下生成一个<code>calc.js</code>文件，现在来创建一个文件<code>expr</code>，文件内容为一个数字，然后执行：</p>

<p><code>sh
node calc.js expr
</code></p>

<p>来测试我们的解释器：</p>

<p><code>sh
$ echo "3.14" &gt; expr
$ node calc.js expr
3.14
</code></p>

<p>目前我们完整的代码仅仅20行：</p>

<p>```js
/<em> lexical grammar </em>/
%lex
%%</p>

<p>\s+                   /<em> skip whitespace </em>/
[0-9]+("."[0-9]+)?    return 'NUMBER'
&lt;<EOF>>               return 'EOF'
.                     return 'INVALID'</p>

<p>/lex</p>

<p>%start expressions</p>

<p>%% /<em> language grammar </em>/</p>

<p>expressions</p>

<pre><code>: NUMBER EOF
    {
    console.log($1);
    return $1;
    }
;
</code></pre>

<p>```</p>

<h4>加法</h4>

<p>我们的解析器现在只能计算一个数字（输入给定的数字，给出同样的输出），我们来为它添加一条新的规则:加法。首先我们来扩展目前的BNF，添加一条新的规则：</p>

<p>```js
expressions</p>

<pre><code>: statement EOF
    {
    console.log($1);
    return $1;
    }
;
</code></pre>

<p>statement:
  NUMBER PLUS NUMBER
  {$$ = $1 + $3}
  |
  NUMBER
  {$$ = $1}
  ;
```</p>

<p>即，<code>expressions</code>由<code>statement</code>组成，而<code>statement</code>可以有两个规则规约得到，一个就是纯数字，另一个是<code>数字 加号 数字</code>，这里的<code>PLUS</code>是我们定义的一个新的符号：</p>

<p><code>js
"+"    return "PLUS"
</code></p>

<p>当输入匹配到规则<code>数字 加号 数字</code>时，对应的块<code>{$$ = $1 + $3}</code>会被执行，也就是说，两个<code>NUMBER</code>对应的值会加在一起，然后赋值给整个表达式的值，这样就完成了<strong>语义</strong>的翻译。</p>

<p>我们在文件<code>expr</code>中写入算式：<code>3.14+1</code>，然后测试：</p>

<p><code>sh
$ jison calc.jison
$ node calc.js expr
13.14
</code></p>

<p>嗯，结果有点不对劲，两个数字都被当成了字符串而拼接在一起了，这是因为JavaScript中，<code>+</code>的二义性和弱类型的自动转换导致的，我们需要做一点修改：</p>

<p><code>js
statement:
  NUMBER PLUS NUMBER
  {$$ = parseFloat($1) + parseFloat($3)}
  |
  NUMBER
  {$$ = $1}
  ;
</code></p>

<p>我们使用JavaScript内置的<code>parseFloat</code>将字符串转换为数字类型，再做加法即可：</p>

<p><code>sh
$ jison calc.jison
$ node calc.js expr
4.140000000000001
</code></p>

<h4>更多的规则</h4>

<p>剩下的事情基本就是把BNF翻译成<code>jison</code>的语法了：</p>

<p><code>
S -&gt; T + T | T - T | T
T -&gt; F * F | F / F | F
F -&gt; NUMBER | '(' S ')'
NUMBER -&gt;  0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</code></p>

<p>```js
expressions</p>

<pre><code>: statement EOF
    {
    console.log($1);
    return $1;
    }
;
</code></pre>

<p>statement:
  term PLUS term {$$ = $1 + $3}
  |
  term MINUS term {$$ = $1 - $3}
  |
  term {$$ = $1}
  ;</p>

<p>term:
  factor MULTIPLE factor {$$ = $1 * $3}
  |
  factor DIVIDE factor {$$ = $1 / $3}
  |
  factor {$$ = $1}
  ;</p>

<p>factor:
  NUMBER {$$ = parseFloat($1)}
  |
  LP statement RP {$$ = $2}
  ;</p>

<p>```</p>

<p>这样，像复杂一些的四则运算：<code>(10-2) * 3 + 2/4</code>，我们的计算器也已经有能力来计算出结果了：</p>

<p><code>sh
$ jison calc.jison
$ node calc.js expr
24.5
</code></p>

<h3>总结</h3>

<p>我们在本文中讨论了BNF和上下文无关文法，以及这些理论如何与工程实践联系起来。这里的<code>四则运算计算器</code>当然是一个很简单的例子，不过我们从中可以看到将<code>BNF</code>形式文法翻译成实际可以工作的代码是多么方便。我在后续的文章中会介绍<code>jison</code>更高级的用法，以及如何在实际项目中使用<code>jison</code>产生的解释器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[又一篇JavaScript的函数式编程教程]]></title>
    <link href="http://abruzzi.github.com/2015/05/functional-programming-again/"/>
    <updated>2015-05-23T17:37:00+08:00</updated>
    <id>http://abruzzi.github.com/2015/05/functional-programming-again</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>4月初在北京的时候，徐昊同学表示我们公司的同事们写的文章都太简单，太注重细节，然后捡起了芝麻丢了西瓜，于是我就不再更新博客（其实根本原因是项目太忙）。上周和其他几个同事一起参加“Martin Fowler深圳行”的活动，我和同事扎西贡献了一个《FullStack Language JavaScript》，一起的还有杨云（江湖人称大魔头）的话题是《掌握函数式编程，控制系统复杂度》，李新（江湖人称新爷）的话题是《并发：前生来世》。</p>

<p>和其他同事预演的时候，突然发现其实我们的主题或多或少都有些关联，我讲的部分也涉及到了基于事件的并发机制和函数式编程。仔细想想，应该与JavaScript本身的特性不无关系：</p>

<ol>
<li>基于事件（Event-Based）的Node.js的正是并发中很典型的一个模型</li>
<li>函数式编程使其天然支持回调，从而非常适合异步/事件机制</li>
<li>函数式编程特性使其非常适合DSL的编写</li>
</ol>


<p>会后的第二天，我在项目代码里忽然想要将一个聚合模型用函数式编程的方式重写一下，结果发现思路竟然与NoSQL依稀有些联系，进一步发现自己很多不足。</p>

<p>下面这个例子来自于实际项目中的场景，不过Domain做了切换，但是丝毫不影响阅读和理解背后的机制。</p>

<h3>一个书签应用</h3>

<p>设想有这样一个应用：用户可以看到一个订阅的RSS的列表。列表中的每一项（称为一个Feed），包含一个<code>id</code>，一个文章的标题<code>title</code>和一个文章的链接<code>url</code>。</p>

<p>数据模型看起来是这样的：</p>

<p>```js
var feeds = [</p>

<pre><code>{
    'id': 1,
    'url': 'http://abruzzi.github.com/2015/03/list-comprehension-in-python/',
    'title': 'Python中的 list comprehension 以及 generator'
},
{
    'id': 2,
    'url': 'http://abruzzi.github.com/2015/03/build-monitor-script-based-on-inotify/',
    'title': '使用inotify/fswatch构建自动监控脚本'
},
{
    'id': 3,
    'url': 'http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery/',
    'title': '使用underscore.js构建前端应用'
}
</code></pre>

<p>];
```</p>

<p>当这个简单应用没有任何用户相关的信息时，模型非常简单。但是很快，应用需要从单机版扩展到Web版，也就是说，我们引入了用户的概念。每个用户都能看到一个这样的列表。另外，用户还可以收藏Feed。当然，收藏之后，用户还可以查看收藏的Feed列表。</p>

<p><img src="/images/2015/05/bookmarks.png" alt="feed and user" /></p>

<p>由于每个用户可以收藏多个Feed，而每个Feed也可以被多个用户收藏，因此它们之间的多对多关系如上图所示。可能你还会想到诸如:</p>

<p><code>sh
$ curl http://localhost:9999/user/1/feeds
</code></p>

<p>来获取用户<code>1</code>的所有<code>feed</code>等，但是这些都不重要，真正的问题是，当你拿到了所有Feed之后，在UI上，需要为每个Feed填加一个属性<code>makred</code>。这个属性用来标示该feed是否已经被收藏了。对应到界面上，可能是一枚黄色的星星，或者一个红色的心。</p>

<p><img src="/images/2015/05/bookmarks-design-resized.png" alt="bookmarkds design" /></p>

<h4>服务器端聚合</h4>

<p>由于关系型数据库的限制，你需要在服务器端做一次聚合，比如将feed对象包装一下，生成一个<code>FeedWrapper</code>之类的对象：</p>

<p>```java
public class FeedWrapper {</p>

<pre><code>private Feed feed;
private boolean marked;

public boolean isMarked() {
    return marked;
}

public void setMarked(boolean marked) {
    this.marked = marked;
}

public FeedWrapper(Feed feed, boolean marked) {
    this.feed = feed;
    this.marked = marked;
}
</code></pre>

<p>}
```</p>

<p>然后定义一个<code>FeedService</code>之类的服务对象：</p>

<p>```java
public ArrayList<FeedWrapper> wrapFeed(List<Feed> markedFeeds, List<Feed> feeds) {</p>

<pre><code>return newArrayList(transform(feeds, new Function&lt;Feed, FeedWrapper&gt;() {
    @Override
    public FeedWrapper apply(Feed feed) {
        if (markedFeeds.contains(feed)) {
            return new FeedWrapper(feed, true);
        } else {
            return new FeedWrapper(feed, false);
        }
    }
}));
</code></pre>

<p>}
```</p>

<p>好吧，这也算是一个还凑合的实现，但是静态强类型的Java做这个事儿有点勉强，而且一旦发生新的变化（几乎肯定会发生），我们还是把这部分逻辑放在JavaScript中，来看看它是如何简化这一个过程的。</p>

<h4>客户端聚合</h4>

<p>快要说到主题了，这篇文章我们会使用<code>lodash</code>作为函数式编程的库来简化代码的编写。由于JavaScript是一个动态弱类型的语言，我们可以随时为一个对象添加属性，这样一个简单的<code>map</code>操作就可以完成上边的Java对应的代码了：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: isMarked(item.id)});
</code></pre>

<p>});
```</p>

<p>其中函数<code>isMarked</code>会做这样一件事儿：</p>

<p>```js
var userMarkedIds = [1, 2];
function isMarked(id) {</p>

<pre><code>return _.includes(userMarkedIds, id);
</code></pre>

<p>}
```</p>

<p>即查看传入的参数是否在一个列表<code>userMarkedIds</code>，这个列表可能由下列的请求来获得：</p>

<p><code>sh
$ curl http://localhost:9999/user/1/marked-feed-ids
</code></p>

<p>之所有只获取id是为了减少网络传输的数据大小，当然你也可以将全部的<code>/marked-feeds</code>都请求到，然后在本地做<code>_.pluck(feeds, 'id')</code>来抽取所有的<code>id</code>属性。</p>

<p>嗯，代码是精简了许多。但是如果仅仅能做到这一步的话，也没有多大的好处嘛。现在需求又有了变化，我们需要在另一个页面上展示当前用户的收藏夹（用以展示用户所有收藏的feed）。作为程序员，我们可不愿意重新写一套界面，如果能复用同一套逻辑当然最好了。</p>

<p>比如对于上面这个列表，我们已经有了对应的模板：</p>

<p>{% raw %}
```
{{#each feeds}}
<li class="list-item"></p>

<pre><code>&lt;div class="section" data-feed-id="{{this.id}}"&gt;
    {{#if this.marked}}
        &lt;span class="marked icon-favorite"&gt;&lt;/span&gt;
    {{else}}
        &lt;span class="unmarked icon-favorite"&gt;&lt;/span&gt;
    {{/if}}
    &lt;a href="http://abruzzi.github.com/feeds/{{this.url}}"&gt;
        &lt;div class="detail"&gt;
            &lt;h3&gt;{{this.title}}&lt;/h3&gt;
        &lt;/div&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p></li>
{{/each}}
```
{% endraw %}</p>

<p>事实上，这段代码在收藏夹页面上完全可以复用，我们只需要把所有的<code>marked</code>属性都设置为true就行了！简单，很快我们就可以写出对应的代码：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: true});
</code></pre>

<p>});
```</p>

<p>漂亮！而且重要的是，它还可以如正常工作！但是作为程序员，你很快就发现了两处代码的相似性：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: isMarked(item.id)});
</code></pre>

<p>});</p>

<p>_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: true});
</code></pre>

<p>});
```</p>

<p>消除重复是一个有追求的程序员的基本素养，不过要消除这两处貌似有点困难：位于<code>marked:</code>后边的，一个是函数调用，另一个是值！如果要简化，我们不得不做一个匿名函数，然后以回调的方式来简化：</p>

<p>```js
function wrapFeeds(feeds, predicate) {</p>

<pre><code>return _.map(feeds, function(item) {
    return _.extend(item, {marked: predicate(item.id)});
});
</code></pre>

<p>}
```</p>

<p>对于feed列表，我们要调用：</p>

<p><code>js
wrapFeeds(feeds, isMarked);
</code></p>

<p>而对于收藏夹，则需要传入一个匿名函数：</p>

<p><code>js
wrapFeeds(feeds, function(item) {return true});
</code></p>

<p>在<code>lodash</code>中，这样的匿名函数可以用<code>_.wrap</code>来简化：</p>

<p><code>js
wrapFeeds(feeds, _.wrap(true));
</code></p>

<p>好了，目前来看，简化的还不错，代码缩减了，而且也好读了一些（当然前提是你已经熟悉了函数式编程的读法）。</p>

<h4>更进一步</h4>

<p>如果仔细审视<code>isMarked</code>函数，会发现它对外部的依赖不是很漂亮（而且这个外部依赖是从网络异步请求来的），也就是说，我们需要在请求到<code>markedIds</code>的地方才能定义<code>isMarked</code>函数，这样就把函数定义<code>绑定</code>到了一个固定的地方，如果该函数的逻辑比较复杂，那么势必会影响代码的可维护性（或者更糟糕的是，多出维护）。</p>

<p>要将这部分代码隔离出去，我们需要将<code>ids</code>作为参数传递出去，并得到一个可以当做谓词（判断一个id是否在列表中的谓词）的函数。</p>

<p>简而言之，我们需要：</p>

<p><code>js
var predicate = createFunc(ids);
wrapFeeds(feeds, predicate);
</code></p>

<p>这里的<code>createFunc</code>函数接受一个列表作为参数，并返回了一个谓词函数。而这个谓词函数就是上边说的<code>isMarked</code>。这个神奇的过程被称为柯里化<code>currying</code>，或者偏函数<code>partial</code>。在<code>lodash</code>中，这个很容易实现：</p>

<p>```js
function isMarkedIn(ids) {</p>

<pre><code>return _.partial(_.includes, ids);
</code></pre>

<p>}
```</p>

<p>这个函数会将<code>ids</code>保存起来，当被调用时，它会被展开为：<code>_.includes(ids, &lt;id&gt;)</code>。只不过这个<code>&lt;id&gt;</code>会在实际迭代的时候才传入：</p>

<p>```js
$('/marked-feed-ids').done(function(ids) {</p>

<pre><code>var wrappedFeeds = wrapFeeds(feeds, isMarkedIn(ids));
console.log(wrappedFeeds);
</code></pre>

<p>});
```</p>

<p>这样我们的代码就被简化成了：</p>

<p>```js
$('/marked-feed-ids').done(function(ids) {</p>

<pre><code>var wrappedFeeds = wrapFeeds(feeds, isMarkedIn(ids));
var markedFeeds = wrapFeeds(feeds, _.wrap(true));

allFeedList.html(template({feeds: wrappedFeeds}));
markedFeedList.html(template({feeds: markedFeeds}));
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
</feed>
