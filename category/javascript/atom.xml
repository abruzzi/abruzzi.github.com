<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | I code it]]></title>
  <link href="http://abruzzi.github.com/category/javascript/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2015-05-23T22:39:47+10:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[又一篇JavaScript的函数式编程教程]]></title>
    <link href="http://abruzzi.github.com/2015/05/functional-programming-again/"/>
    <updated>2015-05-23T17:37:00+10:00</updated>
    <id>http://abruzzi.github.com/2015/05/functional-programming-again</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>4月初在北京的时候，徐昊同学表示我们公司的同事们写的文章都太简单，太注重细节，然后捡起了芝麻丢了西瓜，于是我就不再更新博客（其实根本原因是项目太忙）。上周和其他几个同事一起参加“Martin Fowler深圳行”的活动，我和同事扎西贡献了一个《FullStack Language JavaScript》，一起的还有杨云（江湖人称大魔头）的话题是《掌握函数式编程，控制系统复杂度》，李新（江湖人称新爷）的话题是《并发：前生来世》。</p>

<p>和其他同事预演的时候，突然发现其实我们的主题或多或少都有些关联，我讲的部分也涉及到了基于事件的并发机制和函数式编程。仔细想想，应该与JavaScript本身的特性不无关系：</p>

<ol>
<li>基于事件（Event-Based）的Node.js的正是并发中很典型的一个模型</li>
<li>函数式编程使其天然支持回调，从而非常适合异步/事件机制</li>
<li>函数式编程特性使其非常适合DSL的编写</li>
</ol>


<p>会后的第二天，我在项目代码里忽然想要将一个聚合模型用函数式编程的方式重写一下，结果发现思路竟然与NoSQL依稀有些联系，进一步发现自己很多不足。</p>

<p>下面这个例子来自于实际项目中的场景，不过Domain做了切换，但是丝毫不影响阅读和理解背后的机制。</p>

<h3>一个书签应用</h3>

<p>设想有这样一个应用：用户可以看到一个订阅的RSS的列表。列表中的每一项（称为一个Feed），包含一个<code>id</code>，一个文章的标题<code>title</code>和一个文章的链接<code>url</code>。</p>

<p>数据模型看起来是这样的：</p>

<p>```js
var feeds = [</p>

<pre><code>{
    'id': 1,
    'url': 'http://abruzzi.github.com/2015/03/list-comprehension-in-python/',
    'title': 'Python中的 list comprehension 以及 generator'
},
{
    'id': 2,
    'url': 'http://abruzzi.github.com/2015/03/build-monitor-script-based-on-inotify/',
    'title': '使用inotify/fswatch构建自动监控脚本'
},
{
    'id': 3,
    'url': 'http://abruzzi.github.com/2015/02/build-sample-application-by-using-underscore-and-jquery/',
    'title': '使用underscore.js构建前端应用'
}
</code></pre>

<p>];
```</p>

<p>当这个简单应用没有任何用户相关的信息时，模型非常简单。但是很快，应用需要从单机版扩展到Web版，也就是说，我们引入了用户的概念。每个用户都能看到一个这样的列表。另外，用户还可以收藏Feed。当然，收藏之后，用户还可以查看收藏的Feed列表。</p>

<p><img src="/images/2015/05/bookmarks.png" alt="feed and user" /></p>

<p>由于每个用户可以收藏多个Feed，而每个Feed也可以被多个用户收藏，因此它们之间的多对多关系如上图所示。可能你还会想到诸如:</p>

<p><code>sh
$ curl http://localhost:9999/user/1/feeds
</code></p>

<p>来获取用户<code>1</code>的所有<code>feed</code>等，但是这些都不重要，真正的问题是，当你拿到了所有Feed之后，在UI上，需要为每个Feed填加一个属性<code>makred</code>。这个属性用来标示该feed是否已经被收藏了。对应到界面上，可能是一枚黄色的星星，或者一个红色的心。</p>

<p><img src="/images/2015/05/bookmarks-design-resized.png" alt="bookmarkds design" /></p>

<h4>服务器端聚合</h4>

<p>由于关系型数据库的限制，你需要在服务器端做一次聚合，比如将feed对象包装一下，生成一个<code>FeedWrapper</code>之类的对象：</p>

<p>```java
public class FeedWrapper {</p>

<pre><code>private Feed feed;
private boolean marked;

public boolean isMarked() {
    return marked;
}

public void setMarked(boolean marked) {
    this.marked = marked;
}

public FeedWrapper(Feed feed, boolean marked) {
    this.feed = feed;
    this.marked = marked;
}
</code></pre>

<p>}
```</p>

<p>然后定义一个<code>FeedService</code>之类的服务对象：</p>

<p>```java
public ArrayList<FeedWrapper> wrapFeed(List<Feed> markedFeeds, List<Feed> feeds) {</p>

<pre><code>return newArrayList(transform(feeds, new Function&lt;Feed, FeedWrapper&gt;() {
    @Override
    public FeedWrapper apply(Feed feed) {
        if (markedFeeds.contains(feed)) {
            return new FeedWrapper(feed, true);
        } else {
            return new FeedWrapper(feed, false);
        }
    }
}));
</code></pre>

<p>}
```</p>

<p>好吧，这也算是一个还凑合的实现，但是静态强类型的Java做这个事儿有点勉强，而且一旦发生新的变化（几乎肯定会发生），我们还是把这部分逻辑放在JavaScript中，来看看它是如何简化这一个过程的。</p>

<h4>客户端聚合</h4>

<p>快要说到主题了，这篇文章我们会使用<code>lodash</code>作为函数式编程的库来简化代码的编写。由于JavaScript是一个动态弱类型的语言，我们可以随时为一个对象添加属性，这样一个简单的<code>map</code>操作就可以完成上边的Java对应的代码了：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: isMarked(item.id)});
</code></pre>

<p>});
```</p>

<p>其中函数<code>isMarked</code>会做这样一件事儿：</p>

<p>```js
var userMarkedIds = [1, 2];
function isMarked(id) {</p>

<pre><code>return _.includes(userMarkedIds, id);
</code></pre>

<p>}
```</p>

<p>即查看传入的参数是否在一个列表<code>userMarkedIds</code>，这个列表可能由下列的请求来获得：</p>

<p><code>sh
$ curl http://localhost:9999/user/1/marked-feed-ids
</code></p>

<p>之所有只获取id是为了减少网络传输的数据大小，当然你也可以将全部的<code>/marked-feeds</code>都请求到，然后在本地做<code>_.pluck(feeds, 'id')</code>来抽取所有的<code>id</code>属性。</p>

<p>嗯，代码是精简了许多。但是如果仅仅能做到这一步的话，也没有多大的好处嘛。现在需求又有了变化，我们需要在另一个页面上展示当前用户的收藏夹（用以展示用户所有收藏的feed）。作为程序员，我们可不愿意重新写一套界面，如果能复用同一套逻辑当然最好了。</p>

<p>比如对于上面这个列表，我们已经有了对应的模板：</p>

<p>
```
{{#each feeds}}
<li class="list-item"></p>

<pre><code>&lt;div class="section" data-feed-id="{{this.id}}"&gt;
    {{#if this.marked}}
        &lt;span class="marked icon-favorite"&gt;&lt;/span&gt;
    {{else}}
        &lt;span class="unmarked icon-favorite"&gt;&lt;/span&gt;
    {{/if}}
    &lt;a href="http://abruzzi.github.com/feeds/{{this.url}}"&gt;
        &lt;div class="detail"&gt;
            &lt;h3&gt;{{this.title}}&lt;/h3&gt;
        &lt;/div&gt;
    &lt;/a&gt;
&lt;/div&gt;
</code></pre>

<p></li>
{{/each}}
```
</p>

<p>事实上，这段代码在收藏夹页面上完全可以复用，我们只需要把所有的<code>marked</code>属性都设置为true就行了！简单，很快我们就可以写出对应的代码：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: true});
</code></pre>

<p>});
```</p>

<p>漂亮！而且重要的是，它还可以如正常工作！但是作为程序员，你很快就发现了两处代码的相似性：</p>

<p>```js
_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: isMarked(item.id)});
</code></pre>

<p>});</p>

<p>_.map(feeds, function(item) {</p>

<pre><code>return _.extend(item, {marked: true});
</code></pre>

<p>});
```</p>

<p>消除重复是一个有追求的程序员的基本素养，不过要消除这两处貌似有点困难：位于<code>marked:</code>后边的，一个是函数调用，另一个是值！如果要简化，我们不得不做一个匿名函数，然后以回调的方式来简化：</p>

<p>```js
function wrapFeeds(feeds, predicate) {</p>

<pre><code>return _.map(feeds, function(item) {
    return _.extend(item, {marked: predicate(item.id)});
});
</code></pre>

<p>}
```</p>

<p>对于feed列表，我们要调用：</p>

<p><code>js
wrapFeeds(feeds, isMarked);
</code></p>

<p>而对于收藏夹，则需要传入一个匿名函数：</p>

<p><code>js
wrapFeeds(feeds, function(item) {return true});
</code></p>

<p>在<code>lodash</code>中，这样的匿名函数可以用<code>_.wrap</code>来简化：</p>

<p><code>js
wrapFeeds(feeds, _.wrap(true));
</code></p>

<p>好了，目前来看，简化的还不错，代码缩减了，而且也好读了一些（当然前提是你已经熟悉了函数式编程的读法）。</p>

<h4>更进一步</h4>

<p>如果仔细审视<code>isMarked</code>函数，会发现它对外部的依赖不是很漂亮（而且这个外部依赖是从网络异步请求来的），也就是说，我们需要在请求到<code>markedIds</code>的地方才能定义<code>isMarked</code>函数，这样就把函数定义<code>绑定</code>到了一个固定的地方，如果该函数的逻辑比较复杂，那么势必会影响代码的可维护性（或者更糟糕的是，多出维护）。</p>

<p>要将这部分代码隔离出去，我们需要将<code>ids</code>作为参数传递出去，并得到一个可以当做谓词（判断一个id是否在列表中的谓词）的函数。</p>

<p>简而言之，我们需要：</p>

<p><code>js
var predicate = createFunc(ids);
wrapFeeds(feeds, predicate);
</code></p>

<p>这里的<code>createFunc</code>函数接受一个列表作为参数，并返回了一个谓词函数。而这个谓词函数就是上边说的<code>isMarked</code>。这个神奇的过程被称为柯里化<code>currying</code>，或者偏函数<code>partial</code>。在<code>lodash</code>中，这个很容易实现：</p>

<p>```js
function isMarkedIn(ids) {</p>

<pre><code>return _.partial(_.includes, ids);
</code></pre>

<p>}
```</p>

<p>这个函数会将<code>ids</code>保存起来，当被调用时，它会被展开为：<code>_.includes(ids, &lt;id&gt;)</code>。只不过这个<code>&lt;id&gt;</code>会在实际迭代的时候才传入：</p>

<p>```js
$('/marked-feed-ids').done(function(ids) {</p>

<pre><code>var wrappedFeeds = wrapFeeds(feeds, isMarkedIn(ids));
console.log(wrappedFeeds);
</code></pre>

<p>});
```</p>

<p>这样我们的代码就被简化成了：</p>

<p>```js
$('/marked-feed-ids').done(function(ids) {</p>

<pre><code>var wrappedFeeds = wrapFeeds(feeds, isMarkedIn(ids));
var markedFeeds = wrapFeeds(feeds, _.wrap(true));

allFeedList.html(template({feeds: wrappedFeeds}));
markedFeedList.html(template({feeds: markedFeeds}));
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Sublime Text中设置JavaScript构建]]></title>
    <link href="http://abruzzi.github.com/2014/12/setup-sublime-as-javascript-development-env/"/>
    <updated>2014-12-21T18:52:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/12/setup-sublime-as-javascript-development-env</id>
    <content type="html"><![CDATA[<p>我在编写<a href="http://book.douban.com/subject/24165880/">《JavaScript核心概念及实践》</a>一书的时候，为了保证读者学习时可以比较专注语言本身，专门用Swing开发了一个小工具<a href="https://github.com/abruzzi/jsevaluator">JSEvaluator</a>。</p>

<p>这个工具可以当做JavaScript的简单的IDE，有一个编辑区域，有一些按钮(打开，保存，执行等)，执行之后还可以将结果显示在一个面板上。书出版后不断有读者问我如何将这个工具运行起来（我自己写这个工具的时候，并没有release的概念，而且最初的几个版本可用之后，就再也没有花心思维护），单独回复比较耗时，今天早上又收到一位热心读者的邮件，就在这里统一回复一下。</p>

<p>其实JSEvaluator的思想和其他的IDE一样：将一个编辑器和命令行工具结合在一起，编辑器提供编辑功能，然后IDE可以将编辑器中的文本发送给命令行工具执行（使用Rhino），将结果重定向到界面上。</p>

<p><a href="http://www.sublimetext.com/3">Sublime Text</a>提供的<code>Build</code>功能也可以做到这一点，并且可以使用它更加强大的其他编辑特性，因此推荐各位读者使用这里介绍的方式。</p>

<h3>Sublime Text编辑器</h3>

<p><a href="http://www.sublimetext.com/3">Sublime Text</a>是一个文本编辑器，非常轻量级，并且有丰富的插件机制。虽然它不是一个免费软件，但是如果不注册还是可以无限试用下去，除了不定时的弹出一个对话框之外。它在现在的前端开发中非常流行，我作为一个<code>Vim</code>的忠实粉丝，也已经花费了很多时间在Sublime Text上了。</p>

<p>在写书的时候，JavaScript已经比较火了，但是更多的是在Web端。在本地开发的支持上还是比较薄弱。但是现在就不一样了，各个操作系统平台上都已经有了许多本地的JavaScript执行环境。比如Mac自带的<code>jsc</code>，跨平台的<a href="http://nodejs.org/">node</a>等。</p>

<h4>准备工作</h4>

<p>如果你在使用Mac OS X，请直接跳到下一步。如果你在使用Windows，请先安装node.js的Windows版本，然后保证<code>node.exe</code>在系统的PATH环境变量中。</p>

<h4>自定义build</h4>

<p>在Sublime Text中，点击<code>Tools</code> -> <code>Build System</code> -> <code>New build system...</code>，Sublime会打开一个文件，我们来编辑这个文件：</p>

<p>```json
{</p>

<pre><code>"cmd": ["jsc", "$file"],
"selector": "source.js"
</code></pre>

<p>}
```</p>

<p>上边这个命令指定了这个build使用的命令是<code>jsc</code>。如果你在Windows下使用<code>node</code>，那么对应的这个文件应该写成：</p>

<p>```json
{</p>

<pre><code>"cmd": ["node", "$file"],
"selector": "source.js"
</code></pre>

<p>}
```</p>

<p>如果<code>node.exe</code>不在环境变量PATH中，请保证将其加入。完成这个文件的编辑之后，将其保存为<code>JavaScript.sublime-build</code>文件（Sublime会提示你输入文件名，因此输入JavaScript即可）。</p>

<h4>开始开发</h4>

<p>接下来你就可以在Sublime中开发并编译JavaScript代码了，应该注意的是，如果你使用的是<code>jsc</code>，那么<code>console.log</code>这样的函数式不能直接使用的，不过你可以很容易的将其重新定义：</p>

<p><code>js
var console = console || {};
console.log = debug;
</code></p>

<p>这里的<code>debug</code>是<code>Sublime</code>提供的输出函数，它将会把结果输出在Sublime的控制台上。</p>

<p><img src="/images/2014/12/sublime-text-jsc-resized.png" alt="Sublime Text Build JavaScript" /></p>

<p>运行构建的快捷键，在Mac OS X下为(<code>Cmd+B</code>)，Windows下为(<code>Ctrl+B</code>)。运行之后，可以看到在编辑器的底部会有一个小的窗口打开，里边的内容就是执行结果了。</p>

<h4>其他资料</h4>

<ol>
<li>这里有一个<a href="http://calebgrove.com/articles/js-console-sublime-text">英文版</a>，这里是<a href="http://www.wikihow.com/Create-a-Javascript-Console-in-Sublime-Text">另一个</a></li>
<li>这里有一个<a href="https://cnodejs.org/topic/51ee453af4963ade0ebde85e">中文版</a>，以及它的<a href="http://www.hacke2.cn/nodeJS-sublime-3/">补充</a></li>
</ol>


<p>Note：由于我自己不使用<code>Windows</code>平台，也不推荐其他开发者使用，因此关于Windows的部分并没有经过认真测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个关于时间的神奇Bug]]></title>
    <link href="http://abruzzi.github.com/2014/09/a-bug-about-time/"/>
    <updated>2014-09-04T22:37:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/09/a-bug-about-time</id>
    <content type="html"><![CDATA[<h3>一个神奇的Bug</h3>

<p>目前项目是一个非常传统的Web应用，其中有个页面需要用户填写自己的个人信息，包括姓名和出生日期。非常简单的一个小片段，UI看起来是这个样子的：</p>

<p><img src="/images/2014/09/personal-resized.png" alt="image" /></p>

<p>没有使用现成的<code>datepicker</code>，某个开发人员只是简单的自己收集了一下年，月，日信息，然后在JavaScript中根据填写的值来<code>new</code>了一个Date对象。</p>

<p>然后某天我在做测试的时候，顺手填写了一个日期<code>1986年5月4日</code>，然后奇怪的事情发生了：</p>

<p><img src="/images/2014/09/invalid-date-resized.png" alt="image" /></p>

<p><strong>WTF?</strong>，这日期怎么会是非法的呢？于是我又尝试了<code>1986年5月3日</code>和<code>1986年5月5日</code>，一切正常！好奇之下，我找到对应的代码：</p>

<p>```js
var dobDay = parseInt($("#personal\.dobDay").val(), 10);
var dobMonth = parseInt($("#personal\.dobMonth").val(), 10);
var dobYear = parseInt($("#personal\.dobYear").val(), 10);</p>

<p>// Note month is not zero based.
var dob = null;
if (dobDay > 0 &amp;&amp; dobMonth > 0 &amp;&amp; dobYear > 0) {</p>

<pre><code>dob = new Date(dobYear, dobMonth - 1, dobDay, 0, 0, 0, 0);
</code></pre>

<p>}</p>

<p>if (dob === null || dob.getDate() !== dobDay) {</p>

<pre><code>valid = false;
$("#dob-error").html(this.formMessages.invalidDate);
</code></pre>

<p>}
```</p>

<p>从界面上获取用户输入的年，月，日信息，然后根据这三个数字创建一个JavaScript对象。但是奇怪的是，这里有一条判断<code>dob.getDate() !== dobDay</code>。</p>

<h3>JavaScript的日期类</h3>

<p>JavaScript中的日期类比较奇葩，你可以通过将年月日传入<code>new Date()</code>来构造出一个新的日期类型，奇葩之处在于，年和日都是从1开始计数，但是月份是从0开始计数的，比如<code>new Date(2014, 1, 2)</code>表示2014年<strong>2月</strong>2日。</p>

<p>那么，我们可以在Chrome的Console中查看一下神奇的<code>1986年5月4日</code></p>

<p>```js</p>

<blockquote><p>new Date(1986, 4, 4)
Sat May 03 1986 23:00:00 GMT+0800 (CST)
```</p></blockquote>

<p>WTF? 我好好的5月4日怎么变成5月3日了呢？加上时分秒之后，逐步缩小排查范围：</p>

<p>```js</p>

<blockquote><p>new Date(1986, 4, 4, 0, 59, 59, 0)
Sat May 03 1986 23:59:59 GMT+0800 (CST)</p>

<p>new Date(1986, 4, 4, 0, 59, 59, 1000)
Sun May 04 1986 01:00:00 GMT+0900 (CDT)
```</p></blockquote>

<p>这时候发现，当秒针通过<code>1986年5月3日的23点59分59秒</code>之后，时间就变成了<code>1986年5月4日的1点0分0秒</code>了！这个奇葩至极的问题是由于传说中的<strong>夏令时</strong>所致！</p>

<h3>夏令时</h3>

<p>其实常年和澳洲客户打交道，对日光节约时间(Daylight saving time)已经不陌生，不过澳洲在南半球冬夏正好和中国相反，因此完全没有将其当成日常的一部分。</p>

<p>维基上的解释比较专业：</p>

<blockquote><p>夏时制或夏令时间（英语：Summer time），又称日光节约时制、日光节约时间（英语：Daylight saving time），是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。一般在天亮早的夏季人为将时间提前一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同。</p></blockquote>

<p>即，在夏天的某天（天亮的比较早），将时钟调快一个小时，以便大家起床更早，然后可以节省一些照明用电，然后在冬天的时候（天亮的比较晚）又调回去</p>

<p><img src="/images/2014/09/dst.png" alt="image" /></p>

<p>根据百度百科上的描述：</p>

<blockquote><p>1986年至1991年，中华人民共和国在全国范围实行了六年夏令时，每年从4月中旬的第一个星期日2时整（北京时间）到9月中旬第一个星期日的凌晨2时整（北京夏令时）。除1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束外，其它年份均按规定的时段施行。夏令时实施期间，将时间调快一小时。1992年4月5日后不再实行。</p></blockquote>

<p><code>1986年的5月4日</code>这个特别的日期终于显现出了其特殊之处了。</p>

<p>有了这个认识，我将系统时间设置为了澳洲标准时间，然后测试:</p>

<p>```js</p>

<blockquote><p>new Date(2014, 9, 5, 2, 59, 59, 0)
Sun Oct 05 2014 01:59:59 GMT+1000 (EST)</p>

<p>new Date(2014, 9, 5, 2, 59, 59, 1000)
Sun Oct 05 2014 03:00:00 GMT+1100 (EST)
```</p></blockquote>

<p>如果观察足够细致的话会发现GMT后边的这个数字的变化，GMT是(Greenwish Mean Time)格林尼治标准时间的缩写，它最初是国际公认的时间基准线，地理上位于其东方的各个时区会加上一个偏移量，比如中国就是GMT+8，而澳洲就是GMT+10，而一旦进入夏令时，由于时钟拨快了一个小时，因此就会变成GMT+9/GMT+11。</p>

<p>```js</p>

<blockquote><p>new Date(1986, 4, 4, 0, 59, 59, 0)
Sat May 03 1986 23:59:59 GMT+0800 (CST)</p>

<p>new Date(1986, 4, 4, 0, 59, 59, 1000)
Sun May 04 1986 01:00:00 GMT+0900 (CDT)
```</p></blockquote>

<p>比如今年的巴西：</p>

<p>```js</p>

<blockquote><p>new Date(2014, 9, 19)
Sat Oct 18 2014 23:00:00 GMT-0300 (BRT)
```</p></blockquote>

<h3>其他</h3>

<p>大部分实行夏令时的国家都会将这个调整放到凌晨两点，而不是零点，其中的一个原因应该就是避免出现这种状况。但是由于巴西还是将这个调整放到了凌晨，那么这个日期还是会出现<code>非法日期</code>这样的错误：</p>

<p><img src="/images/2014/09/invalid-date-brasil-resized.png" alt="image" /></p>

<h3>解决方法</h3>

<p>最简单的解决方法就是存储最简单，而且无歧义的年月日字符处，比如'1986-05-04'，而不是通过保存成一个JavaScript的Date对象的方式。</p>

<p>或者也可以使用一个Datepicker控件来获取日期字符串，然后保存：</p>

<p><img src="/images/2014/09/date-picker-resized.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全球地震信息的可视化（使用OpenLayers）]]></title>
    <link href="http://abruzzi.github.com/2014/04/render-geojson-by-using-openlayers/"/>
    <updated>2014-04-15T21:33:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/04/render-geojson-by-using-openlayers</id>
    <content type="html"><![CDATA[<h4>OpenLayers</h4>

<p>使用<a href="http://openlayers.org/">OpenLayers</a>可以很容易的搭建基于Web的GIS系统，OpenLayers支持不同的数据源(符合WMS协议的服务器，Google Maps API, Bing Maps，KML以及<a href="http://geojson.org/">GeoJSON</a>等等)。通过将不同的数据源的数据整合，我们可以开发出丰富而用户友好的GIS系统。</p>

<p>OpenLayers可以轻松的处理GeoJSON数据，并将其生成矢量层，我们可以将这个层叠加在其他数据源（比如OSM）提供的地图上，以得到一个完整的小应用。</p>

<p>最后的运行结果是这样的：</p>

<p><img src="/images/2014/04/openlayers-earthquake-resized.png" alt="image" /></p>

<h4>GeoJSON</h4>

<p><a href="http://www.usgs.gov/aboutusgs/">美国地理信息调查局</a>是一个科学组织，他公开了很多地球上的灾难信息，比如对地震的统计，并提供编程接口。它公开的地震统计信息，包含全世界各地报告过的地震，以及全美所有检测到的地震，并以多种周期（小时，天，周，月等），多种格式（GeoJSON，KML，Atom等），以便应用程序的开发者只用这些数据。</p>

<h4>实现</h4>

<h5>设置基本环境</h5>

<p>我们将借助bower来安装所有的代码依赖。首先，我们需要bower将所有的包都安装在<code>components</code>目录下，这个可以通过在当前目录的<code>.bowerrc</code>文件中制定<code>directory</code>：</p>

<p>```json
{</p>

<pre><code>"directory": "components"
</code></pre>

<p>}
```</p>

<p>然后运行bower安装jquery以及openlayers：</p>

<p><code>sh
$ bower install jquery
$ bower install openlayers
</code></p>

<p>通过bower安装OpenLayers之后，可以通过OpenLayers自带的build工具将所有的源码合并压缩为一个文件：</p>

<p><code>sh
$ cd components/openlayers/build
$ ./build.py #将会在当前目录下生成一个OpenLayers.js的文件
$ mv OpenLayers.js ../
</code></p>

<p>然后，创建一个简单的HTML文件，引用jquery.js和OpenLayers.js，以及我们的入口脚本app.js，本文所有的代码都只是修改这个文件。</p>

<p>```html
&lt;!DOCTYPE HTML>
<html></p>

<pre><code>&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;Earthquake distribution&lt;/title&gt;
    &lt;link rel="stylesheet" href="style.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;
        &lt;div id="map"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="components/jquery/jquery.js" type="text/javascript"&gt;&lt;/script&gt;        
    &lt;script src="components/openlayers/OpenLayers.js" type="text/javascript"&gt;&lt;/script&gt;        
    &lt;script src="app.js" type="text/javascript"&gt;&lt;/script&gt;        
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>还可以运行<code>bower init</code>来将生成<code>bower.json</code>，以方便别人使用我们的应用：</p>

<p><code>js
$ bower init
</code></p>

<h5>基本代码</h5>

<p>一个最简单的OpenLayers应用，只需要7行代码：</p>

<p>```js
$(function() {</p>

<pre><code>var map = new OpenLayers.Map("map");
var osm = new OpenLayers.Layer.OSM();

map.addLayers([osm]);
map.zoomToMaxExtent();
</code></pre>

<p>});
```</p>

<p>这段代码在id为<code>map</code>的HTML元素创建了一个地图，这个地图上有一个叫OSM的层（即<a href="http://www.openstreetmap.org/">OpenStreetMap</a>，一个开源，开放的地图平台），并将地图缩小到边界范围（以获得最大的视野）:</p>

<p><img src="/images/2014/04/openlayers-osm-resized.png" alt="image" /></p>

<h5>生成矢量层</h5>

<p>通过GeoJSON生成矢量图非常容易：</p>

<p>```js
var geo = new OpenLayers.Layer.Vector("EarthQuake", {</p>

<pre><code>strategies: [new OpenLayers.Strategy.Fixed()],
protocol: new OpenLayers.Protocol.HTTP({
    url: '/all_day.geojson',
    format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true})
})
</code></pre>

<p>});
```</p>

<p>注意此处的<a href="http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson">all_day.geojson</a>是从USGS网站上下载的，过去一天中世界各地的所有地震统计。</p>

<p>上边的代码创建了一个名称为<code>EarthQuake</code>的矢量层，<code>strategies</code>中的Fixed策略表示仅请求一次资源，然后缓存在前端，不再请求。<code>protocol</code>表明数据来源为<code>all_day.geojson</code>，格式为<code>OpenLayers.Format.GeoJSON</code>。由于USGS返回的地理信息除了经纬度还包含深度，而OpenLayers默认只处理经纬度的，因此需要此处的<code>ignoreExtraDims</code>来忽略那个额外的深度信息。</p>

<p><img src="/images/2014/04/openlayers-geojson-resized.png" alt="image" /></p>

<h5>定制样式</h5>

<p>虽然我们已经加上了新的层，也可以看到很多表示地震的点信息，但是并不能看出哪些地震是严重的，比如里氏3级以下的地震，几乎没有危害，可以标注成一种颜色；而更高震级的可以标记成另外一种颜色。</p>

<p>OpenLayers可以很容易的做到这个定制化:</p>

<p>```js</p>

<pre><code>var style = new OpenLayers.Style();

var ruleLow = new OpenLayers.Rule({
  filter: new OpenLayers.Filter.Function({
        evaluate: function(properties) {
            return properties.mag &lt; 3.0;
        }
    }),
  symbolizer: {pointRadius: 3, fillColor: "green",
               fillOpacity: 0.5, strokeColor: "black"}
});

var ruleHigh = new OpenLayers.Rule({
  filter: new OpenLayers.Filter.Function({
        evaluate: function(properties) {
            return properties.mag &gt;= 3.0;
        }
    }),
    symbolizer: {pointRadius: 5, fillColor: "red",
               fillOpacity: 0.7, strokeColor: "black"}
});

style.addRules([ruleLow, ruleHigh]);

geo.styleMap = new OpenLayers.StyleMap(style);
</code></pre>

<p>```</p>

<p>首先创建一个Style对象，为Style添加两条规则Rule，然后将Style对象包装成StyleMap并赋值给表示地震的矢量层<code>earthquake</code>。</p>

<p>对于规则ruleLow，我们定义了，当一个feature的属性值mag(震级)小于三的时候后，使用绿色的，半径为3px的小圆圈来表示。而ruleHigh则定义了当震级大于等于三的时候，用红色，半径为5px的圆圈来表示。</p>

<p><img src="/images/2014/04/openlayers-geojson-styling-resized.png" alt="image" /></p>

<h5>加上事件处理</h5>

<p>虽然我们已经可以直观的根据震级不同而看到不同颜色的点，但是整个应用仍然没有多少意义：它不具备于用户的交互能力。我们需要添加上事件处理，当用户点击地图上的一个圆点的时候，应该看到一个更详细的窗口。</p>

<p>```js
var selectControl = new OpenLayers.Control.SelectFeature(geo, {</p>

<pre><code>onSelect: onFeatureSelect,
onUnselect: onFeatureUnselect 
</code></pre>

<p>});</p>

<p>map.addControl(selectControl);
selectControl.activate();</p>

<p>function onFeatureSelect(feature) {</p>

<pre><code>var html = "&lt;span&gt;"+feature.attributes.title+"&lt;/span&gt;";

var popup = new OpenLayers.Popup.FramedCloud("popup",
        feature.geometry.getBounds().getCenterLonLat(),
        null,
        html,
        null,
        true
    );

popup.panMapIfOutOfView = true;
popup.autoSize = true;

feature.popup = popup;

map.addPopup(popup);
</code></pre>

<p>}</p>

<p>function onFeatureUnselect(feature) {</p>

<pre><code>map.removePopup(feature.popup);
feature.popup.destroy();
feature.popup = null;
</code></pre>

<p>}
```</p>

<p>我们在地图上添加了一个<code>SelectFeature</code>元素，并注册了回调函数：当矢量层中的矢量被选中之后，函数<code>onFeatureSelect</code>将被执行，我们可以在这个函数中添加对弹出窗口的控制。当<code>onFeatureSelect</code>执行时，OpenLayers会将当前的Feature传递进来，我们可以动态的取得震级，标题，链接等信息，并展现给最终用户。</p>

<p><img src="/images/2014/04/openlayers-geojson-popup-resized.png" alt="[image]" /></p>

<p>如果将数据源扩大到本周的所有地震：</p>

<p>```js
var geo = new OpenLayers.Layer.Vector("EarthQuake", {</p>

<pre><code>strategies: [new OpenLayers.Strategy.Fixed()],
protocol: new OpenLayers.Protocol.HTTP({
    url: '/all_week.geojson',
    format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true})
})
</code></pre>

<p>});
```</p>

<p><img src="/images/2014/04/openlayers-geojson-weekly-resized.png" alt="image" /></p>

<p>完整的代码示例<a href="https://github.com/abruzzi/earthquake-viz">可以看这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建地图服务器（使用Mapnik）]]></title>
    <link href="http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik/"/>
    <updated>2014-04-12T14:07:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik</id>
    <content type="html"><![CDATA[<h4>渲染引擎Mapnik</h4>

<p><a href="http://icodeit.org/2014/04/intro-map-gis/">上一篇文章</a>中大概介绍了<a href="https://github.com/mapnik">Mapnik</a>，它是一个渲染引擎，一般开发中都会使用他的python的bind做开发。</p>

<p>Mapnik的文档写的比较详细，我们这里只是做一些必要的介绍，详细的细节可以参看Mapnik在<a href="https://github.com/mapnik/mapnik/wiki">Github上的文档</a>。</p>

<p>在Mac下，安装Mapnik十分容易，使用brew即可，注意我们在此处带上<code>--with-postgresql</code>选项，使得Mapnik可以通过PostGIS来访问数据库：</p>

<p><code>sh
brew install mapnik --with-postgresql
</code></p>

<p>安装完成之后，可以通过一个小的python脚本来测试：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(256, 256)
map.background = mapnik.Color('red')
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'red.png', 'png')
```</p>

<p>这段脚本可以在当前目录下生成一个红色的256x256的小图片。好了，有了渲染引擎，我们需要一些数据来进行渲染了。</p>

<h4>数据源</h4>

<p>最通用的数据格式为Shapefiles，目前有很多的免费地理信息供公共下载，我们可以从<a href="http://metro.teczno.com/">Metro的站点</a>上下载一些小的数据文件。</p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm2pgsql-shapefiles.zip
$ mkdir chengdu
$ cd chengdu
$ unzip chengdu.osm2pgsql-shapefiles.zip
</code>
这样就得到了一组文件：</p>

<p><code>
$ find . -name "*.shp"
./chengdu.osm-line.shp
./chengdu.osm-point.shp
./chengdu.osm-polygon.shp
</code></p>

<p>每一个shp文件都会对应几个其他类型的文件，比如投影信息，属性表等。仅仅查看shp的话，有表示所有点的文件chengdu.osm-line.shp，又表示所有线的chengdu.osm-line.shp，以及表示所有面（区域）的chengdu.osm-polygon.shp文件。</p>

<p>有了这些文件，我们就可以做一些测试了，比如我们首先加载所有的线条，并根据这些线条生成一个图层：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(800, 800)
map.background = mapnik.Color('#ffffff')</p>

<p>style = mapnik.Style()
rule = mapnik.Rule()</p>

<p>point_symbolizer = mapnik.PointSymbolizer()
rule.symbols.append(point_symbolizer)</p>

<p>style.rules.append(rule)</p>

<p>map.append_style('default', style)</p>

<p>ds_point = mapnik.Shapefile(file='chengdu.osm-point.shp')
point = mapnik.Layer('point')
point.datasource = ds_point
point.styles.append('default')</p>

<p>map.layers.append(point)
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'chengdu.png', 'png')
```</p>

<p>可以得到：</p>

<p><img src="/images/2014/04/chengdu-point.png" alt="points" /></p>

<p>这里介绍一下Mapnik中的一些概念：一个Map可以包含若干个层（Layer），每个层可以独立着色，即可以为每个层定制样式（Style），每个样式由若干个规则组成（Rule）。每个规则由是由若干个符号定制。</p>

<p><img src="/images/2014/04/chengdu-line.png" alt="lines" /></p>

<p>如果将两者重叠，则可以得到：</p>

<p><img src="/images/2014/04/chengdu-point-and-line.png" alt="lines" /></p>

<p>```python
polygon_symbolizer = mapnik.PolygonSymbolizer(mapnik.Color('#c8102e'))
polygon_rule.symbols.append(polygon_symbolizer)</p>

<p>ds_polygon = mapnik.Shapefile(file='chengdu.osm-polygon.shp')
polygon = mapnik.Layer('polygon')
polygon.datasource = ds_polygon
polygon.styles.append('polygon')</p>

<p>map.layers.append(polygon)
```</p>

<p><img src="/images/2014/04/chengdu-polygon.png" alt="image" /></p>

<p>将这三个层叠加在一起，会得到最终的结果：</p>

<p><img src="/images/2014/04/chengdu-point-and-line-and-polygon.png" alt="lines" /></p>

<h4>数据转化</h4>

<p>在进一步之前，我们需要将数据存储在数据库中。我们可以将shapefile通过转化存入到数据库中。PostGIS本身自带了一个用于此作用的工具：<code>shp2pgsql</code>。可以通过这个工具来先将shapefile导入到数据库中。也可以直接导入别的开放数据，比如很多OSM格式的数据源，我们此处仅仅简单的从别的数据源将OSM格式的数据下载并导入到PostGIS中。</p>

<p>创建数据库<code>chengdu</code>:</p>

<p>```sh
$ createdb chengdu -O gis -E UTF8 -e
CREATE DATABASE chengdu OWNER gis ENCODING 'UTF8';</p>

<p>$ psql -U gis -d chengdu
```</p>

<p>登陆PostGres，然后为数据库<code>chengdu</code>启动PostGIS扩展：</p>

<p><code>sql
-- Enable PostGIS (includes raster)
CREATE EXTENSION postgis;
-- Enable Topology
CREATE EXTENSION postgis_topology;
-- fuzzy matching needed for Tiger
CREATE EXTENSION fuzzystrmatch;
-- Enable US Tiger Geocoder
CREATE EXTENSION postgis_tiger_geocoder;
</code></p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm.bz2
$ bunzip2 -d chengdu.osm.bz2
$ osm2pgsql -U gis -d chengdu -s -S ./default.style chengdu.osm
</code></p>

<p>这个命令将chengdu.osm导入到了名称为<code>chengdu</code>的数据库中。</p>

<p>可以通过SQL命令查看其中的数据：</p>

<p><code>sql
select ST_Extent(ST_Transform(way,4326)) from planet_osm_roads;
</code></p>

<p>结果如下：</p>

<p>```</p>

<pre><code>                            st_extent                                 
</code></pre>

<hr />

<p> BOX(103.564165069794 30.3634139134986,104.554549945024 30.9869936005376)
(1 row)
```</p>

<h4>WMS服务器</h4>

<p>生成图片之后，我们还需要将这些图片切成瓦片，然后公开给外部以便使用。Mapnik提供了切图的功能，并且还提供一个实现了<a href="https://github.com/mapnik/OGCServer">WMS协议的服务器</a>，以便使用。</p>

<p>安装这个OGCServer服务器非常容易：</p>

<p><code>sh
$ git clone git@github.com:mapnik/OGCServer.git
$ cd OGCServer
$ sudo python setup.py install
</code></p>

<p>但是OGCServer的启动，需要一个配置XML配置文件，这个配置文件可以由Mapnik提供的工具集生成：</p>

<p><code>sh
$ svn co http://svn.openstreetmap.org/applications/rendering/mapnik/
</code></p>

<p>这个svn仓库中包含了众多的小工具，generate_xml.py用于生成Mapnik的样式文件，generate_image.py用于生成图片，generate_tiles.py用于生成众多的瓦片。</p>

<p>此处我们将使用<code>generate_xml.py</code>来创建一个地图样式文件，</p>

<p><code>sh
$ cd svn.openstreetmap.org/applications/rendering/mapnik/
$ ./generate_xml.py osm.xml chengdu.xml --dbname chengdu --user gis --accept-none
</code></p>

<p>generate_xml.py根据osm.xml作为模板，生成<code>chengdu.xml</code>。这个文件即可用于测试OGCServer：</p>

<p><code>sh
$ OGCServer chengdu.xml
Listening at 0.0.0.0:8000....
</code></p>

<p>然后在浏览器中查看：</p>

<p><img src="/images/2014/04/ogcserver-localhost-resized.png" alt="ogcserver" /></p>

<h4>使用OpenLayers测试</h4>

<p>有了一张图片，那么我们就需要有更多的图片组成的瓦片，这就需要使用引入GIS的前端利器OpenLayers了：</p>

<p>```
$(function() {</p>

<pre><code>var map, layer;
map = new OpenLayers.Map('map', {});

layer = new OpenLayers.Layer.WMS('Tile Cache', 
    'http://localhost:8000/?', {
        layers: '__all__',
        format: 'image/png'
    });

map.addLayer(layer);

if (!map.getCenter()) {
    map.zoomToMaxExtent();
}
</code></pre>

<p>});
```</p>

<p><img src="/images/2014/04/openlayers-chengdu-resized.png" alt="openlayers" /></p>

<p><img src="/images/2014/04/openlayers-chengdu-detail-resized.png" alt="openlayers" /></p>

<p>应该注意的是，此处在OpenLayers中使用了来自与OSM导入的数据，而并非Shapefile中的数据（Shapefile中仅有三个层次，point, line, polygon）。而OSM的数据则丰富的多。</p>
]]></content>
  </entry>
  
</feed>
