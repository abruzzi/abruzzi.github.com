<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | I code it]]></title>
  <link href="http://abruzzi.github.com/category/javascript/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2013-10-09T10:40:13+05:30</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Grunt的几个常用插件]]></title>
    <link href="http://abruzzi.github.com/2013/10/grunt-plugins/"/>
    <updated>2013-10-08T16:42:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/grunt-plugins</id>
    <content type="html"><![CDATA[<h3>Grunt的几个常用插件</h3>

<h4>grunt-karma 简介</h4>

<p><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a>是一个karma的Grunt插件，<a href="http://icodeit.org/2013/10/using-karma-as-the-javascript-test-runner/">上一篇文章</a>中已经介绍了karma的基本用法。这里简单介绍如何在Grunt中使用karma。</p>

<p>首先需要安装grunt-karma插件：</p>

<p><code>
$ npm install grunt-karma --save-dev
</code></p>

<p>然后在Gruntfile.js中加载该插件：</p>

<p><code>
grunt.loadNpmTasks('grunt-karma');
</code></p>

<p>在使用karma之前，需要生成一个karma的配置文件<code>karma.conf.js</code>:</p>

<p><code>
$ karma init karma.conf.js
</code></p>

<p>然后在Gruntfile.js中，加入初始化karma的参数，并指定，karma需要使用<code>karma.conf.js</code>文件作为配置来运行：</p>

<p>```
grunt.initConfig({</p>

<pre><code>karma: {
  unit: {
    configFile: 'karma.conf.js'
  }
}
</code></pre>

<p>});
```</p>

<p>大多数情况下，如果要把karma作为CI的一部分，应该启动单次运行模式:</p>

<p><code>
singleRun: true
</code></p>

<p>这样karma会启动浏览器，运行所有的测试用例，然后退出。</p>

<p>```
grunt.loadNpmTasks('grunt-contrib-jshint');
grunt.loadNpmTasks('grunt-karma');</p>

<p>grunt.registerTask('default', ['jshint', 'karma']);
```</p>

<p><img src="http://abruzzi.github.com/images/2013/10/grunt-karma-resized.png" alt="image" /></p>

<p>注意此处的default后边带了一个任务数组，其中每个任务会按照声明的顺序依次被执行。事实上此处的'default'是后边整个列表的一个别名(alias)。</p>

<h4>grunt-jshint / grunt-uglify / grunt-concat</h4>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>是一个用于JavaScript静态语法检查的工具，它会帮助开发者在进行较为严格的语法检查。</p>

<p>和其他的Grunt插件一样，它是以一个npm的包的形式发布的，因此安装非常容易:</p>

<p><code>
$ npm install grunt-contrib-jshint --save-dev
</code></p>

<p>然后在Gruntfile.js中加载该插件:</p>

<p><code>
grunt.loadNpmTasks('grunt-contrib-jshint');
</code></p>

<p>即可，类似的还有：用以连接所有JavaScript源代码为一个独立文件的<a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a>，以及用以最小化JavaScript源码的<a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a>。</p>

<h4>自定义插件</h4>

<p><a href="https://github.com/gruntjs/grunt-init">grunt-init</a>是一个帮助开发人员快速搭建基于Grunt项目的工具，比如开发jQuery插件，Gruntfile，或者Grunt插件本身。安装方式很简单，我们需要在其他项目也用到grunt-init，因此安装在全局路径下<code>-g</code>:</p>

<p><code>
$ npm install -g grunt-init
</code></p>

<p>开发Grunt插件，我们需要一个基本的模板，将这个模板clone到home下的.grunt-init目录下：</p>

<p><code>
$ git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin
</code></p>

<p>然后新建一个目录，并在该目录下运行：</p>

<p><code>
$ mkdir beautify
$ cd beautify
$ grunt-init gruntplugin
</code></p>

<p>grunt-init会让你回答一些问题，比如插件名称，版本号，github链接等。之后，grunt-init会生成一个基本的模板，开发者只需要完成自己插件的逻辑代码即可。逻辑实现在<code>tasks/&lt;plugin-name&gt;.js</code>中即可。</p>

<p>完成后可以通过<code>npm publish</code>来发布，发布之后，你的插件就可以向上边提到的常用插件那样被其他的开发者使用了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Karma运行JavaScript测试]]></title>
    <link href="http://abruzzi.github.com/2013/10/using-karma-as-the-javascript-test-runner/"/>
    <updated>2013-10-08T10:36:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/using-karma-as-the-javascript-test-runner</id>
    <content type="html"><![CDATA[<h3>Karma 简介</h3>

<p>Karma是一个JavaScript的测试运行器。事实上，Karma更是一个测试环境，使用Karma可以很方便的的运行测试(方便到你感觉不到它的实际存在)。</p>

<p>一般的TDD的开发流程为：</p>

<ol>
<li>编写测试(一个会失败的case)</li>
<li>运行测试，并看到这个测试失败</li>
<li>编写代码(足够让测试通过的代码)</li>
<li>运行测试，并看到测试通过</li>
<li>重构</li>
<li>运行测试，并看到测试通过</li>
</ol>


<p>然后<strong>如此循环</strong>，而在前端开发中，很长一段时间，这个流程受限于开发环境，比如添加了一个新的JavaScript源文件，开发者需要在HTML中引入相应地文件，以及响应的测试文件，然后刷新页面(有时候还需要清空浏览器缓存)。</p>

<p>在这个过程中，开发者真正关注的就是编写测试，运行测试，编写实现，重构等等，需要不断的重复这个过程。而不是关注如刷新页面，清空缓存，修改HTML对脚本的引用等武馆的工作。</p>

<p>Karma就是这样一个开发环境，开发者指定需要测试的脚本/测试文件，需要运行的浏览器等信息，Karma会在后台自动监控文件的修改，并启动一个浏览器与Karma的服务器连接，这样当源代码或者测试发生修改后，Karma会自动运行测试。</p>

<p>开发者可以指定不同的浏览器，甚至可以跨设备。由于Karma只是一个运行器，你可以使用项目中正在使用的测试框架如Jasmine，QUnit等，甚至可以自定义适配器来支持你自己的测试框架。</p>

<h3>运行Karma</h3>

<p>Karma需要一个配置文件来知道哪些文件需要被加载，需要被监控(当文件内容发生变化时，尝试运行测试)，这个配置文件可以通过Karma自带的参数来生成。</p>

<h4>基本使用</h4>

<p>Karma被实现为一个npm的包，所以可以通过</p>

<p><code>
$ npm install -g karma
</code></p>

<p>安装之后，可以生成karma需要的配置文件：</p>

<p><code>
$ karma init my.conf.js
</code></p>

<p>karma会让你回答一些问题，比如是哪种测试框架，哪些文件需要被测试，哪些浏览器需要被考虑等。生成的配置文件的一个片段是：</p>

<p>```
// base path, that will be used to resolve files and exclude
basePath = '';</p>

<p>// list of files / patterns to load in the browser
files = [
  JASMINE,
  JASMINE_ADAPTER,
  'src/<strong>/*.js',
  'test/</strong>/*spec.js'
];</p>

<p>// web server port
port = 9876;</p>

<p>// browsers
browsers = ['Chrome'];</p>

<p>```</p>

<hr />

<p><strong>更新</strong>
新的配置文件生成脚本会生成更加<strong>模块化</strong>的配置：</p>

<p>```
module.exports = function(config) {
  config.set({</p>

<pre><code>frameworks: ['jasmine'],

files: [
  'src/**/*.js',
  'test/**/*spec.js'
],

port: 9876,

browsers: ['Chrome'],

singleRun: true
</code></pre>

<p>  });
};</p>

<p>```</p>

<hr />

<p>生成配置文件之后，可以通过命令来启动Karma服务器，同时指定使用<code>my.conf.js</code>文件作为配置：</p>

<p><code>
$ karma start my.conf.js
</code></p>

<p><img src="http://abruzzi.github.com/images/2013/10/karma-run-resized.png" alt="image" /></p>

<h4>调试及其他</h4>

<p>很多时候，我们只想要运行某一个suite中的所有测试用例，而不是整个工程，比如在Jasmine中：</p>

<p>```
describe("Controller User", function() {</p>

<pre><code>it("add user", function() {});
it("search users", function() {});
it("delete user", function() {});
</code></pre>

<p>})
```</p>

<p>只需要将<code>describe</code>修改为<code>ddescribe</code>即可，类似的，如果只需要运行某一个测试用例，只需要将<code>it</code>修改为<code>iit</code>即可。</p>

<p>这在运行调试某个测试或者某段特定代码时非常好用。另外，Karma还提供了debugger功能，在测试用例中加入：</p>

<p><code>
debugger;
</code></p>

<p>即可。由于在运行时，karma实际上会启动一个真实地浏览器，所以可以在浏览器的developer-tool中进行实际的调试。需要注意的是，当进入调试模式时，需要启动developer-tool(在Karma启动的那个浏览器窗口中)。</p>

<p><img src="http://abruzzi.github.com/images/2013/10/karma-debug-resized.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Grunt作为构建工具(build tool)]]></title>
    <link href="http://abruzzi.github.com/2013/10/using-grunt-as-your-build-tool/"/>
    <updated>2013-10-07T18:14:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/10/using-grunt-as-your-build-tool</id>
    <content type="html"><![CDATA[<h3>Grunt简介</h3>

<p>Grunt是一个基于JavaScript的构建工具。和其他的构建工具类似，grunt主要用于一些将一些繁琐的工作自动化，比如运行测试，代码的静态检查，压缩JavaScript源代码等等。</p>

<h4>安装grunt-cli</h4>

<p>要在命令行运行grunt，需要安装grunt的命令行工具：</p>

<p><code>
$ npm install -g grunt-cli
</code></p>

<p>grunt-cli本身并不会提供Grunt构建工具，而只是一个Grunt的调用器。<code>-g</code>参数表示将grunt-cli安装在全局的路径中，这样我们可以在不同的项目中使用grunt-cli，而由于grunt-cli本身只是一个调用器，所以对于不同的项目，真正运行的Grunt可以是不同的版本，而命令行的借口则完全一致。</p>

<p>grunt-cli提供的命令行可执行文件的名称为<code>grunt</code>，这个工具每次运行时都会检查当前目录下的Grunt。</p>

<h4>使用grunt-cli</h4>

<p>如果在一个既有的npm模块中，可以很容易的加入grunt的支持，只需要修改package.json，加入依赖，然后运行<code>npm install</code>来完成依赖的安装即可。</p>

<p>如果是一个新启动的项目，那么在项目中添加两个文件：package.json和Gruntfile。其中package.json用来定义当前项目是一个npm的模块，而Gruntfile用来定义具体的任务，以及加载Grunt的其他插件(Grunt提供丰富的插件，比如运行测试，代码静态检查等功能都是通过插件来完成的)</p>

<h4>package.json</h4>

<p>package.json定义了一个工程的元数据，这些数据被npm管理器来使用，npm本身提供了<code>init</code>参数可以很容易的生成一个package.json文件：</p>

<p><code>
$ npm init
</code></p>

<p>根据提示可以很容易的生成一个新的package.json</p>

<p>```
{
  "name": "chapter-testing",
  "version": "0.0.0",
  "description": "This is the demo for how to use grunt.js",
  "main": "my.conf.js",
  "directories": {</p>

<pre><code>"test": "test"
</code></pre>

<p>  },
  "scripts": {</p>

<pre><code>"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
</code></pre>

<p>  },
  "author": "Juntao",
  "license": "BSD-2-Clause"
}
```</p>

<p>一般来说，package.json文件中有一个<code>devDependencies</code>的小节，定义了本项目的外部依赖。</p>

<p>可以通过运行</p>

<p><code>
$ npm install grunt --save-dev
</code>
来为工程文件package.json添加<code>devDependencies</code>小节的定义：</p>

<p><code>
"devDependencies": {
  "grunt": "~0.4.1"
}
</code></p>

<p>该命令会为工程添加一条依赖关系，如果别人拿到这个文件，就可以在本地“复原”你的开发环境，以保证整个团队使用同样地<strong>库</strong>文件。</p>

<p>完成之后，该命令会在本地生成一个目录(如果没有的话)<code>node_modules</code>，其中包括了完成的Grunt的可执行文件，这时候在命令行运行grunt(由grunt-cli提供的命令行工具)，就会尝试在此目录中查找Grunt的可执行文件。</p>

<h4>Gruntfile</h4>

<p>要运行Grunt，还需要定义你自己的任务，默认的任务定义在Gruntfile中，Gruntfile有一定的格式。</p>

<p>所有的任务需要定义在一个函数中：</p>

<p><code>
module.exports = function(grunt) {
  // task defination
};
</code></p>

<p>一般而言，使用Grunt会读取一些项目的信息(定义在package.json中)：</p>

<p>```
grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json')
</code></pre>

<p>});
```</p>

<p>亦可以在这个时刻指定一些其他的插件的选项：</p>

<p>```
grunt.initConfig({</p>

<pre><code>pkg: grunt.file.readJSON('package.json'),
jshint: {
    all: ['Gruntfile.js', 'lib/**/*.js', 'test/**/*.js']
}
</code></pre>

<p>});
```</p>

<p>然后需要加载其他的插件(如果需要的话)</p>

<p><code>
grunt.loadNpmTasks('grunt-contrib-jshint');
</code></p>

<p>最后，需要指定一个grunt的入口任务(<code>default</code>任务)：</p>

<p>```
grunt.registerTask('default', function() {</p>

<pre><code>console.log("default task");
</code></pre>

<p>});</p>

<p>```</p>

<p>然后运行<code>grunt</code>，我们此处定义的default任务仅仅在控制台上打印一行字符串:</p>

<p>```
$ grunt
Running "default" task
default task</p>

<p>Done, without errors.
```</p>

<h3>Grunt插件</h3>

<p>Grunt已经得到了很多的开源软件贡献者的支持，已经又众多的插件被开发出来。比如:</p>

<ol>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a></li>
</ol>


<p>等等，使用这些插件可以快速的为你的项目开发提供很多的便利，以grunt-jshint为例，
首先需要安装此插件：</p>

<p><code>
$ npm install grunt-contrib-jshint --save-dev
</code></p>

<p>然后在grunt.initConfig中指定jshint需要的参数：</p>

<p>```
grunt.initConfig({</p>

<pre><code>jshint: {
    files: ['js/*.js'],
    options: {
        ignores: ['js/jquery*.js']
    }
}
</code></pre>

<p>});
```</p>

<p>然后加载此插件：</p>

<p><code>
grunt.loadNpmTasks('grunt-contrib-jshint');
</code></p>

<p>最后，可以将<code>jshint</code>加入到默认的任务中：</p>

<p><code>
grunt.registerTask('default', ['jshint']);
</code></p>

<p>运行结果<code>可能</code>如下:</p>

<p><img src="http://abruzzi.github.com/images/2013/10/jshint.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逐步编写一个jQuery插件(todoify)]]></title>
    <link href="http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step/"/>
    <updated>2013-07-20T13:04:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/07/write-a-jquery-plugin-step-by-step</id>
    <content type="html"><![CDATA[<h3>最终结果</h3>

<p>这篇文章将讨论如何编写一个简单的jQuery插件的基本步骤和实践，最后完成的时候，我们会得到一个管理todo的插件（而且还是一个比较灵活，易于定制的todo插件）。事实上，这个插件可以工作在所有与管理todo类似的应用场景中，比如gmail的搜索框中的token等，豆瓣读书里的tags管理等等。</p>

<p><img src="http://abruzzi.github.com/images/2013/07/todo-origin.resized.png" alt="默认设置" /></p>

<p>上例中HTML结构如下：</p>

<p>```</p>

<div id="container">
    <input type="text" id="input" />
    <div id="todos" />
</div>
```

下面的JavaScript代码将会找到id为*input*的输入框，并将它**变为**一个todolist的控制器，并将新加入的内容添加到id为*todos*的容器中：

```
$("#input").todoify({
    container: "#todos"
});
```

如果需要定制item的外观，可以定义模板并自定义渲染函数：

```
$("#thing-input").todoify({
    container: "#thing-todos",
    template: "<section class='todoItem'><header><%= todo %></header><a>remove</a></section>",
    renderItem: function(item) {
        var cont = this.renderTemplate(item);

        cont.find("a").click(function(event){
            cont.remove();
        });

        return cont;
    }
});
```

![Item定制](http://abruzzi.github.com/images/2013/07/todo-customized.resized.png)

### jQuery插件基础知识

#### 简单流程
通常使用jQuery的流程是这样的：通过选择器选择出一个jQuery对象（集合），然后为这个对象应用一些预定义的函数，如：

```
$(".artile .title").mouseover(function(){
    $(this).css({
        "background-color": "red",
        "color": "white"
    });
});
```

我们如果要定义自己的插件，预期其被调用的方式和此处的*mouseover*并无二致。这需要将我们定义的函数attach到jQuery对象的fn属性上：

```
$.fn.hltitle = function() {
    this.mouseover(function(){
        $(this).css({
            "background-color": "red",
            "color": "white"
        })
    })
}

$('.article .title').hltitle();
```

jQuery的一个很明显的特点是其链式操作，即每次调用完成一个函数/插件之后仍然会返回jQuery对象本身，这个需要我们在插件函数的最后一行返回*this*。这样插件的使用者会像使用其他函数/插件一样很方便的将调用连起来。

另外一个问题是注意命名冲突（$是一个合法的标示符，而且被众多的JavaScript库在使用），所以可以通过匿名执行函数来避免：

```
(function($){
    $.fn.hltitle = function() {
        //...
    }
}(jQuery));
```

#### 需要注意的问题

上面是一个最简单的插件定义，为了插件更加灵活，我们需要尽可能多的将配置项暴露给插件的用户，比如提供一些默认选项，如果用户不提供配置，则插件按照默认配置来工作，但是用户可以通过修改配置来定制插件的行为：

```
(function($){
    $.fn.hltitle = function(options) {
        var defaults = {
            "background-color": "red",
            "color": "white"                
        };
        
        var settings = $.extend(defaults, options);
        
        return this.mouseover(...);
    }
}(jQuery));

```

### Todoify

我们的插件是一个遵循上述原则的简单插件，基本的步骤如下：

-   将给定的input包装成一个jQuery对象
-   需要一个默认的放置todolist的容器元素
-   为input注册keypress事件（如果用户按Enter，则触发add事件，添加一个新条目到容器）

```
(function($){
    $.fn.todoify = function(options) {
        var settings = $.extend({
            container: "body",
            template: "<span class='todo-item'><%= todo %></span>",
            renderItem: function(item) {
                return $(_.template(this.template, {todo: item}));
            }
        }, options);

        $(this).keypress(function(event){
            if(event.keyCode == 13) {
                var item = $(this).val();
                $(settings.container).append(settings.renderItem(item));
                $(this).val("").focus();
            }
        });

        return this;
    }
}(jQuery));
```

此处为了防止创建众多的DOM元素，然后依次插入到正确地节点上，我使用了underscore.js的template，不过此处并非重点，略微一提。

如果用户想要更好地定制性，比如用户想要apply自己的class，定义自己的模板，或者注册新的事件（删除一条todo），显然我们需要更多的options：

```
var settings = $.extend({
    data: [],
    template: "<div class='todo'><h3><%= todo %></h3><span>X</span></div>",
    container: "body",
    renderTemplate: function(item) {
        return $(_.template(this.template, {todo: item}));
    },
    renderItem: function(item) {
        var cont = this.renderTemplate(item);
        cont.find("span").click(function(event) {
            cont.remove();
        });
        return cont;
    }
}, options);
```

这里定义了默认的close事件需要attach到span（定义在模板中）上，如果插件的用户需要自己绘制模板，并且注册事件，那么会像文章开头的那个实例一样：

```
$("#thing-input").todoify({
    container: "#thing-todos",
    template: "<section class='todoItem'><header><%= todo %></header><a>remove</a></section>",
    renderItem: function(item) {
        var cont = this.renderTemplate(item);

        cont.find("a").click(function(event){
            cont.remove();
        });

        return cont;
    }
});
```

###进一步改进

目前，todoify还没有与后台进行任何的通信，如果可以和后台的RESTFul的API集成的话，这个插件将会有更多的使用场景。

简单来讲，只需要为插件提供更多选项，并提供回调函数即可，比如：

```
$("#input").todoify({
    restful: 'http://app/todos',
    onadd: function(item){
        //...
    },
    ondelete: function(item){
        //...
    }
})
```

然后加入一些ajax的调用即可。

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript核心概念及实践勘误表]]></title>
    <link href="http://abruzzi.github.com/2013/05/javascripthe-xin-gai-nian-ji-shi-jian-kan-wu-biao/"/>
    <updated>2013-05-16T11:29:00+05:30</updated>
    <id>http://abruzzi.github.com/2013/05/javascripthe-xin-gai-nian-ji-shi-jian-kan-wu-biao</id>
    <content type="html"><![CDATA[<h3>《JavaScript核心概念及实践》勘误表</h3>

<p><a href="http://icodeit.org/jsccp/">JavaScript核心概念及实践</a>一书已经于2013年5月出版，由于时间原因以及作者的疏于检查，导致书中出现了一些错别字词等错误，现在将错误及更正列于此页，作者为对读者朋友带来的不便表示深深的歉意。</p>

<hr />

<p>第一章第12页</p>

<p>“则向控制台打印：goodbay” 应为 “则向控制台打印：<strong>goodbye</strong>”</p>

<hr />

<p>第二章第19页</p>

<p>“var y = x + "2";// => 32” 注释中的数字32应为字符串类型 “var y = x + "2";// => <strong>"32"</strong>”</p>

<hr />

<p>第三章第36页</p>

<p>“对函数customize(options)的调用 constomize” 应为 “<strong>customize</strong>”。</p>

<p>同一页，3.4小节
“反回给前端的仍然是 JSON 对象” 应为 “<strong>返回</strong>给前端的仍然是 JSON 对象”</p>

<hr />

<p><a href="http://book.douban.com/review/5960403/">这里有</a>一个非常仔细，质量很高的勘误表，由网友 @RednaxelaFX 整理。</p>

<hr />

<p>这个页面将维持更新，如果有新的错误被发现，我会第一时间更新书籍的电子版本，并在此页面上更新。</p>
]]></content>
  </entry>
  
</feed>
