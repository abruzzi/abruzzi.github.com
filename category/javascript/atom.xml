<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | I code it]]></title>
  <link href="http://abruzzi.github.com/category/javascript/atom.xml" rel="self"/>
  <link href="http://abruzzi.github.com/"/>
  <updated>2014-09-01T19:00:05+10:00</updated>
  <id>http://abruzzi.github.com/</id>
  <author>
    <name><![CDATA[Qiu Juntao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[全球地震信息的可视化（使用OpenLayers）]]></title>
    <link href="http://abruzzi.github.com/2014/04/render-geojson-by-using-openlayers/"/>
    <updated>2014-04-15T21:33:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/04/render-geojson-by-using-openlayers</id>
    <content type="html"><![CDATA[<h4>OpenLayers</h4>

<p>使用<a href="http://openlayers.org/">OpenLayers</a>可以很容易的搭建基于Web的GIS系统，OpenLayers支持不同的数据源(符合WMS协议的服务器，Google Maps API, Bing Maps，KML以及<a href="http://geojson.org/">GeoJSON</a>等等)。通过将不同的数据源的数据整合，我们可以开发出丰富而用户友好的GIS系统。</p>

<p>OpenLayers可以轻松的处理GeoJSON数据，并将其生成矢量层，我们可以将这个层叠加在其他数据源（比如OSM）提供的地图上，以得到一个完整的小应用。</p>

<p>最后的运行结果是这样的：</p>

<p><img src="/images/2014/04/openlayers-earthquake-resized.png" alt="image" /></p>

<h4>GeoJSON</h4>

<p><a href="http://www.usgs.gov/aboutusgs/">美国地理信息调查局</a>是一个科学组织，他公开了很多地球上的灾难信息，比如对地震的统计，并提供编程接口。它公开的地震统计信息，包含全世界各地报告过的地震，以及全美所有检测到的地震，并以多种周期（小时，天，周，月等），多种格式（GeoJSON，KML，Atom等），以便应用程序的开发者只用这些数据。</p>

<h4>实现</h4>

<h5>设置基本环境</h5>

<p>我们将借助bower来安装所有的代码依赖。首先，我们需要bower将所有的包都安装在<code>components</code>目录下，这个可以通过在当前目录的<code>.bowerrc</code>文件中制定<code>directory</code>：</p>

<p>```json
{</p>

<pre><code>"directory": "components"
</code></pre>

<p>}
```</p>

<p>然后运行bower安装jquery以及openlayers：</p>

<p><code>sh
$ bower install jquery
$ bower install openlayers
</code></p>

<p>通过bower安装OpenLayers之后，可以通过OpenLayers自带的build工具将所有的源码合并压缩为一个文件：</p>

<p><code>sh
$ cd components/openlayers/build
$ ./build.py #将会在当前目录下生成一个OpenLayers.js的文件
$ mv OpenLayers.js ../
</code></p>

<p>然后，创建一个简单的HTML文件，引用jquery.js和OpenLayers.js，以及我们的入口脚本app.js，本文所有的代码都只是修改这个文件。</p>

<p>```html
&lt;!DOCTYPE HTML>
<html></p>

<pre><code>&lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;Earthquake distribution&lt;/title&gt;
    &lt;link rel="stylesheet" href="style.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;
        &lt;div id="map"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="components/jquery/jquery.js" type="text/javascript"&gt;&lt;/script&gt;        
    &lt;script src="components/openlayers/OpenLayers.js" type="text/javascript"&gt;&lt;/script&gt;        
    &lt;script src="app.js" type="text/javascript"&gt;&lt;/script&gt;        
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<p>还可以运行<code>bower init</code>来将生成<code>bower.json</code>，以方便别人使用我们的应用：</p>

<p><code>js
$ bower init
</code></p>

<h5>基本代码</h5>

<p>一个最简单的OpenLayers应用，只需要7行代码：</p>

<p>```js
$(function() {</p>

<pre><code>var map = new OpenLayers.Map("map");
var osm = new OpenLayers.Layer.OSM();

map.addLayers([osm]);
map.zoomToMaxExtent();
</code></pre>

<p>});
```</p>

<p>这段代码在id为<code>map</code>的HTML元素创建了一个地图，这个地图上有一个叫OSM的层（即<a href="http://www.openstreetmap.org/">OpenStreetMap</a>，一个开源，开放的地图平台），并将地图缩小到边界范围（以获得最大的视野）:</p>

<p><img src="/images/2014/04/openlayers-osm-resized.png" alt="image" /></p>

<h5>生成矢量层</h5>

<p>通过GeoJSON生成矢量图非常容易：</p>

<p>```js
var geo = new OpenLayers.Layer.Vector("EarthQuake", {</p>

<pre><code>strategies: [new OpenLayers.Strategy.Fixed()],
protocol: new OpenLayers.Protocol.HTTP({
    url: '/all_day.geojson',
    format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true})
})
</code></pre>

<p>});
```</p>

<p>注意此处的<a href="http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson">all_day.geojson</a>是从USGS网站上下载的，过去一天中世界各地的所有地震统计。</p>

<p>上边的代码创建了一个名称为<code>EarthQuake</code>的矢量层，<code>strategies</code>中的Fixed策略表示仅请求一次资源，然后缓存在前端，不再请求。<code>protocol</code>表明数据来源为<code>all_day.geojson</code>，格式为<code>OpenLayers.Format.GeoJSON</code>。由于USGS返回的地理信息除了经纬度还包含深度，而OpenLayers默认只处理经纬度的，因此需要此处的<code>ignoreExtraDims</code>来忽略那个额外的深度信息。</p>

<p><img src="/images/2014/04/openlayers-geojson-resized.png" alt="image" /></p>

<h5>定制样式</h5>

<p>虽然我们已经加上了新的层，也可以看到很多表示地震的点信息，但是并不能看出哪些地震是严重的，比如里氏3级以下的地震，几乎没有危害，可以标注成一种颜色；而更高震级的可以标记成另外一种颜色。</p>

<p>OpenLayers可以很容易的做到这个定制化:</p>

<p>```js</p>

<pre><code>var style = new OpenLayers.Style();

var ruleLow = new OpenLayers.Rule({
  filter: new OpenLayers.Filter.Function({
        evaluate: function(properties) {
            return properties.mag &lt; 3.0;
        }
    }),
  symbolizer: {pointRadius: 3, fillColor: "green",
               fillOpacity: 0.5, strokeColor: "black"}
});

var ruleHigh = new OpenLayers.Rule({
  filter: new OpenLayers.Filter.Function({
        evaluate: function(properties) {
            return properties.mag &gt;= 3.0;
        }
    }),
    symbolizer: {pointRadius: 5, fillColor: "red",
               fillOpacity: 0.7, strokeColor: "black"}
});

style.addRules([ruleLow, ruleHigh]);

geo.styleMap = new OpenLayers.StyleMap(style);
</code></pre>

<p>```</p>

<p>首先创建一个Style对象，为Style添加两条规则Rule，然后将Style对象包装成StyleMap并赋值给表示地震的矢量层<code>earthquake</code>。</p>

<p>对于规则ruleLow，我们定义了，当一个feature的属性值mag(震级)小于三的时候后，使用绿色的，半径为3px的小圆圈来表示。而ruleHigh则定义了当震级大于等于三的时候，用红色，半径为5px的圆圈来表示。</p>

<p><img src="/images/2014/04/openlayers-geojson-styling-resized.png" alt="image" /></p>

<h5>加上事件处理</h5>

<p>虽然我们已经可以直观的根据震级不同而看到不同颜色的点，但是整个应用仍然没有多少意义：它不具备于用户的交互能力。我们需要添加上事件处理，当用户点击地图上的一个圆点的时候，应该看到一个更详细的窗口。</p>

<p>```js
var selectControl = new OpenLayers.Control.SelectFeature(geo, {</p>

<pre><code>onSelect: onFeatureSelect,
onUnselect: onFeatureUnselect 
</code></pre>

<p>});</p>

<p>map.addControl(selectControl);
selectControl.activate();</p>

<p>function onFeatureSelect(feature) {</p>

<pre><code>var html = "&lt;span&gt;"+feature.attributes.title+"&lt;/span&gt;";

var popup = new OpenLayers.Popup.FramedCloud("popup",
        feature.geometry.getBounds().getCenterLonLat(),
        null,
        html,
        null,
        true
    );

popup.panMapIfOutOfView = true;
popup.autoSize = true;

feature.popup = popup;

map.addPopup(popup);
</code></pre>

<p>}</p>

<p>function onFeatureUnselect(feature) {</p>

<pre><code>map.removePopup(feature.popup);
feature.popup.destroy();
feature.popup = null;
</code></pre>

<p>}
```</p>

<p>我们在地图上添加了一个<code>SelectFeature</code>元素，并注册了回调函数：当矢量层中的矢量被选中之后，函数<code>onFeatureSelect</code>将被执行，我们可以在这个函数中添加对弹出窗口的控制。当<code>onFeatureSelect</code>执行时，OpenLayers会将当前的Feature传递进来，我们可以动态的取得震级，标题，链接等信息，并展现给最终用户。</p>

<p><img src="/images/2014/04/openlayers-geojson-popup-resized.png" alt="[image]" /></p>

<p>如果将数据源扩大到本周的所有地震：</p>

<p>```js
var geo = new OpenLayers.Layer.Vector("EarthQuake", {</p>

<pre><code>strategies: [new OpenLayers.Strategy.Fixed()],
protocol: new OpenLayers.Protocol.HTTP({
    url: '/all_week.geojson',
    format: new OpenLayers.Format.GeoJSON({ignoreExtraDims: true})
})
</code></pre>

<p>});
```</p>

<p><img src="/images/2014/04/openlayers-geojson-weekly-resized.png" alt="image" /></p>

<p>完整的代码示例<a href="https://github.com/abruzzi/earthquake-viz">可以看这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建地图服务器（使用Mapnik）]]></title>
    <link href="http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik/"/>
    <updated>2014-04-12T14:07:00+10:00</updated>
    <id>http://abruzzi.github.com/2014/04/setup-map-server-by-mapnik</id>
    <content type="html"><![CDATA[<h4>渲染引擎Mapnik</h4>

<p><a href="http://icodeit.org/2014/04/intro-map-gis/">上一篇文章</a>中大概介绍了<a href="https://github.com/mapnik">Mapnik</a>，它是一个渲染引擎，一般开发中都会使用他的python的bind做开发。</p>

<p>Mapnik的文档写的比较详细，我们这里只是做一些必要的介绍，详细的细节可以参看Mapnik在<a href="https://github.com/mapnik/mapnik/wiki">Github上的文档</a>。</p>

<p>在Mac下，安装Mapnik十分容易，使用brew即可，注意我们在此处带上<code>--with-postgresql</code>选项，使得Mapnik可以通过PostGIS来访问数据库：</p>

<p><code>sh
brew install mapnik --with-postgresql
</code></p>

<p>安装完成之后，可以通过一个小的python脚本来测试：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(256, 256)
map.background = mapnik.Color('red')
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'red.png', 'png')
```</p>

<p>这段脚本可以在当前目录下生成一个红色的256x256的小图片。好了，有了渲染引擎，我们需要一些数据来进行渲染了。</p>

<h4>数据源</h4>

<p>最通用的数据格式为Shapefiles，目前有很多的免费地理信息供公共下载，我们可以从<a href="http://metro.teczno.com/">Metro的站点</a>上下载一些小的数据文件。</p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm2pgsql-shapefiles.zip
$ mkdir chengdu
$ cd chengdu
$ unzip chengdu.osm2pgsql-shapefiles.zip
</code>
这样就得到了一组文件：</p>

<p><code>
$ find . -name "*.shp"
./chengdu.osm-line.shp
./chengdu.osm-point.shp
./chengdu.osm-polygon.shp
</code></p>

<p>每一个shp文件都会对应几个其他类型的文件，比如投影信息，属性表等。仅仅查看shp的话，有表示所有点的文件chengdu.osm-line.shp，又表示所有线的chengdu.osm-line.shp，以及表示所有面（区域）的chengdu.osm-polygon.shp文件。</p>

<p>有了这些文件，我们就可以做一些测试了，比如我们首先加载所有的线条，并根据这些线条生成一个图层：</p>

<p>```python
import mapnik</p>

<p>map = mapnik.Map(800, 800)
map.background = mapnik.Color('#ffffff')</p>

<p>style = mapnik.Style()
rule = mapnik.Rule()</p>

<p>point_symbolizer = mapnik.PointSymbolizer()
rule.symbols.append(point_symbolizer)</p>

<p>style.rules.append(rule)</p>

<p>map.append_style('default', style)</p>

<p>ds_point = mapnik.Shapefile(file='chengdu.osm-point.shp')
point = mapnik.Layer('point')
point.datasource = ds_point
point.styles.append('default')</p>

<p>map.layers.append(point)
map.zoom_all()</p>

<p>mapnik.render_to_file(map, 'chengdu.png', 'png')
```</p>

<p>可以得到：</p>

<p><img src="/images/2014/04/chengdu-point.png" alt="points" /></p>

<p>这里介绍一下Mapnik中的一些概念：一个Map可以包含若干个层（Layer），每个层可以独立着色，即可以为每个层定制样式（Style），每个样式由若干个规则组成（Rule）。每个规则由是由若干个符号定制。</p>

<p><img src="/images/2014/04/chengdu-line.png" alt="lines" /></p>

<p>如果将两者重叠，则可以得到：</p>

<p><img src="/images/2014/04/chengdu-point-and-line.png" alt="lines" /></p>

<p>```python
polygon_symbolizer = mapnik.PolygonSymbolizer(mapnik.Color('#c8102e'))
polygon_rule.symbols.append(polygon_symbolizer)</p>

<p>ds_polygon = mapnik.Shapefile(file='chengdu.osm-polygon.shp')
polygon = mapnik.Layer('polygon')
polygon.datasource = ds_polygon
polygon.styles.append('polygon')</p>

<p>map.layers.append(polygon)
```</p>

<p><img src="/images/2014/04/chengdu-polygon.png" alt="image" /></p>

<p>将这三个层叠加在一起，会得到最终的结果：</p>

<p><img src="/images/2014/04/chengdu-point-and-line-and-polygon.png" alt="lines" /></p>

<h4>数据转化</h4>

<p>在进一步之前，我们需要将数据存储在数据库中。我们可以将shapefile通过转化存入到数据库中。PostGIS本身自带了一个用于此作用的工具：<code>shp2pgsql</code>。可以通过这个工具来先将shapefile导入到数据库中。也可以直接导入别的开放数据，比如很多OSM格式的数据源，我们此处仅仅简单的从别的数据源将OSM格式的数据下载并导入到PostGIS中。</p>

<p>创建数据库<code>chengdu</code>:</p>

<p>```sh
$ createdb chengdu -O gis -E UTF8 -e
CREATE DATABASE chengdu OWNER gis ENCODING 'UTF8';</p>

<p>$ psql -U gis -d chengdu
```</p>

<p>登陆PostGres，然后为数据库<code>chengdu</code>启动PostGIS扩展：</p>

<p><code>sql
-- Enable PostGIS (includes raster)
CREATE EXTENSION postgis;
-- Enable Topology
CREATE EXTENSION postgis_topology;
-- fuzzy matching needed for Tiger
CREATE EXTENSION fuzzystrmatch;
-- Enable US Tiger Geocoder
CREATE EXTENSION postgis_tiger_geocoder;
</code></p>

<p><code>sh
$ wget http://osm-extracted-metros.s3.amazonaws.com/chengdu.osm.bz2
$ bunzip2 -d chengdu.osm.bz2
$ osm2pgsql -U gis -d chengdu -s -S ./default.style chengdu.osm
</code></p>

<p>这个命令将chengdu.osm导入到了名称为<code>chengdu</code>的数据库中。</p>

<p>可以通过SQL命令查看其中的数据：</p>

<p><code>sql
select ST_Extent(ST_Transform(way,4326)) from planet_osm_roads;
</code></p>

<p>结果如下：</p>

<p>```</p>

<pre><code>                            st_extent                                 
</code></pre>

<hr />

<p> BOX(103.564165069794 30.3634139134986,104.554549945024 30.9869936005376)
(1 row)
```</p>

<h4>WMS服务器</h4>

<p>生成图片之后，我们还需要将这些图片切成瓦片，然后公开给外部以便使用。Mapnik提供了切图的功能，并且还提供一个实现了<a href="https://github.com/mapnik/OGCServer">WMS协议的服务器</a>，以便使用。</p>

<p>安装这个OGCServer服务器非常容易：</p>

<p><code>sh
$ git clone git@github.com:mapnik/OGCServer.git
$ cd OGCServer
$ sudo python setup.py install
</code></p>

<p>但是OGCServer的启动，需要一个配置XML配置文件，这个配置文件可以由Mapnik提供的工具集生成：</p>

<p><code>sh
$ svn co http://svn.openstreetmap.org/applications/rendering/mapnik/
</code></p>

<p>这个svn仓库中包含了众多的小工具，generate_xml.py用于生成Mapnik的样式文件，generate_image.py用于生成图片，generate_tiles.py用于生成众多的瓦片。</p>

<p>此处我们将使用<code>generate_xml.py</code>来创建一个地图样式文件，</p>

<p><code>sh
$ cd svn.openstreetmap.org/applications/rendering/mapnik/
$ ./generate_xml.py osm.xml chengdu.xml --dbname chengdu --user gis --accept-none
</code></p>

<p>generate_xml.py根据osm.xml作为模板，生成<code>chengdu.xml</code>。这个文件即可用于测试OGCServer：</p>

<p><code>sh
$ OGCServer chengdu.xml
Listening at 0.0.0.0:8000....
</code></p>

<p>然后在浏览器中查看：</p>

<p><img src="/images/2014/04/ogcserver-localhost-resized.png" alt="ogcserver" /></p>

<h4>使用OpenLayers测试</h4>

<p>有了一张图片，那么我们就需要有更多的图片组成的瓦片，这就需要使用引入GIS的前端利器OpenLayers了：</p>

<p>```
$(function() {</p>

<pre><code>var map, layer;
map = new OpenLayers.Map('map', {});

layer = new OpenLayers.Layer.WMS('Tile Cache', 
    'http://localhost:8000/?', {
        layers: '__all__',
        format: 'image/png'
    });

map.addLayer(layer);

if (!map.getCenter()) {
    map.zoomToMaxExtent();
}
</code></pre>

<p>});
```</p>

<p><img src="/images/2014/04/openlayers-chengdu-resized.png" alt="openlayers" /></p>

<p><img src="/images/2014/04/openlayers-chengdu-detail-resized.png" alt="openlayers" /></p>

<p>应该注意的是，此处在OpenLayers中使用了来自与OSM导入的数据，而并非Shapefile中的数据（Shapefile中仅有三个层次，point, line, polygon）。而OSM的数据则丰富的多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何测试AngularJS中的Service]]></title>
    <link href="http://abruzzi.github.com/2014/01/how-to-test-service-in-angularjs/"/>
    <updated>2014-01-04T14:22:00+11:00</updated>
    <id>http://abruzzi.github.com/2014/01/how-to-test-service-in-angularjs</id>
    <content type="html"><![CDATA[<h3>Service的典型示例</h3>

<p>在AngularJS中，Service都是单例的实体，通常会将Service作为向后台交互的数据提供者，所有的需要数据的组件只需要依赖于这个Service即可。</p>

<p>```js</p>

<p>var app = angular.module('MyApp', []);</p>

<p>app.factory('SearchSettingService',</p>

<pre><code>['$http', '$q', function($http, $q) {
return {
    setting: function() {
        var deferred = $q.defer();

        $http.get('/settings.json').success(function(result) {
            deferred.resolve(result);
        }).error(function(result) {
            deferred.reject("network error");
        });

        return deferred.promise;
    }
};
</code></pre>

<p>}]);</p>

<p>```</p>

<h4>$httpBackend</h4>

<p>测试的时候，我们不需要真实的发送HTTP请求来获取数据。如果可以只测试Service的逻辑，当发送请求时，我们将这个请求拦截下来，然后返回一个预定义好的数据即可：</p>

<p>```js
it('should have settings from http request', function() {</p>

<pre><code>var result;
var expected = {
    "period": "day",
    "date": "Sat Dec 21 12:56:53 EST 2013",
};

httpBackend.expectGET('/settings.json').respond(expected);

var promise = settingService.setting();
promise.then(function(data) {
    result = data;
});

httpBackend.flush();

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>$httpBackend是AngularJS提供的一个测试用的服务，可以在spec中注入进来：</p>

<p>```js
beforeEach(function() {</p>

<pre><code>module('services');

inject(function(SearchSettingService, $httpBackend) {
    settingService = SearchSettingService;
    httpBackend = $httpBackend;
});
</code></pre>

<p>});
```</p>

<p><code>httpBackend</code>服务有一些很方便测试的方法：</p>

<p><code>js
httpBackend.expectGET(url).respond(data);
httpBackend.expectPOST(url, param).respond(data);
</code></p>

<p>设置之后，当调用<code>httpBackend.flush</code>时，AngularJS会调用这个setup，发送的请求会被之前的setup拦截并返回，这样service中的数据就被填充好了。</p>

<h4>Service测试的模板</h4>

<p>或者说，当测试一个Service时，我们应该测那些方面呢？</p>

<ol>
<li>正常流程，一个完整的处理过程</li>
<li>异常处理，如果服务器出错了，程序需要如何反馈？</li>
<li>其他异常情况</li>
</ol>


<p>正常流程很容易，在调用service提供的方法之后，在获得的promise对象上调用then方法来填充一个数据即可，然后调用<code>httpBackend.flush()</code>来<strong>发送</strong>请求，最后验证数据的格式/内容是否正确。</p>

<p>这个测试的主要目的是验证当调用service的方法时，service真实的发送了一个http请求：</p>

<p>```js
it('should have settings from http request', function() {</p>

<pre><code>var result;
var expected = {
    "period": "day",
    "date": "Sat Dec 21 12:56:53 EST 2013",
};

httpBackend.expectGET('/settings.json').respond(expected);

var promise = settingService.setting();
promise.then(function(data) {
    result = data;
});

httpBackend.flush();

expect(result).toEqual(expected);
</code></pre>

<p>});
```</p>

<p>对于异常的情况，比如服务器返回了错误，如<code>500</code>，那么最低程度，程序应该可以处理这个异常：</p>

<p>```js
it("should throw error when network expection", function() {</p>

<pre><code>var result, error;
httpBackend.expectGET('/settings.json').respond(500);

var promise = settingService.setting();
promise.then(function(data) {
    result = data;
}, function(data) {
    error = data;
});

httpBackend.flush();

expect(result).toBeUndefined();
expect(error).toEqual("network error");
</code></pre>

<p>});
```</p>

<h4><em>服务器</em> moco</h4>

<p><a href="https://github.com/dreamhead/moco">moco</a>是同事<a href="http://dreamhead.blogbus.com/">郑晔</a>开发的一个测试框架/工具，基本上来说，moco是一个用来集成测试的用的HTTP服务器。</p>

<p>你可以通过API方式或者启动moco服务器的方式来使用它，我比较喜欢将moco作为一个独立的服务器来使用：</p>

<p><code>sh
java -jar moco-runner-0.9-standalone.jar start -p 12306 -c moco.conf.json
</code></p>

<p>比如<code>moco.conf.json</code>中定义了一下规则：</p>

<p>```js
[</p>

<pre><code>{
    "request": {
        "method": "post",
        "uri": "/resource"
    },
    "response": {
        "status": 201,
        "text": "resource has been created"
    }
},
{
    "request": {
        "uri": "/resource"
    },
    "response": {
        "status": 200,
        "file": "resources.json"
    }
}
</code></pre>

<p>]
```</p>

<p>则启动moco的服务器之后，所有发往<code>/resource</code>的<code>post</code>请求都会得到</p>

<p><code>
201
resource has been created
</code></p>

<p>的HTTP响应，这个功能在前端开发越来越独立的情况下变得非常好用。我最近在有很多小项目中都在尝试moco，非常的好用，后边会有相关的博客专门介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何测试AngularJS中的Controller]]></title>
    <link href="http://abruzzi.github.com/2013/12/how-to-test-controller-in-angularjs/"/>
    <updated>2013-12-28T17:40:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/12/how-to-test-controller-in-angularjs</id>
    <content type="html"><![CDATA[<h3>AngularJS中的一个典型的Controller</h3>

<p>在AngularJS中，Controller主要用于hold一些跟view的有关的状态，以及数据模型，比如界面上某些元素是否展示，以及展示那些内容等。通常来说，Controller会依赖与一个Service来提供数据：</p>

<p>```js
app.controller('EventController', ['$scope', 'EventService',</p>

<pre><code>function($scope, EventService) {
    EventService.getEvents().then(function(events) {
        $scope.events = events;
    });
}]);
</code></pre>

<p>```</p>

<p>而service本身则需要通过向后台服务发送请求来获取数据：</p>

<p>```js
app.factory('EventService', ['$http', '$q',</p>

<pre><code>function($http, $q) {
    return {
        getEvents: function() {
            var deferred = $q.defer();

            $http.get('/events.json').success(function(result) {
                deferred.resolve(result);
            }).error(function(result) {
                deferred.reject(result);
            });

            return deferred.promise;
        }
    };
}]);
</code></pre>

<p>```</p>

<p>通常的做法是返回一个<a href="http://docs.angularjs.org/api/ng.$q">promise</a>对象，然后当数据准备完整之后，controller的then会被执行。</p>

<p>那么对于这种情况（在AngularJS中，算是一个非常典型的场景），我们如何进行单元测试呢？</p>

<h3>测试依赖与Service的Controller</h3>

<p>通常来讲，在单元级别的测试中，我们肯定不希望Service真正的发送请求，这样就变成了集成测试，而且前端的开发完全依赖与后台的开发进度/稳定程度等。</p>

<p>所以我们需要做一个假的Service，这个假的Service仅仅在测试中存在：</p>

<p>```js</p>

<p>var app = angular.module('MyApp');</p>

<p>describe("EventController", function() {</p>

<pre><code>var scope, q;
var controllerFactory;
var mockSerivce = {};

var events = ["Event1", "Event2", "Event3"];

beforeEach(function() {
    module("MyApp");
    inject(function($rootScope, $controller, $q) {
        controllerFactory = $controller;
        scope = $rootScope.$new();
        q = $q;
    });
});

beforeEach(function() {
    var deferred = q.defer();
    deferred.resolve(events);
    mockSerivce.getEvents = jasmine.createSpy('getEvents');
    mockSerivce.getEvents.andReturn(deferred.promise);
});

function initController() {
    return controllerFactory('EventController', {
        $scope: scope,
        EventService: mockSerivce
    });
}

it("should have a events list", function() {
    initController();
    scope.$digest();
    expect(scope.events.length).toEqual(3);
    expect(scope.events).toEqual(events);
});
</code></pre>

<p>});
```</p>

<p>此处有很多值得注意的事情：</p>

<h4>在何处实例化Controller</h4>

<p>不要在注入<code>beforeEach</code>中初始化Controller，很多示例中都会在注入了<code>$controller</code>之后紧接着实例化Controller，如果Controller有多个外部的依赖的话，那么在<code>beforeEach</code>中的代码将越来越多，而且读每一个测试用例时会有一些疑惑。</p>

<p>一个好的做法是将依赖注入到<code>describe</code>中的临时变量中，然后将初始化的动作延后到一个函数中：</p>

<p>```js
function initController() {</p>

<pre><code>return controllerFactory('EventController', {
    $scope: scope,
    EventService: mockSerivce
});
</code></pre>

<p>}
```</p>

<h4>如何mock一个service</h4>

<p>由于在AngularJS中，Service一般会返回一个<a href="http://docs.angularjs.org/api/ng.$q">promise</a>对象。因此在测试时需要有一些技巧来绕过：</p>

<p>```js
var events = ["Event1", "Event2", "Event3"];</p>

<p>beforeEach(function() {</p>

<pre><code>var deferred = q.defer();
deferred.resolve(events);
mockSerivce.getEvents = jasmine.createSpy('getEvents');
mockSerivce.getEvents.andReturn(deferred.promise);
</code></pre>

<p>});
```</p>

<p>这样，当使用注入<code>EventService.getEvents().then(callback)</code>的地方就可以访问到此处的promise对象了。</p>

<p>如果添加了新的用例，</p>

<p>```js
app.controller('EventController', ['$scope', 'EventService',</p>

<pre><code>function($scope, EventService) {
    EventService.getEvents().then(function(events) {
        $scope.events = events;
        $scope.recentEvent = $scope.events[0];
    });
}]);
</code></pre>

<p>```</p>

<p>则在用例开始完成创建Controller的动作即可：</p>

<p>```js
it("should have a recent event", function() {</p>

<pre><code>initController();
scope.$digest();
expect(scope.recentEvent).toEqual("Event1");
</code></pre>

<p>});
```</p>

<p>完整的代码<a href="https://github.com/abruzzi/angularjs-controller-demo">请看此处</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bower as dependencies manager]]></title>
    <link href="http://abruzzi.github.com/2013/10/bower-as-dependencies-manager/"/>
    <updated>2013-10-09T16:38:00+11:00</updated>
    <id>http://abruzzi.github.com/2013/10/bower-as-dependencies-manager</id>
    <content type="html"><![CDATA[<h3>Bower简介</h3>

<h4>Bower安装及简单配置</h4>

<p><a href="http://bower.io/">Bower</a>是一个基于Node.js的依赖管理工具，它是一个npm的包，因此安装十分简单，由于我们需要在所有项目中都可以使用bower，因此将其安装在全局目录下：</p>

<p><code>
$ npm install -g bower
</code></p>

<p>安装完成之后，可以通过<code>bower search</code>来搜索需要的包，比如：</p>

<p><code>
$ bower search underscore
</code></p>

<p>典型的应用场景可能会是这样的，新建一个项目目录，然后运行<code>bower init</code>：</p>

<p><code>
$ mkdir -p listing
$ cd listing
$ bower init
</code>
和Grunt类似，bower会问你一些问题，比如项目名称，项目入口点，作者信息之类：</p>

<p>```
{
  "name": "listing",
  "version": "0.0.0",
  "authors": [</p>

<pre><code>"Qiu Juntao &lt;juntao.qiu@gmail.com&gt;"
</code></pre>

<p>  ],
  "main": "src/app.js",
  "license": "MIT",
  "ignore": [</p>

<pre><code>"**/.*",
"node_modules",
"bower_components",
"test",
"tests"
</code></pre>

<p>  ]
}
```</p>

<p>比如我们需要安装jQuery和underscore.js，则很简单的运行<code>bower install</code>命令即可：</p>

<p><code>
$ bower install jquery
$ bower install underscore
</code></p>

<p>如果需要团队中的其他成员可以在本地恢复我们的环境，需要在bower.json中指定<code>dependencies</code>小节：</p>

<p>```
  "dependencies": {</p>

<pre><code>"jquery": "~2.0.3",
"underscore": "~1.5.2"
</code></pre>

<p>  }
```</p>

<p>所有的JavaScript包都被安装到了本地的<code>bower_components</code>目录下，如果有了bower.json文件，那么即使本地的<code>bower_components</code>目录不存在，或者其中的包内容过期了，那么很容易用<code>bower install</code>将其更新。</p>
]]></content>
  </entry>
  
</feed>
