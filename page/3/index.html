
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>I code it</title>
  <meta name="author" content="Qiu Juntao">

  
  <meta name="description" content="一个实际的场景 大部分命令行程序都被设计成了可以被管道连接起来的，这样在命令行里可以很容易的讲很多命令串起来，从而完成极为强大的功能。比如： 1
$ find . -name "*.js" | xargs basename | uniq | wc -l &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://abruzzi.github.com/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="I code it" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-28217566-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">I code it</a></h1>
  
    <h2>Code and Life</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:abruzzi.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">文章</a></li>
  <li><a href="/about-me">关于我</a></li>
  <li><a href="/jsccp">JavaScript核心概念及实践</a></li>
  <li><a href="/lwweb">轻量级Web应用开发</a></li>
</ul>


</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/12/expect-how-to-make-yourself-more-efficient/">使用expect来自动化交互式命令</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-14T17:40:00+11:00" pubdate data-updated="true">Dec 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一个实际的场景</h3>

<p>大部分命令行程序都被设计成了可以被管道连接起来的，这样在命令行里可以很容易的讲很多命令串起来，从而完成极为强大的功能。比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ find . -name "*.js" | xargs basename | uniq | wc -l</span></code></pre></td></tr></table></div></figure>


<p>这个命令会递归的查找当前目录下所有的JavaScript文件，然后用<code>basename</code>去掉可能存在的路径字符串(比如，<code>basename path/to/file</code>会返回<code>file</code>)，然后我们使用uniq来保证查找列表中得每个条目都是唯一的，最后用<code>wc -l</code>来统计行数。</p>

<p>但是并非所有场景都不需要人的干预，比如一个<strong>vpn</strong>链接的建立过程：</p>

<ol>
<li>选择vpn的Group名称</li>
<li>填写用户名</li>
<li>填写密码</li>
<li>等待连接建立，然后程序退出</li>
</ol>


<p><img src="http://abruzzi.github.com/images/2013/12/vpnlogin.png" alt="image" /></p>

<p>像这种需要用户交互操作的程序，是无法通过常规的方式来完成自动化的。如果你经常需要做这样的操作，比如网络环境并不稳定，每天需要连接2-3次，那也是一个非常烦人的事情。</p>

<p><a href="http://expect.sourceforge.net/">Expect</a>正是为这种场景设计的。</p>

<h3>Expect简介</h3>

<p><a href="http://expect.sourceforge.net/">Expect</a>用来自动化这些<code>交互式</code>的命令行程序，比如telnet, ftp等。</p>

<p>Expect脚本非常简单，基本的模式是：</p>

<ol>
<li>启动一个命令A</li>
<li>当命令的输出中包含字符串X的话</li>
<li>输入Y</li>
</ol>


<p>用expect的脚本来表示的话，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/expect
</span><span class='line'>
</span><span class='line'>spawn A
</span><span class='line'>expect "X"
</span><span class='line'>send "Y"</span></code></pre></td></tr></table></div></figure>


<p><code>spawn</code>会启动一个进程，<code>expect</code>会负责和这个进程来交互。如果没有匹配到指定的字符串，则在一个超时时间内expect就会退出。当然可以通过<code>set timeout -1</code>来让程序expect永远等待下去。</p>

<h3>两个小例子</h3>

<h4>自动的登录到vpn服务器上</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/expect
</span><span class='line'>
</span><span class='line'>set addr "vpn.service.com.au"
</span><span class='line'>set user "qiu.juntao"
</span><span class='line'>set pass "mypassword"
</span><span class='line'>
</span><span class='line'>set timeout -1 
</span><span class='line'>spawn /opt/cisco/anyconnect/bin/vpn connect $addr
</span><span class='line'>
</span><span class='line'>expect "Group: "
</span><span class='line'>send "1\r"
</span><span class='line'>
</span><span class='line'>expect "Username: " 
</span><span class='line'>send "$user\r"
</span><span class='line'>
</span><span class='line'>expect "Password: " 
</span><span class='line'>send "$pass\r"
</span><span class='line'>
</span><span class='line'>expect "&gt;&gt; state: Connected"</span></code></pre></td></tr></table></div></figure>


<h4>自动通过ssh登录到远程</h4>

<p>另外一个问题是，如果需要这个session保持下去，比如需要自动<code>ssh</code>到一个远程的服务器上，但是又不想每次都输入认证信息，则可以进入<code>inactive</code>模式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/expect
</span><span class='line'>
</span><span class='line'>set pass "mypassword"
</span><span class='line'>
</span><span class='line'>set timeout -1 
</span><span class='line'>spawn ssh user@remote.dev.env.com
</span><span class='line'>
</span><span class='line'>expect "Password:"
</span><span class='line'>send "$pass\r"
</span><span class='line'>
</span><span class='line'>interact</span></code></pre></td></tr></table></div></figure>


<p>这样就可以完成自动登录了，而expect回一直等到你从ssh中退出。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/10/bower-as-dependencies-manager/">Bower as Dependencies Manager</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-09T16:38:00+11:00" pubdate data-updated="true">Oct 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Bower简介</h3>

<h4>Bower安装及简单配置</h4>

<p><a href="http://bower.io/">Bower</a>是一个基于Node.js的依赖管理工具，它是一个npm的包，因此安装十分简单，由于我们需要在所有项目中都可以使用bower，因此将其安装在全局目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g bower</span></code></pre></td></tr></table></div></figure>


<p>安装完成之后，可以通过<code>bower search</code>来搜索需要的包，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bower search underscore</span></code></pre></td></tr></table></div></figure>


<p>典型的应用场景可能会是这样的，新建一个项目目录，然后运行<code>bower init</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir -p listing
</span><span class='line'>$ cd listing
</span><span class='line'>$ bower init</span></code></pre></td></tr></table></div></figure>


<p>和Grunt类似，bower会问你一些问题，比如项目名称，项目入口点，作者信息之类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "name": "listing",
</span><span class='line'>  "version": "0.0.0",
</span><span class='line'>  "authors": [
</span><span class='line'>    "Qiu Juntao &lt;juntao.qiu@gmail.com&gt;"
</span><span class='line'>  ],
</span><span class='line'>  "main": "src/app.js",
</span><span class='line'>  "license": "MIT",
</span><span class='line'>  "ignore": [
</span><span class='line'>    "**/.*",
</span><span class='line'>    "node_modules",
</span><span class='line'>    "bower_components",
</span><span class='line'>    "test",
</span><span class='line'>    "tests"
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>比如我们需要安装jQuery和underscore.js，则很简单的运行<code>bower install</code>命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ bower install jquery
</span><span class='line'>$ bower install underscore</span></code></pre></td></tr></table></div></figure>


<p>如果需要团队中的其他成员可以在本地恢复我们的环境，需要在bower.json中指定<code>dependencies</code>小节：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  "dependencies": {
</span><span class='line'>    "jquery": "~2.0.3",
</span><span class='line'>    "underscore": "~1.5.2"
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>所有的JavaScript包都被安装到了本地的<code>bower_components</code>目录下，如果有了bower.json文件，那么即使本地的<code>bower_components</code>目录不存在，或者其中的包内容过期了，那么很容易用<code>bower install</code>将其更新。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/10/grunt-plugins/">Grunt的几个常用插件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-08T16:42:00+11:00" pubdate data-updated="true">Oct 8<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Grunt的几个常用插件</h3>

<h4>grunt-karma 简介</h4>

<p><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a>是一个karma的Grunt插件，<a href="http://icodeit.org/2013/10/using-karma-as-the-javascript-test-runner/">上一篇文章</a>中已经介绍了karma的基本用法。这里简单介绍如何在Grunt中使用karma。</p>

<p>首先需要安装grunt-karma插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-karma --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中加载该插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-karma');</span></code></pre></td></tr></table></div></figure>


<p>在使用karma之前，需要生成一个karma的配置文件<code>karma.conf.js</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma init karma.conf.js</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中，加入初始化karma的参数，并指定，karma需要使用<code>karma.conf.js</code>文件作为配置来运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>  karma: {
</span><span class='line'>    unit: {
</span><span class='line'>      configFile: 'karma.conf.js'
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>大多数情况下，如果要把karma作为CI的一部分，应该启动单次运行模式:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>singleRun: true</span></code></pre></td></tr></table></div></figure>


<p>这样karma会启动浏览器，运行所有的测试用例，然后退出。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');
</span><span class='line'>grunt.loadNpmTasks('grunt-karma');
</span><span class='line'>
</span><span class='line'>grunt.registerTask('default', ['jshint', 'karma']);</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/10/grunt-karma-resized.png" alt="image" /></p>

<p>注意此处的default后边带了一个任务数组，其中每个任务会按照声明的顺序依次被执行。事实上此处的&#8217;default&#8217;是后边整个列表的一个别名(alias)。</p>

<h4>grunt-jshint / grunt-uglify / grunt-concat</h4>

<p><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a>是一个用于JavaScript静态语法检查的工具，它会帮助开发者在进行较为严格的语法检查。</p>

<p>和其他的Grunt插件一样，它是以一个npm的包的形式发布的，因此安装非常容易:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-contrib-jshint --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中加载该插件:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>即可，类似的还有：用以连接所有JavaScript源代码为一个独立文件的<a href="https://github.com/gruntjs/grunt-contrib-concat">grunt-contrib-concat</a>，以及用以最小化JavaScript源码的<a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a>。</p>

<h4>自定义插件</h4>

<p><a href="https://github.com/gruntjs/grunt-init">grunt-init</a>是一个帮助开发人员快速搭建基于Grunt项目的工具，比如开发jQuery插件，Gruntfile，或者Grunt插件本身。安装方式很简单，我们需要在其他项目也用到grunt-init，因此安装在全局路径下<code>-g</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g grunt-init</span></code></pre></td></tr></table></div></figure>


<p>开发Grunt插件，我们需要一个基本的模板，将这个模板clone到home下的.grunt-init目录下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone git://github.com/gruntjs/grunt-init-gruntplugin.git ~/.grunt-init/gruntplugin</span></code></pre></td></tr></table></div></figure>


<p>然后新建一个目录，并在该目录下运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mkdir beautify
</span><span class='line'>$ cd beautify
</span><span class='line'>$ grunt-init gruntplugin</span></code></pre></td></tr></table></div></figure>


<p>grunt-init会让你回答一些问题，比如插件名称，版本号，github链接等。之后，grunt-init会生成一个基本的模板，开发者只需要完成自己插件的逻辑代码即可。逻辑实现在<code>tasks/&lt;plugin-name&gt;.js</code>中即可。</p>

<p>完成后可以通过<code>npm publish</code>来发布，发布之后，你的插件就可以向上边提到的常用插件那样被其他的开发者使用了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/10/using-karma-as-the-javascript-test-runner/">使用Karma运行JavaScript测试</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-08T10:36:00+11:00" pubdate data-updated="true">Oct 8<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Karma 简介</h3>

<p>Karma是一个JavaScript的测试运行器。事实上，Karma更是一个测试环境，使用Karma可以很方便的的运行测试(方便到你感觉不到它的实际存在)。</p>

<p>一般的TDD的开发流程为：</p>

<ol>
<li>编写测试(一个会失败的case)</li>
<li>运行测试，并看到这个测试失败</li>
<li>编写代码(足够让测试通过的代码)</li>
<li>运行测试，并看到测试通过</li>
<li>重构</li>
<li>运行测试，并看到测试通过</li>
</ol>


<p>然后<strong>如此循环</strong>，而在前端开发中，很长一段时间，这个流程受限于开发环境，比如添加了一个新的JavaScript源文件，开发者需要在HTML中引入相应地文件，以及响应的测试文件，然后刷新页面(有时候还需要清空浏览器缓存)。</p>

<p>在这个过程中，开发者真正关注的就是编写测试，运行测试，编写实现，重构等等，需要不断的重复这个过程。而不是关注如刷新页面，清空缓存，修改HTML对脚本的引用等武馆的工作。</p>

<p>Karma就是这样一个开发环境，开发者指定需要测试的脚本/测试文件，需要运行的浏览器等信息，Karma会在后台自动监控文件的修改，并启动一个浏览器与Karma的服务器连接，这样当源代码或者测试发生修改后，Karma会自动运行测试。</p>

<p>开发者可以指定不同的浏览器，甚至可以跨设备。由于Karma只是一个运行器，你可以使用项目中正在使用的测试框架如Jasmine，QUnit等，甚至可以自定义适配器来支持你自己的测试框架。</p>

<h3>运行Karma</h3>

<p>Karma需要一个配置文件来知道哪些文件需要被加载，需要被监控(当文件内容发生变化时，尝试运行测试)，这个配置文件可以通过Karma自带的参数来生成。</p>

<h4>基本使用</h4>

<p>Karma被实现为一个npm的包，所以可以通过</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g karma</span></code></pre></td></tr></table></div></figure>


<p>安装之后，可以生成karma需要的配置文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma init my.conf.js</span></code></pre></td></tr></table></div></figure>


<p>karma会让你回答一些问题，比如是哪种测试框架，哪些文件需要被测试，哪些浏览器需要被考虑等。生成的配置文件的一个片段是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// base path, that will be used to resolve files and exclude
</span><span class='line'>basePath = ''; 
</span><span class='line'>
</span><span class='line'>// list of files / patterns to load in the browser
</span><span class='line'>files = [ 
</span><span class='line'>  JASMINE,
</span><span class='line'>  JASMINE_ADAPTER,
</span><span class='line'>  'src/**/*.js',
</span><span class='line'>  'test/**/*spec.js'
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>// web server port
</span><span class='line'>port = 9876;
</span><span class='line'>
</span><span class='line'>// browsers
</span><span class='line'>browsers = ['Chrome'];
</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong>更新</strong>
新的配置文件生成脚本会生成更加<strong>模块化</strong>的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.exports = function(config) {
</span><span class='line'>  config.set({
</span><span class='line'>  
</span><span class='line'>    frameworks: ['jasmine'],
</span><span class='line'>
</span><span class='line'>    files: [
</span><span class='line'>      'src/**/*.js',
</span><span class='line'>      'test/**/*spec.js'
</span><span class='line'>    ],
</span><span class='line'>
</span><span class='line'>    port: 9876,
</span><span class='line'>
</span><span class='line'>    browsers: ['Chrome'],
</span><span class='line'>
</span><span class='line'>    singleRun: true
</span><span class='line'>    
</span><span class='line'>  });
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>生成配置文件之后，可以通过命令来启动Karma服务器，同时指定使用<code>my.conf.js</code>文件作为配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ karma start my.conf.js</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/10/karma-run-resized.png" alt="image" /></p>

<h4>调试及其他</h4>

<p>很多时候，我们只想要运行某一个suite中的所有测试用例，而不是整个工程，比如在Jasmine中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>describe("Controller User", function() {
</span><span class='line'>  it("add user", function() {});
</span><span class='line'>  it("search users", function() {});
</span><span class='line'>  it("delete user", function() {});
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>只需要将<code>describe</code>修改为<code>ddescribe</code>即可，类似的，如果只需要运行某一个测试用例，只需要将<code>it</code>修改为<code>iit</code>即可。</p>

<p>这在运行调试某个测试或者某段特定代码时非常好用。另外，Karma还提供了debugger功能，在测试用例中加入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>debugger;</span></code></pre></td></tr></table></div></figure>


<p>即可。由于在运行时，karma实际上会启动一个真实地浏览器，所以可以在浏览器的developer-tool中进行实际的调试。需要注意的是，当进入调试模式时，需要启动developer-tool(在Karma启动的那个浏览器窗口中)。</p>

<p><img src="http://abruzzi.github.com/images/2013/10/karma-debug-resized.png" alt="image" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/10/using-grunt-as-your-build-tool/">使用Grunt作为构建工具(build Tool)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-07T18:14:00+11:00" pubdate data-updated="true">Oct 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Grunt简介</h3>

<p>Grunt是一个基于JavaScript的构建工具。和其他的构建工具类似，grunt主要用于一些将一些繁琐的工作自动化，比如运行测试，代码的静态检查，压缩JavaScript源代码等等。</p>

<h4>安装grunt-cli</h4>

<p>要在命令行运行grunt，需要安装grunt的命令行工具：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install -g grunt-cli</span></code></pre></td></tr></table></div></figure>


<p>grunt-cli本身并不会提供Grunt构建工具，而只是一个Grunt的调用器。<code>-g</code>参数表示将grunt-cli安装在全局的路径中，这样我们可以在不同的项目中使用grunt-cli，而由于grunt-cli本身只是一个调用器，所以对于不同的项目，真正运行的Grunt可以是不同的版本，而命令行的借口则完全一致。</p>

<p>grunt-cli提供的命令行可执行文件的名称为<code>grunt</code>，这个工具每次运行时都会检查当前目录下的Grunt。</p>

<h4>使用grunt-cli</h4>

<p>如果在一个既有的npm模块中，可以很容易的加入grunt的支持，只需要修改package.json，加入依赖，然后运行<code>npm install</code>来完成依赖的安装即可。</p>

<p>如果是一个新启动的项目，那么在项目中添加两个文件：package.json和Gruntfile。其中package.json用来定义当前项目是一个npm的模块，而Gruntfile用来定义具体的任务，以及加载Grunt的其他插件(Grunt提供丰富的插件，比如运行测试，代码静态检查等功能都是通过插件来完成的)</p>

<h4>package.json</h4>

<p>package.json定义了一个工程的元数据，这些数据被npm管理器来使用，npm本身提供了<code>init</code>参数可以很容易的生成一个package.json文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm init </span></code></pre></td></tr></table></div></figure>


<p>根据提示可以很容易的生成一个新的package.json</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "name": "chapter-testing",
</span><span class='line'>  "version": "0.0.0",
</span><span class='line'>  "description": "This is the demo for how to use grunt.js",
</span><span class='line'>  "main": "my.conf.js",
</span><span class='line'>  "directories": {
</span><span class='line'>    "test": "test"
</span><span class='line'>  },
</span><span class='line'>  "scripts": {
</span><span class='line'>    "test": "echo \"Error: no test specified\" && exit 1"
</span><span class='line'>  },
</span><span class='line'>  "author": "Juntao",
</span><span class='line'>  "license": "BSD-2-Clause"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>一般来说，package.json文件中有一个<code>devDependencies</code>的小节，定义了本项目的外部依赖。</p>

<p>可以通过运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt --save-dev</span></code></pre></td></tr></table></div></figure>


<p>来为工程文件package.json添加<code>devDependencies</code>小节的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"devDependencies": {
</span><span class='line'>  "grunt": "~0.4.1"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>该命令会为工程添加一条依赖关系，如果别人拿到这个文件，就可以在本地“复原”你的开发环境，以保证整个团队使用同样地<strong>库</strong>文件。</p>

<p>完成之后，该命令会在本地生成一个目录(如果没有的话)<code>node_modules</code>，其中包括了完成的Grunt的可执行文件，这时候在命令行运行grunt(由grunt-cli提供的命令行工具)，就会尝试在此目录中查找Grunt的可执行文件。</p>

<h4>Gruntfile</h4>

<p>要运行Grunt，还需要定义你自己的任务，默认的任务定义在Gruntfile中，Gruntfile有一定的格式。</p>

<p>所有的任务需要定义在一个函数中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.exports = function(grunt) {
</span><span class='line'>  // task defination
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>一般而言，使用Grunt会读取一些项目的信息(定义在package.json中)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    pkg: grunt.file.readJSON('package.json')
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>亦可以在这个时刻指定一些其他的插件的选项：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    pkg: grunt.file.readJSON('package.json'),
</span><span class='line'>    jshint: {
</span><span class='line'>        all: ['Gruntfile.js', 'lib/**/*.js', 'test/**/*.js']
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>然后需要加载其他的插件(如果需要的话)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>最后，需要指定一个grunt的入口任务(<code>default</code>任务)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.registerTask('default', function() {
</span><span class='line'>  console.log("default task");
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>然后运行<code>grunt</code>，我们此处定义的default任务仅仅在控制台上打印一行字符串:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ grunt
</span><span class='line'>Running "default" task
</span><span class='line'>default task
</span><span class='line'>
</span><span class='line'>Done, without errors.</span></code></pre></td></tr></table></div></figure>


<h3>Grunt插件</h3>

<p>Grunt已经得到了很多的开源软件贡献者的支持，已经又众多的插件被开发出来。比如:</p>

<ol>
<li><a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a></li>
<li><a href="https://github.com/gruntjs/grunt-contrib-qunit">grunt-contrib-qunit</a></li>
<li><a href="https://github.com/karma-runner/grunt-karma">grunt-karma</a></li>
</ol>


<p>等等，使用这些插件可以快速的为你的项目开发提供很多的便利，以grunt-jshint为例，
首先需要安装此插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ npm install grunt-contrib-jshint --save-dev</span></code></pre></td></tr></table></div></figure>


<p>然后在grunt.initConfig中指定jshint需要的参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.initConfig({
</span><span class='line'>    jshint: {
</span><span class='line'>        files: ['js/*.js'],
</span><span class='line'>        options: {
</span><span class='line'>            ignores: ['js/jquery*.js']
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>然后加载此插件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.loadNpmTasks('grunt-contrib-jshint');</span></code></pre></td></tr></table></div></figure>


<p>最后，可以将<code>jshint</code>加入到默认的任务中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grunt.registerTask('default', ['jshint']);</span></code></pre></td></tr></table></div></figure>


<p>运行结果<code>可能</code>如下:</p>

<p><img src="http://abruzzi.github.com/images/2013/10/jshint.png" alt="image" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/08/quick-api-development-by-grape/">使用Grape快速开发API</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-04T10:29:00+10:00" pubdate data-updated="true">Aug 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Grape简介</h3>

<p><a href="http://intridea.github.io/grape">Grape</a>是一个基于Rack的非常轻量级的框架，用于快速的开发API。一般来说，Rails对于单独的API来说，太过于重量级；而Sinatra虽然足够小巧，但是又没有为开发API提供足够的默认支持（如果从可控制性，灵活性上来说，Sinatra可能更好一些，但是如果有专门的更好用的工具，为什么不用呢？）。</p>

<p>安装非常简便：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install grape</span></code></pre></td></tr></table></div></figure>


<p>或者使用在自己的Gemfile中，与其他的gem一起搭建API:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem 'grape'</span></code></pre></td></tr></table></div></figure>


<h3>为既有系统添加API</h3>

<h4>简单一试</h4>

<p>之前的一篇介绍<a href="http://icodeit.org/2013/05/using-active-record-as-a-standalone-orm/">ActiveRecord在既有系统中使用</a>的文章中，我使用ActiveRecord为既有的数据库visitor中的三个表(visitor, listGroup, listGroupItem)建立了ruby对应的模型。现在我们可以为这些模型包装一组API，以方便客户端（消费者）可以通过web来访问。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module MySys
</span><span class='line'>    class API &lt; Grape::API
</span><span class='line'>        format :json
</span><span class='line'>
</span><span class='line'>        resource :visitors do
</span><span class='line'>
</span><span class='line'>            desc "get all visitor information"
</span><span class='line'>            get do
</span><span class='line'>                Visitor.limit(20)
</span><span class='line'>            end
</span><span class='line'>
</span><span class='line'>        end
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>首先，MySys::API扩展了Grape::API。<code>format</code>定义我们的API会产生JSON格式的输出，resource定义了这一组API是为资源visitors提供的，因此访问API的url为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/visitors/</span></code></pre></td></tr></table></div></figure>


<p>当然，grape提供一个很方便的设置prefix，可以使得API的路径更有意义:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>format :json
</span><span class='line'>prefix "mysys"</span></code></pre></td></tr></table></div></figure>


<p>url则相应地变为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/mysys/visitors/</span></code></pre></td></tr></table></div></figure>


<h4>处理参数</h4>

<p>在对参数的处理上，grape也非常灵活，比如接上例，我们想要获取某一个具体的用户的信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001</span></code></pre></td></tr></table></div></figure>


<p>我们可以添加一个新的endpoint：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "return a visitor"
</span><span class='line'>params do
</span><span class='line'>    requires :visitor_uid, :type =&gt; String, :desc =&gt; "visitor id"
</span><span class='line'>end
</span><span class='line'>route_param :visitor_uid do
</span><span class='line'>    get do
</span><span class='line'>        Visitor.find(params[:visitor_uid])
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>params中要求，需要一个类型为String的参数visitor_uid。然后在handler中，通过params来引用这个参数的值。</p>

<h4>助手函数(Helper)</h4>

<p>Grape允许开发者将编解码，权限校验等等的通用的操作分离出来，放入助手函数，这些Helper可以被所有的API使用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>helpers do
</span><span class='line'>    def generate_default_visitor(email, site) 
</span><span class='line'>        {
</span><span class='line'>            :visitor_uid =&gt; SecureRandom.hex,
</span><span class='line'>            :password_expiration =&gt; (Time.now + 60 * 60 * 24),
</span><span class='line'>            :last_used_timestamp =&gt; (Time.now - 60 * 60 * 24),
</span><span class='line'>            :visitor_login_id =&gt; email,
</span><span class='line'>            :site_name =&gt; site
</span><span class='line'>        }
</span><span class='line'>    end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>使用上边定义的助手函数<code>generate_default_visitor</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "create a visitor"
</span><span class='line'>params do
</span><span class='line'>    requires :email, :type =&gt; String, :desc =&gt; "Email address"
</span><span class='line'>    requires :site, :type =&gt; String, :desc =&gt; "Site"
</span><span class='line'>end
</span><span class='line'>post do
</span><span class='line'>    attr = generate_default_visitor(params[:email], params[:site])
</span><span class='line'>    visitor = Visitor.new attr
</span><span class='line'>    visitor.visitor_uid = attr[:visitor_uid]
</span><span class='line'>    visitor.save
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<h3>对API进行测试</h3>

<p>通过Web测试API有非常多的方式，比如通过浏览器的插件(POSTMan)，RSpec，但是我最喜欢，也是最轻便的方式是通过命令行工具curl：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl http://localhost:9292/visitors/8a9d82b13b9786e1013b978766150001</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -H "Content-Type: application/json" -X POST -d "{\"email\":\"jtqiu@tw.com\", \"site\":\"mysys\"}" http://localhost:9292/visitors/</span></code></pre></td></tr></table></div></figure>


<p>命令行的程序curl是一个非常灵活，强大的工具，可以定制HTTP头信息，User Agent，支持所有的HTTP动词，最重要的是，在命令行很容易将工具们组合在一起，并完成自动化。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/08/rack-it-up/">Rack It Up</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-02T07:38:00+10:00" pubdate data-updated="true">Aug 2<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Rack it up (proc)</h3>

<p>一个最简单的rack应用程序可以是：一个简单的ruby对象，包含了一个call方法。这个call方法接受一个参数，并返回一个有三个元素的数组即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def call(env)
</span><span class='line'>  [200, {}, ["content"]]
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>其中参数env将被rack用作HTTP请求对象来传递进来，而函数的返回值与HTTP响应对应：分别为状态码，HTTP头信息以及响应内容。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/07/write-a-jquery-plugin-step-by-step/">逐步编写一个jQuery插件(todoify)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-20T13:04:00+10:00" pubdate data-updated="true">Jul 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>最终结果</h3>

<p>这篇文章将讨论如何编写一个简单的jQuery插件的基本步骤和实践，最后完成的时候，我们会得到一个管理todo的插件（而且还是一个比较灵活，易于定制的todo插件）。事实上，这个插件可以工作在所有与管理todo类似的应用场景中，比如gmail的搜索框中的token等，豆瓣读书里的tags管理等等。</p>

<p><img src="http://abruzzi.github.com/images/2013/07/todo-origin.resized.png" alt="默认设置" /></p>

<p>上例中HTML结构如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;div id="container"&gt;
</span><span class='line'>    &lt;input type="text" id="input" /&gt;
</span><span class='line'>    &lt;div id="todos" /&gt;
</span><span class='line'>&lt;/div&gt;</span></code></pre></td></tr></table></div></figure>


<p>下面的JavaScript代码将会找到id为<em>input</em>的输入框，并将它<strong>变为</strong>一个todolist的控制器，并将新加入的内容添加到id为<em>todos</em>的容器中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#input").todoify({
</span><span class='line'>  container: "#todos"
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>如果需要定制item的外观，可以定义模板并自定义渲染函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#thing-input").todoify({
</span><span class='line'>    container: "#thing-todos",
</span><span class='line'>    template: "&lt;section class='todoItem'&gt;&lt;header&gt;&lt;%= todo %&gt;&lt;/header&gt;&lt;a&gt;remove&lt;/a&gt;&lt;/section&gt;",
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>
</span><span class='line'>        cont.find("a").click(function(event){
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><img src="http://abruzzi.github.com/images/2013/07/todo-customized.resized.png" alt="Item定制" /></p>

<h3>jQuery插件基础知识</h3>

<h4>简单流程</h4>

<p>通常使用jQuery的流程是这样的：通过选择器选择出一个jQuery对象（集合），然后为这个对象应用一些预定义的函数，如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$(".artile .title").mouseover(function(){
</span><span class='line'>  $(this).css({
</span><span class='line'>      "background-color": "red",
</span><span class='line'>      "color": "white"
</span><span class='line'>  });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>我们如果要定义自己的插件，预期其被调用的方式和此处的<em>mouseover</em>并无二致。这需要将我们定义的函数attach到jQuery对象的fn属性上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$.fn.hltitle = function() {
</span><span class='line'>  this.mouseover(function(){
</span><span class='line'>      $(this).css({
</span><span class='line'>          "background-color": "red",
</span><span class='line'>          "color": "white"
</span><span class='line'>      })
</span><span class='line'>  })
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>$('.article .title').hltitle();</span></code></pre></td></tr></table></div></figure>


<p>jQuery的一个很明显的特点是其链式操作，即每次调用完成一个函数/插件之后仍然会返回jQuery对象本身，这个需要我们在插件函数的最后一行返回<em>this</em>。这样插件的使用者会像使用其他函数/插件一样很方便的将调用连起来。</p>

<p>另外一个问题是注意命名冲突（$是一个合法的标示符，而且被众多的JavaScript库在使用），所以可以通过匿名执行函数来避免：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>  $.fn.hltitle = function() {
</span><span class='line'>      //...
</span><span class='line'>  }
</span><span class='line'>}(jQuery));</span></code></pre></td></tr></table></div></figure>


<h4>需要注意的问题</h4>

<p>上面是一个最简单的插件定义，为了插件更加灵活，我们需要尽可能多的将配置项暴露给插件的用户，比如提供一些默认选项，如果用户不提供配置，则插件按照默认配置来工作，但是用户可以通过修改配置来定制插件的行为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>  $.fn.hltitle = function(options) {
</span><span class='line'>      var defaults = {
</span><span class='line'>          "background-color": "red",
</span><span class='line'>          "color": "white"                
</span><span class='line'>      };
</span><span class='line'>      
</span><span class='line'>      var settings = $.extend(defaults, options);
</span><span class='line'>      
</span><span class='line'>      return this.mouseover(...);
</span><span class='line'>  }
</span><span class='line'>}(jQuery));
</span></code></pre></td></tr></table></div></figure>


<h3>Todoify</h3>

<p>我们的插件是一个遵循上述原则的简单插件，基本的步骤如下：</p>

<ul>
<li>将给定的input包装成一个jQuery对象</li>
<li>需要一个默认的放置todolist的容器元素</li>
<li>为input注册keypress事件（如果用户按Enter，则触发add事件，添加一个新条目到容器）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(function($){
</span><span class='line'>    $.fn.todoify = function(options) {
</span><span class='line'>        var settings = $.extend({
</span><span class='line'>            container: "body",
</span><span class='line'>            template: "&lt;span class='todo-item'&gt;&lt;%= todo %&gt;&lt;/span&gt;",
</span><span class='line'>            renderItem: function(item) {
</span><span class='line'>              return $(_.template(this.template, {todo: item}));
</span><span class='line'>            }
</span><span class='line'>        }, options);
</span><span class='line'>
</span><span class='line'>        $(this).keypress(function(event){
</span><span class='line'>            if(event.keyCode == 13) {
</span><span class='line'>                var item = $(this).val();
</span><span class='line'>                $(settings.container).append(settings.renderItem(item));
</span><span class='line'>                $(this).val("").focus();
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return this;
</span><span class='line'>    }
</span><span class='line'>}(jQuery));</span></code></pre></td></tr></table></div></figure>


<p>此处为了防止创建众多的DOM元素，然后依次插入到正确地节点上，我使用了underscore.js的template，不过此处并非重点，略微一提。</p>

<p>如果用户想要更好地定制性，比如用户想要apply自己的class，定义自己的模板，或者注册新的事件（删除一条todo），显然我们需要更多的options：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var settings = $.extend({
</span><span class='line'>    data: [],
</span><span class='line'>    template: "&lt;div class='todo'&gt;&lt;h3&gt;&lt;%= todo %&gt;&lt;/h3&gt;&lt;span&gt;X&lt;/span&gt;&lt;/div&gt;",
</span><span class='line'>    container: "body",
</span><span class='line'>    renderTemplate: function(item) {
</span><span class='line'>        return $(_.template(this.template, {todo: item}));
</span><span class='line'>    },
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>        cont.find("span").click(function(event) {
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>}, options);</span></code></pre></td></tr></table></div></figure>


<p>这里定义了默认的close事件需要attach到span（定义在模板中）上，如果插件的用户需要自己绘制模板，并且注册事件，那么会像文章开头的那个实例一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#thing-input").todoify({
</span><span class='line'>    container: "#thing-todos",
</span><span class='line'>    template: "&lt;section class='todoItem'&gt;&lt;header&gt;&lt;%= todo %&gt;&lt;/header&gt;&lt;a&gt;remove&lt;/a&gt;&lt;/section&gt;",
</span><span class='line'>    renderItem: function(item) {
</span><span class='line'>        var cont = this.renderTemplate(item);
</span><span class='line'>
</span><span class='line'>        cont.find("a").click(function(event){
</span><span class='line'>            cont.remove();
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        return cont;
</span><span class='line'>    }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h3>进一步改进</h3>

<p>目前，todoify还没有与后台进行任何的通信，如果可以和后台的RESTFul的API集成的话，这个插件将会有更多的使用场景。</p>

<p>简单来讲，只需要为插件提供更多选项，并提供回调函数即可，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$("#input").todoify({
</span><span class='line'>  restful: 'http://app/todos',
</span><span class='line'>  onadd: function(item){
</span><span class='line'>      //...
</span><span class='line'>  },
</span><span class='line'>  ondelete: function(item){
</span><span class='line'>      //...
</span><span class='line'>  }
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>然后加入一些ajax的调用即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/06/macro-in-common-lisp/">Common Lisp中的宏(Macro)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-15T11:12:00+10:00" pubdate data-updated="true">Jun 15<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Lisp与其他语言之区别</h4>

<p>函数式编程，前缀表达式，繁多的括号，奇怪的操作符等等，这些都足以让Lisp和其他编程语言看起来有很大的区别，但是这些区别并非本质上的差异。让Lisp和其他编程语言有本质区别的是它对<code>宏</code>的支持。</p>

<p>C语言中的，被称为<code>宏</code>的预编译系统自有其好处，但是和Lisp中的<code>宏</code>比起来，好比的Notepad和Vim或者Emacs之间的差异。</p>

<h4>数据与代码</h4>

<p>在Lisp中，数据和代码间的差异非常小，<a href="http://icodeit.org/2013/06/common-lisp-basic/">上一篇文章</a>简单讨论了<code>引用</code>的基本概念，其中对数据与代码的差异已经有所涉及。</p>

<h4>宏(Macro)</h4>

<p>简而言之，<code>宏</code>即替换，在Lisp中，可以通过程序生成代码(s-expr)，而这些代码又可以被执行（当然，需要是合法的s-expr）。这一点赋予了<code>宏</code>无限的可能性，比如定义一个新的语法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro only (condition &rest body)
</span><span class='line'>  `(if ,condition (progn ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>Lisp中函数macroexpand-1可以用来查看调用时<code>宏</code>是如何展开的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(only (&gt; x 10) (format t "big than 10")))   
</span><span class='line'>
</span><span class='line'>(IF (&gt; X 10)
</span><span class='line'>    (PROGN (FORMAT T "big than 10")))</span></code></pre></td></tr></table></div></figure>


<p>上例中，<code>(&gt; x 10)</code>被作为<code>condition</code>，而<code>(format t "big than 10")</code>作为<code>body</code>传递给了宏。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(only (&gt; x 10) 
</span><span class='line'>  (format t "big than 10")
</span><span class='line'>  (format t "~%")))
</span><span class='line'>
</span><span class='line'>(IF (&gt; X 10)
</span><span class='line'>    (PROGN (FORMAT T "big than 10") (FORMAT T "~%")))</span></code></pre></td></tr></table></div></figure>


<p>使用<code>progn</code>是为了让剩余的多条语句(如果有的话)，逐条执行，并返回最后一条语句的值（正如在函数中那样）。</p>

<h4>可能的陷阱</h4>

<p><a href="http://icodeit.org/2013/06/common-lisp-basic/">上一篇文章</a>中讨论了迭代的通用方式<code>do</code>，虽然很通用，但是三段式的定义略显繁琐。</p>

<p>我们可以编写一个简单的宏<code>ntimes</code>，它接受一个数字参数N和一个代码块Block，并执行N次这个Block：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(ntimes 10 (format t "Hello, world~%"))</span></code></pre></td></tr></table></div></figure>


<p>将打印10次<code>Hello, world</code>，<code>宏</code>的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  `(do ((x 0 (1+ x)))
</span><span class='line'>       ((&gt;= x ,n))
</span><span class='line'>     ,@prog))</span></code></pre></td></tr></table></div></figure>


<p>但是这个宏在某些场景下不能如预期般的工作：比如当在使用<code>ntimes</code>的context中，本身有一个变量x，而在代码块Block中，尝试修改这个x，会发生什么呢？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(let ((x 10))
</span><span class='line'>    (ntimes 5
</span><span class='line'>       (format t "~a~%" x)))</span></code></pre></td></tr></table></div></figure>


<p>预期的执行结果为打印5次10，但是事实上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0
</span><span class='line'>1
</span><span class='line'>2
</span><span class='line'>3
</span><span class='line'>4</span></code></pre></td></tr></table></div></figure>


<p>这是因为<code>宏</code>的内部使用了同名的变量，而由于作用域的原因，外部的let被屏蔽了，事实上宏的设计者貌似无法避免这类事情的发生，因为使用者如何使用是不能预料的，Lisp提供了另一种解决方案(类似于UUID)，使用<code>gensym</code>，以避免这种情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (gensym)
</span><span class='line'>
</span><span class='line'>#:G778
</span><span class='line'>&gt; (gensym)
</span><span class='line'>
</span><span class='line'>#:G779</span></code></pre></td></tr></table></div></figure>


<p>函数<code>gensym</code>每次都会分配一个新的ID作为标示，因此宏的实现可以修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  (let ((g (gensym)))
</span><span class='line'>    `(do ((,g 0 (+ ,g 1)))
</span><span class='line'>         ((&gt;= ,g ,n))
</span><span class='line'>       ,@prog)))</span></code></pre></td></tr></table></div></figure>


<p>事实上，这个版本还是有一个隐藏的bug：这里我们预期的n是一个数字，而实际上使用者是可以传入一个表达式如：<code>(setf x (- x 1))</code>，而由于<code>do</code>的特性，迭代中每次都查看测试条件是否满足<code>(&gt;= ,g ,n)</code>，这会使得<code>(setf x (- x 1))</code>会被执行N次。也就是说，当数字N是一个有副作用的表达式时，我们的宏的行为是错误的，可以通过引入额外的临时变量来解决这个问题。</p>

<p>即在最开始的适合对N求值并赋值给一个临时变量，然后每次的测试都是基于这个临时变量而来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro ntimes (n &rest prog)
</span><span class='line'>  (let ((g (gensym))
</span><span class='line'>        (h (gensym)))
</span><span class='line'>    `(let ((,h ,n))
</span><span class='line'>       (do ((,g 0 (+ ,g 1)))
</span><span class='line'>           ((&gt;= ,g ,h))
</span><span class='line'>         ,@prog))))</span></code></pre></td></tr></table></div></figure>


<h4>定义新的语法</h4>

<p>这一小节的一个例子是for循环的<code>宏</code>定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro for (var start stop &body body)
</span><span class='line'>  (let ((gstop (gensym)))
</span><span class='line'>    `(do ((,var ,start (1+ ,var))
</span><span class='line'>          (,gstop ,stop))
</span><span class='line'>         ((&gt; ,var ,gstop))
</span><span class='line'>       ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>这样，可以很方便的使用我们比较熟悉的for语句了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (for x 1 5
</span><span class='line'>     (print x))
</span><span class='line'>
</span><span class='line'>1 
</span><span class='line'>2 
</span><span class='line'>3 
</span><span class='line'>4 
</span><span class='line'>5 </span></code></pre></td></tr></table></div></figure>


<p>另一个有意思的例子是求平均值的<code>avg</code>宏：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro avg (&rest args)
</span><span class='line'>  `(/ (+ ,@args) ,(length args)))</span></code></pre></td></tr></table></div></figure>


<p>由于Lisp中采取前缀表达式，因此像<code>+</code>这种函数可以很方便的apply到一个列表上，如果是中缀表达式，则这种形式的抽象就变得非常复杂。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (macroexpand-1 '(avg 1 2 3 4 5 6 7 8 9 10))
</span><span class='line'>(/ (+ 1 2 3 4 5 6 7 8 9 10) 10)
</span><span class='line'>
</span><span class='line'>&gt; (avg 1 2 3 4 5 6 7 8 9 10)
</span><span class='line'>11/2</span></code></pre></td></tr></table></div></figure>


<hr />

<p>附：文中部分代码示例来源于《ANSI Common Lisp》一书。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2013/06/common-lisp-basic/">Common Lisp 里的一些基本概念</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-13T16:15:00+10:00" pubdate data-updated="true">Jun 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Common Lisp</h3>

<p>之前一直说JavaScript是一门被误解很深的语言，现在学习了一段时间Lisp后发现，Lisp才是！Lisp一直为人所诟病的是它虽然很强大，但是有点学院派，难当大用。但是读了七，八章<a href="http://book.douban.com/subject/6859720/">《Practical Common Lisp》</a>和几章<a href="http://book.douban.com/subject/1456906/">《ANSI Common Lisp》</a>之后发现，怎么就学院派了，其他编程语言能处理的，Lisp一样可以处理，其他语言处理不了的（或者很繁琐的，比如java中的循环，map之类），Lisp却能处理。</p>

<p>Lisp本质上是一个抽象语法树（AST）而已，但是又提供了一些操作这个AST的方法（比如强大的宏），这样很容易用Lisp开发出来一个新的DSL。用函数式编程的好处之一就是在编写完一个应用程序之后，通常还可以获得一个新的语言（于业务领域很匹配的语言）。</p>

<p><a href="http://zh.wikipedia.org/wiki/Common_Lisp">Common Lisp</a>本身是Lisp的一个方言，是有一个标准来定义，其目的是为了标准化众多的Lisp分支而定。</p>

<h4>sbcl环境</h4>

<p><a href="http://icodeit.org/2013/06/setup-lisp-development-env-on-mac/">上一篇文章</a>已经介绍了如何在Mac下配置Common Lisp的开发环境：</p>

<p><img src="http://abruzzi.github.com/images/2013/06/sbcl.resized.png" alt="image" /></p>

<h4>引用（quote）</h4>

<p>由于在Lisp中，数据和代码都是通过S-expr来表示，所以需要用一种标记法来告诉解释器：这个表达式表示数据/代码。这就是引用的作用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (+ 1 2 3 4 5)
</span><span class='line'>15
</span><span class='line'>
</span><span class='line'>&gt; '(+ 1 2 3 4 5)
</span><span class='line'>(+ 1 2 3 4 5)</span></code></pre></td></tr></table></div></figure>


<p>解释器会将s-expr的第一项作为函数(car)，而将后续的元素(cdr)作为参数传递给第一项来调用，并求值。可以通过引用（quote）来阻止解释器这样解释。</p>

<h4>反引号(`)</h4>

<p>与引用对应的，有一个反引号形式的引用(在键盘上1的左边)。一般的用法上，它与<code>quote</code>的含义一样，都是防止解释器解释被引用的列表。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;`(a b c)
</span><span class='line'>(a b c)
</span><span class='line'>
</span><span class='line'>&gt;`(a b (+ 1 2))
</span><span class='line'>(a b (+ 1 2))</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>但是，反引号引用的列表提供了重新启动求值的能力，这……，我的意思是，如上式中，如果想要将<code>(+1 2)</code>这个子列表求值，怎么做到呢？反引号引用提供了这个能力，用逗号(,)作为子列表的前缀即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;`(a b ,(+ 1 2))
</span><span class='line'>(a b 3)</span></code></pre></td></tr></table></div></figure>


<p>这个当然在此刻看起来毫无用处，或者感觉略有画蛇添足之嫌，但是在宏中，这个操作符却有很广泛的用途，这里有一个有意思的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defun foo (x) 
</span><span class='line'>  (only (&gt; x 10) (format t "big than 10")))</span></code></pre></td></tr></table></div></figure>


<p>我们可以通过<code>if</code>来实现此处的only，当only之后的条件满足的话，就执行后续的所有语句：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(defmacro only (condition &rest body)
</span><span class='line'>  `(if ,condition (progn ,@body)))</span></code></pre></td></tr></table></div></figure>


<p>此处可以看到，对于宏代码体中，有部分代码我们不需要引用，如(if, progn)，而另外一部分则需要解释器真实地去解释来获得值。另外，我们需要宏本身返回一个列表(被引用的列表)。</p>

<h4>通用的循环（do）</h4>

<p><code>do</code>是Lisp中通用的处理迭代的操作符，可以在其中创建局部变量：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do ((i 0 (1+ i)))
</span><span class='line'>    ((&gt;= i 4))
</span><span class='line'>  (print i))</span></code></pre></td></tr></table></div></figure>


<p><code>do</code>的格式比较复杂：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do (variable-definition*)
</span><span class='line'>  (end-test-form result-form*)
</span><span class='line'>  statement*)</span></code></pre></td></tr></table></div></figure>


<p>其中，变量声明部分的格式为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(variable init-form step-form)</span></code></pre></td></tr></table></div></figure>


<p>然后是测试，如果测试成功，有一个可选的返回值（上例中为nil），然后是statement部分，如果测试失败，则执行一次statement，然后通过step-from修改变量的值，测试，执行。</p>

<p>上例的代码会打印<strong>0-3</strong>的数字。<code>do</code>的另外一个功用是它支持多个变量并发的循环，这是(dolist, dotimes等无法完成的，所以在很多宏中，do是不二之选)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(do ((n 0 (1+ n))
</span><span class='line'>     (cur 0 next)
</span><span class='line'>     (next 1 (+ cur next)))
</span><span class='line'>    ((= 10 n) cur))</span></code></pre></td></tr></table></div></figure>


<p>这个例子则没有statement部分，当n等于10这个测试条件成立后，返回cur当前的值。</p>

<h4>apply 和 funcall</h4>

<p><code>apply/call</code> 这两个函数当然是FP编程语言的必备了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (apply #'(lambda (x y) (+ x y)) '(3 4))
</span><span class='line'>7
</span><span class='line'>
</span><span class='line'>&gt; (funcall #'(lambda (x y) (+ x y)) 3 4)
</span><span class='line'>8</span></code></pre></td></tr></table></div></figure>


<p>注意这里的<code>#'</code>操作符，它表示对函数对象的引用，就像<code>'</code>是对list的引用一样。</p>

<h4>list的基本操作</h4>

<p>构造列表（cons），<code>cons</code>的作用是将两个对象结合成一个对象（这个新的对象由两部分组成），这两部分分别由<code>car</code>,<code>cdr</code>来引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (cons 'a nil)
</span><span class='line'>(a)
</span><span class='line'>
</span><span class='line'>&gt; (cons 'a (cons 'b nil))
</span><span class='line'>(a b)</span></code></pre></td></tr></table></div></figure>


<p>当然可以用更简洁的方式：使用list函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (list a b)
</span><span class='line'>(a b)</span></code></pre></td></tr></table></div></figure>


<p><code>car</code>, <code>cdr</code>的用法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; (setf x '(a b c (d e)))
</span><span class='line'>(a b c (d e))
</span><span class='line'>
</span><span class='line'>&gt; (car x)
</span><span class='line'>a
</span><span class='line'>
</span><span class='line'>&gt; (cdr x)
</span><span class='line'>(b c (d e))
</span></code></pre></td></tr></table></div></figure>


<p>有了<code>car</code>,<code>cdr</code>，对于既定的list，我们总是可以将其遍历（这在宏中非常有用）。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2014/12/setup-sublime-as-javascript-development-env/">在Sublime Text中设置JavaScript构建</a>
      </li>
    
      <li class="post">
        <a href="/2014/11/modern-ui-development-workflow/">现代Web页面开发流程</a>
      </li>
    
      <li class="post">
        <a href="/2014/11/publish-your-web-design/">发布你的Web设计</a>
      </li>
    
      <li class="post">
        <a href="/2014/11/tdd-step-by-step/">从一个小例子学习TDD</a>
      </li>
    
      <li class="post">
        <a href="/2014/11/splash-color-in-black-and-white-photo/">命令行制作黑白+单色照片</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Qiu Juntao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'icodeit';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
