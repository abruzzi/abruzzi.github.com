
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>I code it</title>
  <meta name="author" content="Qiu Juntao">

  
  <meta name="description" content="DDD为什么很难实施 领域驱动设计（Domain Driven Design）的概念已经被发明了十多年，而且也不乏相关著作，但是业界宣称自己应用了DDD原则的项目，软件却鲜有耳闻。随着微服务架构的流行，DDD在边界识别，服务划分等方面不断被提及，作为一种应对复杂软件的方法论，似乎又被重视起来了。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://abruzzi.github.com/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="I code it" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.gmirror.org/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.gmirror.org/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.gmirror.org/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-28217566-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">I code it</a></h1>
  
    <h2>Code and Life</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:abruzzi.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">文章</a></li>
  <li><a href="/blog/archives">文章归档</a></li>
  <li><a href="/publish">出版物</a></li>
  <li><a href="/about-me">关于</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2017/01/why-ddd-is-so-hard/">实施领域驱动设计的正确姿势</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-01-11T00:48:00+08:00" pubdate data-updated="true">Jan 11<span>th</span>, 2017</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>DDD为什么很难实施</h2>

<p>领域驱动设计（<a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a>）的概念已经被发明了十多年，而且也不乏相关著作，但是业界宣称自己应用了DDD原则的项目，软件却鲜有耳闻。随着微服务架构的流行，DDD在边界识别，服务划分等方面不断被提及，作为一种应对复杂软件的方法论，似乎又被重视起来了。</p>

<p>那么，为什么这个听起来很靠谱的方法论实际上很难实施呢？我们以DDD创始人<code>Eric Evans</code>的经典书籍《领域驱动设计：软件核心复杂性应对之道》为例，分析一下，可能的原因是这样的：</p>

<ul>
<li>新概念数量比较多</li>
<li>战术/战略都有所涉及</li>
<li>不同层次的概念混杂（除了设计模式之外，还有架构风格的讨论）在一起</li>
</ul>


<h3>繁复而混杂的概念</h3>

<p>领域，子域，核心子域，通用子域，实体，值对象，领域服务，应用服务，领域事件，统一语言，衔接上下文，遵循者等等。DDD中有着大量的新概念，而且这些概念有些是技术相关的，有些是问题相关的，交织在一起之后，很难理清头绪。</p>

<p><img src="/images/2017/01/ddd-full-diagram-resized.png" alt="DDD Full" /></p>

<p>DDD中的模式又分为战术的和战略的两大部分，有很多团队应用了战术相关的，比如实体，值对象，领域服务，仓库等模式，代码看似DDD，实则与DDD强调的<code>以领域为中心</code>相去甚远，陷入了开发者太过于关注技术本身的老路上，这种现象还有个专门的名词，叫<a href="http://stackoverflow.com/questions/4196668/domain-driven-design-ddd-pitfalls">DDD-Lite</a>。</p>

<h3>不同的思维方式要求</h3>

<p>DDD要求读者既有具体Coding的技能，有需要跳出圈外，以架构师的角度来审视整个系统。DDD需要开发者以一个全新的视角去认识软件开发，强调对业务流程的熟悉，强调与领域专家一起协作，强调软件的表达能力和进化能力。而这些思维方式的转变，都有很大阻力的（想想从面向对象世界切换到函数式编程，再到响应式函数编程的切换）。</p>

<blockquote><p>It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure. Basic professional ethics would instead require him to write a DestroyCity procedure, to which Baghdad could be given as a parameter.  &#8211; Nathaniel Borenstein</p></blockquote>

<p>我自己在工作的前4年，非常反感业务，认为<code>case by case</code>的业务流程会严重影响我的代码的通用性。然而事实是，纯粹通用的代码是不存在的。毕竟，诸如IoC容器，Web等基础设施已经相当完善，完全无需我们重复发明轮子。而作为应用开发人员，更重要的是在充分理解业务的前提下，写出易于维护，易于扩展，可以更快速响应业务变化的代码。</p>

<p>正因为如此，DDD在一定程度上会让程序员感到不适，它太强调领域了，而领域又是独一无二的，每个公司的每个系统都有其独立性，这就要求你的代码可能没法做到<code>纯粹</code>。</p>

<h2>正确姿势</h2>

<p>要解决上面提到的这些问题，正确的实施DDD来指导实际的开发工作，需要至少做到这样几个事情。首先，明确分清<code>问题</code>和<code>方案</code>（这是初学DDD者最容易犯的错误）；其次，转变思维方式，将软件开发的重心放在梳理并明确业务需求上，而不是代码逻辑上；最后，需要应用一些合理的工程实践来促成DDD-Lite的落地。</p>

<h3>分清问题和解决方案</h3>

<p>我们说领域（子域，通用子域，支撑子域等）的时候，是在讨论问题域，即定义我们要解决的问题是什么。而说到限界上下文，聚合，实体，仓库则是在讨论解决方案部分，人们很容易将两者搞混。</p>

<p>在电商的领域中，一些典型的问题是：</p>

<ul>
<li>如何获得更多的客户</li>
<li>如何让客户更快速的找到自己想要的商品</li>
<li>如何准确的推荐相关产品给客户</li>
<li>用户如何付费</li>
</ul>


<p>要解决这些问题，人们可能会开发出来一个软件系统，也可能会用手工的流程，也可能是混合模式。同样，一些具体的解决方案的例子是：</p>

<ul>
<li>商品促销子系统</li>
<li>全文搜索系统</li>
<li>推荐子系统</li>
<li>支付平台</li>
</ul>


<p>显然，解决方案是在问题定义之后才产生的，而定义问题本身是一件<code>开发人员</code>不擅长的工作，这也是为什么DDD特别强调领域专家的原因。实施DDD需要从领域专家，技术专家的深入合作中，得出一个模型。其实，DDD的核心就是要解决一个问题：建立领域问题的软件模型，这个模型需要满足这样几个条件：</p>

<ul>
<li>能准确表达领域概念，业务流程等（无需经过翻译）</li>
<li>容易演进</li>
<li>每个领域有自己的解决方案</li>
</ul>


<h4>DDD战略模式</h4>

<p><img src="/images/2017/01/problem-and-domain-resized.png" alt="" /></p>

<p>这是Vaughn Vernon的著作<a href="https://vaughnvernon.co/?page_id=168">《Implement Domain Driven Design》</a>中的一张图，整个外边的大圈是业务对应的领域（问题域），这个大的圈被虚线划分成了很多小的子域（依然是问题域，不过每个子域要解决的问题都不相同），子域有很多类型，比如核心子域，支撑子域，通用子域等。对应的，每个域都可能有自己的<code>限界上下文</code>，上下文之间有不同类型的<code>上下文映射</code>模式。</p>

<p>子域的边界由<code>通用语言</code>来划分，也就是说，每个子域有自己区别于其他子域的语言（也就是自己的业务概念，业务规则）。比如财务系统中，提及的概念如毛利，净利率，投入回报比，发票，报销等等，与招聘系统中的候选人，面试，宣讲，校招等等都大不相同。</p>

<p>正确的应用DDD的战略模式来帮助问题的识别和理解，比单纯的应用<code>DDD-Lite</code>要重要得多。</p>

<ul>
<li>通用语言</li>
<li>限界上下文</li>
<li>上下文映射</li>
</ul>


<h3>思维方式转变</h3>

<p>开发者要将思维方式转变成<code>以业务规则优先</code>是一件非常困难的事儿。毕竟经过了多年的训练，特别是抽象思维的训练，开发者很喜欢<code>通用</code>的技巧，比如管道-过滤器，线程池，解析器等等。然而业务规则往往是具体的，而且很多时候，需求变化的方向会破坏掉开发者精心构筑的抽象体系。</p>

<p>然而个思维方式的转变正是成功实施DDD关键所在：愿意和业务人员一起理解沟通，理解业务是实施DDD的第一步。其实每个行业的业务都有很多有意思的地方，我在ThoughtWorks，由于工作性质的原因，可以接触到很多不同的客户，不同的业务。每个项目上，我都很乐于去向业务人员学习，业务在现实世界中是如何运作的：房产中介如何打广告，房东如何付费，房地产广告平台如何从中盈利；无线基站如何建设，工人如何去施工，甚至基站铁塔如何避雷，如何防雨；保单的类型，付费年限，如何分红等等。</p>

<p>每个不同的业务都可以学到很多人们在解决问题时发明出来的新思路，新方法。这些思路和方法未尝不可以反过来应用在软件开发上。</p>

<h3>工程实践</h3>

<ul>
<li>敏捷方法</li>
<li>自动化测试</li>
</ul>


<h4>敏捷方法</h4>

<p>其实早在敏捷宣言产生的时代，人们就已经发现了<code>客户合作胜过合同谈判</code>。与客户保持高度的合作（最好是业务人员就坐在开发人员旁边），实时的反馈收集并根据反馈进行方向调整都是敏捷方法中倡导的。而DDD更进一步，需要和业务人员一起，定义出领域模型的原型，包括一些白板上的图和代码原型，并根据敏捷方法进行持续的演进。</p>

<p>比如这里提出的一些实践可以比较好的帮助你来实施<code>DDD</code>:</p>

<ul>
<li>需求的Kickoff（BA，开发，QA一起来明确需求的含义）</li>
<li>结对编程（不限于开发之间的结对，也可能是不同角色间的结对）</li>
<li>代码审视</li>
<li>代码重构</li>
<li>Mini Showcase</li>
<li><del>回顾会议</del></li>
</ul>


<p>通过敏捷实践，我们可以建立起快速的<code>反馈机制</code>，和对变化的响应能力，冗长的流程和不透明的价值流向会导致很多问题。</p>

<p>如果我们承认自己不是全知全能的，需要不断地通过学习来不断的理解业务，那么重构就编程了一件自然而言地、必须做的事情了。通过重构，我们将之前模糊的业务概念清晰起来，将缺失的概念补齐，将代码中的华为到消除。</p>

<p><code>Mini Showcase</code>强调开发者在完成需求的过程中，不定期的与BA，QA等角色交流、确认。如果有理解不正确的地方，可以尽快发现，然后解决。</p>

<h4>自动化测试</h4>

<p>另一方面，要保证模型的可理解性，除了<code>Clean Code</code>的一些原则之外，自动化测试也是一个必不可少的工程实践。领域模型在<strong>意图表现</strong>上需要做到极致，而单元测试/功能测试则以用例的方式将模型<code>用起来</code>。这要求开发者使用<code>实例化需求</code>，<code>行为驱动开发</code>等方法编写实践作支撑。</p>

<p>测试不是为了覆盖率，也不能仅仅只是为了自动化一些手工的工作。在DDD的上下文中，自动化测试更多的是完整表达业务意图的用例。</p>

<h5>实例化需求</h5>

<p>测试需要以实际用户的角度来编写，并以<code>实例</code>的方式描述。这样即使自动化做不了，这个<code>实例</code>依然是一个很好的文档。当然，为了保证这个文档不过期（和代码实现不匹配），还是强烈建议可以将其自动化起来。</p>

<p>比如这里有个例子，人事经理想要找一些开发人员来分配到项目上，这个找人的过程有两条很简单的规则：</p>

<ul>
<li>开发人员的技能要和项目的要求匹配</li>
<li>开发人员当前不在项目上（比如当前项目为Beach即为空闲状态）</li>
</ul>


<p>用<code>Cucumber</code>写的测试看起来是这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Feature: Find employee by skills
</span><span class='line'>  As a staffing manager
</span><span class='line'>  I want to find employee by skills
</span><span class='line'>  So that I know whether we have the staff or we need to hire new ones
</span><span class='line'>
</span><span class='line'>  Background: persona
</span><span class='line'>    Given we have the following employees:
</span><span class='line'>      | name   | currentProject | role | skills    |
</span><span class='line'>      | Juntao | Consulting     | Dev  | Java,Ruby |
</span><span class='line'>      | Yanyu  | Beach          | Dev  | Ruby      |
</span><span class='line'>      | Jiawei | Beach          | Dev  | Java,Ruby |
</span><span class='line'>      | Momo   | Beach          | Dev  | Python    |
</span><span class='line'>
</span><span class='line'>  Scenario: Search by skills
</span><span class='line'>    Given I have a project which require "Ruby" as language
</span><span class='line'>    When I search staff by skill
</span><span class='line'>    Then I should get the following names:
</span><span class='line'>      | Yanyu  |
</span><span class='line'>      | Jiawei |</span></code></pre></td></tr></table></div></figure>


<h4>迭代开发</h4>

<p>软件开发本身就具有很高的复杂度，正如我在<a href="http://icodeit.org/2017/01/why-software-is-complex/">上一篇博客</a>里提到的，在项目启动之初，无论是业务专家还是开发者，对软件系统的知识都是非常有限的。迭代式的开发方式更加契合这种复杂度很高的活动。业务人员和开发一起，在建模、实现的过程中会对领域进行深入的学习，并产生新的知识。反过来这些新的知识又会影响模型的进一步进化。</p>

<p><img src="/images/2015/08/waterfall-v-agile-about.gif" alt="" /></p>

<p>迭代开发的方式可以帮助我们将这个复杂度很高的过程变得平缓一些，而且从一个个小的迭代中学习，并根据反馈来指导新的方向，可以快速的帮助团队建立信心，同时对业务的理解更为深入，使得整个开发过程越来越平顺。</p>

<h2>小结</h2>

<p>简而言之，要顺利实施DDD，需要至少做到：</p>

<ul>
<li>明确概念，分清<code>问题域</code>和<code>解决方案域</code>，应用DDD的战略模式</li>
<li>转变思维方式，为<code>业务梳理和理解</code>赋予最高的优先级</li>
<li>通过<code>工程实践</code>来确保落地</li>
</ul>


<p>当然，如何来实施战略模式（通用语言，限界上下文，上下文映射）也需要一些工程实践的帮助，我会在另外一篇文章中详细讨论。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2017/01/why-software-is-complex/">软件开发为什么很难</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-01-06T18:06:00+08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2017</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>问题的分类</h2>

<p>最初在1999年被Dave Snowden开发出来的<strong><a href="https://en.wikipedia.org/wiki/Cynefin_framework">Cynefin</a>框架</strong>尝试把世界上的问题划分到了5个域中（大类）：</p>

<p><img src="/images/2017/01/cynefin-resized.png" alt="" /></p>

<ul>
<li>简单（Simple）问题，该域中的因果关系非常明显，解决这些问题的方法是 <code>感知-分类-响应</code>（Sense-Categorise-Respond），有对应的<strong>最佳</strong>实践</li>
<li>复合（Complicated）问题，该域中的因果关系需要分析，或者需要一些其他形式的调查和/或专业知识的应用，解决这些问题的方法是<code>感知-分析-响应</code>（Sense-Analyze-Respond），有对应的<strong>好的</strong>实践</li>
<li>复杂（Complex）问题，该域中的因果关系仅能够从回顾中发现，解决这些问题的方法是<code>探索-感知-响应</code>（Probe-Sense-Respond），我们能够感知<strong>涌现</strong>实践（emergent practice）</li>
<li>混乱（Chaotic）问题，该域中没有系统级别的因果关系，方法是<code>行动-感知-响应</code>（Act-Sense-Respond），我们能够发现<strong>新颖</strong>实践（novel practice）</li>
<li>失序（Disorder）问题，该域中没有因果关系，不可感知，其中的问题也无法被解决</li>
</ul>


<p>显然，软件开发过程更多地是一个复杂（Complex）问题。在一个产品被开发出来之前，不确定性非常高，团队（包括业务人员和技术人员）对产品的知识也是最少的，而且需要大量的学习和尝试才可以明确下一步可能的方向。不幸的是，很多时候我们需要在一开始（不确定性最高的时候）就为项目做计划。这种从传统行业中非常适合的方法在软件开发领域不再适用，这也是敏捷开发、精益等方法论在软件开发中更加适合的原因。</p>

<p><img src="/images/2017/01/learning-curve-resized.png" alt="" /></p>

<p><em>来源：http://alistair.cockburn.us/Disciplined+Learning</em></p>

<p>正因为软件开发事实上是一个学习的过程，我们学习到的新知识反过来会帮助我们对问题的定义，从而带来变化。这里的变化可能来自两个方向：</p>

<ul>
<li>功能性</li>
<li>非功能性</li>
</ul>


<p>功能性的变化指随着对业务的深入理解、或者已有业务规则为了匹配市场而产生的变化。比如支付方式由传统的货到付款变成了网银付款，又变成了微信支付、支付宝扫码等等。一个原始的电商平台仅仅提供基本的购物服务，但是后来可以根据已有数据产生推荐商品，从来带来更大的流量。这些变化需要体现在已有的代码中，而对代码的修改往往是牵一发而动全身。</p>

<p>非功能性的变化是指随着业务的发展，用户规模的增加，数据量的变化，安全认知的变化等产生的新的需求。比如100个用户的时候无需考虑性能问题，但是100万用户的时候，性能就变成了必须重视的问题。天气预报应用的数据安全性和网络银行的数据安全性要求也大不相同。</p>

<p><em>而在业务提出一个需求的时候，往往只是一个简化过的版本。</em></p>

<h3>非功能性复杂性</h3>

<p><img src="/images/2017/01/ui-resized.png" alt="" /></p>

<p><em>来源：https://d13yacurqjgara.cloudfront.net/users/749341/screenshots/2228676/uielements_day021_dribbbleinvites.jpg</em></p>

<p>这是一个经过设计师精确设计的界面，在它被设计出来之前，用户事实上无法准确的描述出它。设计过程中经历了很多的诸如：</p>

<ul>
<li>线框图</li>
<li>颜色的确定</li>
<li>交互的动画</li>
<li>信息层次</li>
</ul>


<p>往复多次之后，界面确定了。在没有仔细思考使用场景的时候，开发会误以为这个功能非常简单。但是如果你是一个有经验的开发者，很快会想到的一些问题是：</p>

<ul>
<li>在宽屏下如何展示</li>
<li>在平板上如何展示</li>
<li>在手机上如何展示</li>
<li>即使仅仅支持桌面版，跨浏览器要考虑吗？支持哪些版本？</li>
<li>有些UI效果在低版本的浏览器上不工作，需要Shim技术</li>
</ul>


<p>除此之外，依然有大量的其他细节需要考虑：</p>

<ul>
<li>性能要求是什么样的？</li>
<li>安全性要考虑吗？</li>
<li>在网络环境不好的时候，要不要fallback到基础视图？</li>
<li>既然涉及发送邀请函，送达率如何保证</li>
<li>与外部邮件服务提供商集成时的工作量</li>
</ul>


<p>等等。这些隐含的信息需要被充分挖掘出来，然后开发者才能做一个合理的评估，而且这还只是开始。一旦进入开发阶段，很多之前没有考虑到的细节开始涌现：字体的选用，字号，字体颜色，元素间的间距等等，如何测试邮件是否发送成功，多个角色之间的conversation又会消耗很多时间。</p>

<h3>需求的变化方向</h3>

<p>作为程序员，有一天你被要求写一段代码，这段代码需要完成一件很简单的事：</p>

<ol>
<li>打印&#8221;Hello, world&#8221;5次</li>
</ol>


<p>很容易嘛，你想，然后顺手就写下了下面这几行代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，拷贝粘贴看起来有点低端，你做了一个微小的改动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来还不错，老板的需求又变成了打印&#8221;Goodbye, world&#8221;5次。既然是打印<code>不同</code>的消息，那何不把消息作为参数呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">printMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">print</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">printMessage</span><span class="p">(</span><span class="s2">&quot;Hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">printMessage</span><span class="p">(</span><span class="s2">&quot;Goodbye, world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了这个函数，你可以打印<code>任意消息</code>5次了。老板又一次改变了需求：打印&#8221;Hello, world&#8221;13次（没人知道为什么是13）。既然次数也变化了，那么一个可能是将<code>次数</code>作为参数传入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">printMessage</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">print</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">printMessage</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="s2">&quot;Hello, world&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nx">printMessage</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Goodbye, world&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>完美，这就是抽象的魅力。有了这个函数，你可以将任意消息打印任意次数。不过老板是永远无法满足的，就在这次需求变化之后的第二天，他的需求又变了：不但要将&#8221;Hello, world&#8221;打印到控制台，还要将其计入日志。</p>

<p>没办法，通过搜索<code>JavaScript</code>的文档，你发现了一个叫做高阶函数的东东：<strong>函数可以作为参数传入另一个参数！</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">system</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">doMessage</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">action</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doMessage</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Hello, world&quot;</span><span class="p">,</span> <span class="nx">print</span><span class="p">);</span>
</span><span class='line'><span class="nx">doMessage</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Hello, world&quot;</span><span class="p">,</span> <span class="nx">log</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这下厉害了，我们可以对任意消息，做任意次的任意动作！再回过头来看看那个最开始的需求：</p>

<ol>
<li>打印&#8221;Hello, world&#8221;5次</li>
</ol>


<p>稍微分割一下这句话：<strong>打印，&#8221;Hello, world&#8221;，5次</strong>，可以看到，这三个元素最后都变成了可以变化的点，软件开发很多时候正是如此，需求可能在任意<em>可能变化</em>的方向上变化。这也是各种软件开发原则尝试解决的问题：如何写出更容易扩展，更容易响应变化的代码来。</p>

<h3>小节</h3>

<p>软件的复杂性来自于大量的<strong>不确定性</strong>，而这个不确定性事实上是无法避免的，而且每个软件都是独一无二的。另一方面，软件的需求会以各种方式来变化，而且往往会以开发者没有预料到的方向。比如上面这个小例子中看到的，最后的需求可能会变成将消息以短信的方式发送给手机号以<code>185</code>开头的用户手机上。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/12/my-2016/">我的2016</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-12-28T14:21:00+08:00" pubdate data-updated="true">Dec 28<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>大事记</h2>

<p>把女儿心心哄睡着之后，我躺在她旁边，听着她平稳的呼吸声，心里充满了幸福和感激。女儿降生的那种感动，是无以伦比的，之前的很多事情变得无所谓起来，这当然是我今年最大的收获。</p>

<p><img src="/images/2016/12/xx-2-resized.png" alt="心心" /></p>

<p>当然，初为人父，有<code>好多好多</code>东西需要学习，她还在月子里的时候，我整理过一次思维导图：</p>

<p><img src="/images/2016/12/new-born-resized.png" alt="新生儿" /></p>

<p>今年也有一些其他的里程碑：</p>

<ul>
<li>骑行了第一个100公里</li>
<li>学会了驾驶（已经行驶了近6000公里）</li>
<li>学会了抱娃，换尿布，给娃洗澡，试水温等等</li>
<li><a href="https://book.douban.com/subject/26585461/">《轻量级Web应用开发》</a>被翻译成繁体中文版在台湾发售</li>
<li>Hiking到了秦岭最高点（大爷海，海拔3500m）</li>
</ul>


<p><img src="/images/2016/12/mybook-resized.png" alt="" /></p>

<h3>学习</h3>

<p>今年的大部分时间都不在办公室，在客户现场出差有8-9个月。最大的感受是归属感的缺乏，另外就是大部分时候再输出，会导致积累的存货快要被掏空的感觉。很多知识需要花时间来补充上，咨询工作本身有很大一部分是需要咨询师在非咨询项目上做积累，然后再去输出的。</p>

<p>这一点希望在2017年可以做的更好一些：减少一些出差，多在办公室的项目上工作，然后能有更多的时间来积累自己的知识库。</p>

<p>上半年花了一些时间和设计师唐婉莹合写的<a href="https://www.gitbook.com/book/juntao/pre-iteration-zero/details">《在迭代1之前》</a>，后来出差网络比较封闭的时候，就只有唐婉莹在做更新（频率和质量都很高），我自己的开发部分很久没有改动了，算是一个比较遗憾的地方。2017年希望可以完成其中的烂尾部分。</p>

<p>总体来说，2016年很多时间是做咨询工作，内容比较杂乱。我梳理了一下，大致如下：</p>

<p><img src="/images/2016/12/learning-resized.png" alt="" /></p>

<h4>一些微小的练习</h4>

<p>我的第一个React Natvie应用，感谢傅若愚：</p>

<p><img src="/images/2016/12/react-native-resized.png" alt="" /></p>

<p>闪电计划的页面局部，感谢张小虫：</p>

<p><img src="/images/2016/12/bookish-detail-resized.png" alt="" /></p>

<p><del>
Graphviz一个例子：</p>

<p><img src="/images/2016/12/graphgiz-demo-resized.png" alt="" />
</del></p>

<h4>闪电计划</h4>

<p>7月，和另外两个同事组织了一个系列的活动，这个活动旨在通过一系列的刻意练习，包括但不限于：</p>

<ul>
<li>TDD，Tasking，构建，环境自动化</li>
<li>自动化测试（集成测试，UI测试）</li>
<li>项目中的常见场景（多表关联，异常处理，RESTful API设计）</li>
<li>常见静态页面</li>
<li>一些具体而微的端到端Web项目</li>
</ul>


<p><img src="/images/2016/12/lighting-resized.png" alt="" /></p>

<p>闪电计划的另一个副作用是找出了一些前端的Kata，可以供后续的前端们做练习用。我已经找张小虫，李彤欣做过了第一次的实验，证明是一个比较合理的方向。在2017年，可以作为新的Workshop进行。</p>

<h3>项目经历</h3>

<p>元月份经历了一个史上最奇特的咨询项目：Staffing好的3个人中，有两个离职了……。不过还好，通过两个月的微小工作，客户最终还是比较满意的，也很顺利的有了项目的第二期（虽然由于其他原因，第二期只做了一半）。</p>

<p>其他的经历比较平淡：</p>

<ul>
<li>在回南天的3月去了一趟广州出差，做了一些前端性能相关的测试。</li>
<li>在最热的7月份去了一趟上海出差，莫名其妙的做了一些前端性能相关的测试，以及<code>React Native</code>的一些预研。</li>
<li>最后在寒冷的12月去了一趟深圳出差，做了一些安全测试（基于<code>OWASP</code>）、依赖关系图（基于<code>Doxygen</code>）等的Spike。</li>
</ul>


<p>不过总体来看，2016年经历的项目是最多的，而且多样性也很高：</p>

<ul>
<li>3个咨询项目</li>
<li>3个交付项目</li>
<li>3个售前</li>
</ul>


<h3>其他</h3>

<p>应王欢要求，除了一起吃过几次饭之外，今年跟王欢基本上没有交集。倒是多亏了他的脸，在楼下的来福士和他喝了不少次咖啡。</p>

<p><img src="/images/2016/12/huanghe-resized.png" alt="" /></p>

<p>这是九月份去付莹家的黄河时和同事们的合影，第一次开车走高速去那么远的地方，后座还有一个澳洲的客户。</p>

<p><img src="/images/2016/12/cycling-resized.png" alt="" /></p>

<p>骑行了一半儿，有一群开着车的同事追了上来，跟我们一起吃了个饭，我们骑车回去，他们则开车/坐车回去了。</p>

<p><img src="/images/2016/12/reunion-resized.png" alt="" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/10/testing-in-microservice-context/">微服务场景下的自动化测试</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-10-01T18:49:00+08:00" pubdate data-updated="true">Oct 1<span>st</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>新的挑战</h2>

<p>微服务和传统的单块应用相比，在测试策略上，会有一些不太一样的地方。简单来说，在微服务架构中，测试的层次变得更多，而且对环境的搭建要求更高。比如对单块应用，在一个机器上就可以setup出所有的依赖，但是在微服务场景下，由于依赖的服务往往很多，要搭建一个完整的环境非常困难，这对团队的<code>DevOps</code>的能力也有比较高的要求。</p>

<p>相对于单块来说，微服务架构具有以下特点：</p>

<ul>
<li>每个微服务在物理上分属不同进程</li>
<li>服务间往往通过<code>RESTful</code>来集成</li>
<li>多语言，多数据库，多运行时</li>
<li>网络的不可靠特性</li>
<li>不同的团队和交付周期</li>
</ul>


<p>上述的这些微服务环境的特点，决定了在微服务场景中进行测试自然会面临的一些挑战：</p>

<ul>
<li>服务间依赖关系复杂</li>
<li>需要为每个不同语言，不同数据库的服务搭建各自的环境</li>
<li>端到端测试时，环境准备复杂</li>
<li>网络的不可靠会导致测试套件的不稳定</li>
<li>团队之间的<code>沟通成本</code></li>
</ul>


<h3>测试的分层</h3>

<p>相比于常见的<a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">三层测试金字塔</a>，在微服务场景下，这个层次可以被扩展为5层（如果将UI测试单独抽取出来，可以分为六层）。</p>

<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>组件测试</li>
<li>契约测试</li>
<li>端到端测试</li>
</ul>


<p><img src="/images/2016/10/microservice-testing-zhcn-resized.png" alt="Test layers" /></p>

<p>和测试金字塔的基本原则相同：</p>

<ol>
<li>越往上，越接近业务/最终用户；越往下，越接近开发</li>
<li>越往上，测试用例越少</li>
<li>越往上，测试成本越高（越耗时，失败时的信息越模糊，越难跟踪）</li>
</ol>


<h4>单元测试</h4>

<p>单元测试，即每个微服务内部，对于领域对象，领域逻辑的测试。它的隔离性比较高，无需其他依赖，执行速度较快。</p>

<p>对于业务规则：</p>

<ol>
<li>商用软件需要License才可以使用，License有时间限制</li>
<li>需要License的软件在到期之前，系统需要发出告警</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">license_should_expire_after_the_evaluation_period</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">LocalDate</span> <span class="n">fixed</span> <span class="o">=</span> <span class="n">getDateFrom</span><span class="o">(</span><span class="s">&quot;2015-09-03&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">License</span> <span class="n">license</span> <span class="o">=</span> <span class="k">new</span> <span class="n">License</span><span class="o">(</span><span class="n">fixed</span><span class="o">.</span><span class="na">toDate</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">isExpiredOn</span> <span class="o">=</span> <span class="n">license</span><span class="o">.</span><span class="na">isExpiredOn</span><span class="o">(</span><span class="n">fixed</span><span class="o">.</span><span class="na">plusYears</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">plusDays</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">toDate</span><span class="o">());</span>
</span><span class='line'>    <span class="n">assertTrue</span><span class="o">(</span><span class="n">isExpiredOn</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">license_should_not_expire_before_the_evaluation_period</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">LocalDate</span> <span class="n">fixed</span> <span class="o">=</span> <span class="n">getDateFrom</span><span class="o">(</span><span class="s">&quot;2015-09-05&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">License</span> <span class="n">license</span> <span class="o">=</span> <span class="k">new</span> <span class="n">License</span><span class="o">(</span><span class="n">fixed</span><span class="o">.</span><span class="na">toDate</span><span class="o">(),</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">isExpiredOn</span> <span class="o">=</span> <span class="n">license</span><span class="o">.</span><span class="na">isExpiredOn</span><span class="o">(</span><span class="n">fixed</span><span class="o">.</span><span class="na">plusYears</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">minusDays</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">toDate</span><span class="o">());</span>
</span><span class='line'>    <span class="n">assertFalse</span><span class="o">(</span><span class="n">isExpiredOn</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个例子就是一个非常典型的单元测试，它和其他组件基本上没有依赖。即使要测试的对象对其他类有依赖，我们会Stub/Mock的手段来将这些依赖消除，比如使用<a href="http://mockito.org/">mockito</a>/<a href="https://github.com/jayway/powermock">PowerMock</a>。</p>

<h4>集成测试</h4>

<p>系统内模块（一个模块对其周边的依赖项）间的集成，系统间的集成都可以归类为集成测试。比如</p>

<ul>
<li>数据库访问模块与数据库的集成</li>
<li>对外部<code>service</code>依赖的测试，比如对第三方支付，通知等服务的集成</li>
</ul>


<p>集成测试强调模块和外部的交互的验证，在集成测试时，通常会涉及到外部的组件，比如数据库，第三方服务。这时候需要尽可能真实的去与外部组件进行交互，比如使用和真实环境相同类型的数据库，采用独立模式（Standalone）的<a href="http://wiremock.org/">WireMock</a>来启动外部依赖的RESTful系统。</p>

<p>通常会用来做模拟外部依赖工具包括：</p>

<ul>
<li><a href="http://wiremock.org/">WireMock</a></li>
<li><a href="http://www.mbtest.org/">mountebank</a></li>
</ul>


<p>其中，mountbank还支持Socket级别的Mock，可以在非HTTP协议的场景中使用。</p>

<p><img src="/images/2016/10/1905-funcional-teamwork.jpg" alt="Integration Test" /></p>

<h4>组件测试</h4>

<p>贯穿应用层和领域层的测试。不过通常来说，这部分的测试不会访问真实的外部数据源，而是使用同<code>schema</code>的内存数据库，而且对外部service的访问也会使用Stub的方式：</p>

<ul>
<li>内存数据库</li>
<li>Stub外部服务（<a href="http://wiremock.org/">WireMock</a>）</li>
<li><a href="https://github.com/rest-assured/rest-assured">RestAssured</a></li>
</ul>


<p>比如使用<a href="http://www.h2database.com/html/main.html">h2</a>来做内存数据库，并且自动生成schema。使用WireMock来Stub外部的服务等。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_create_user</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">given</span><span class="o">().</span><span class="na">contentType</span><span class="o">(</span><span class="n">ContentType</span><span class="o">.</span><span class="na">JSON</span><span class="o">).</span><span class="na">body</span><span class="o">(</span><span class="n">prepareUser</span><span class="o">()).</span>
</span><span class='line'>            <span class="n">when</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="s">&quot;/users&quot;</span><span class="o">).</span>
</span><span class='line'>            <span class="n">then</span><span class="o">().</span><span class="na">statusCode</span><span class="o">(</span><span class="mi">201</span><span class="o">).</span>
</span><span class='line'>            <span class="n">body</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="n">notNullValue</span><span class="o">()).</span>
</span><span class='line'>            <span class="n">body</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Juntao Qiu&quot;</span><span class="o">)).</span>
</span><span class='line'>            <span class="n">body</span><span class="o">(</span><span class="s">&quot;email&quot;</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;juntao.qiu@gmail.com&quot;</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">User</span> <span class="nf">prepareUser</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">();</span>
</span><span class='line'>    <span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Juntao Qiu&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">user</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">&quot;juntao.qiu@gmail.com&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">user</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用Spring，还可以通过<code>profile</code>来切换不同的数据库。比如下面这个例子中，默认的profile会连接数据库<code>jigsaw</code>，而<code>integration</code>的profile会连接<code>jigsaw_test</code>数据库：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nl">spring:</span>
</span><span class='line'>  <span class="nl">datasource:</span>
</span><span class='line'>    <span class="nl">url:</span> <span class="nl">jdbc:mysql:</span><span class="c1">//localhost:3306/jigsaw</span>
</span><span class='line'>    <span class="n">driver</span><span class="o">-</span><span class="n">class</span><span class="o">-</span><span class="nl">title:</span> <span class="n">com</span><span class="o">.</span><span class="na">mysql</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">Driver</span>
</span><span class='line'>    <span class="nl">username:</span> <span class="n">root</span>
</span><span class='line'>    <span class="nl">password:</span> <span class="n">password</span>
</span><span class='line'>
</span><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="nl">spring:</span>
</span><span class='line'>  <span class="nl">profiles:</span> <span class="n">integration</span>
</span><span class='line'>
</span><span class='line'>  <span class="nl">datasource:</span>
</span><span class='line'>    <span class="nl">url:</span> <span class="nl">jdbc:mysql:</span><span class="c1">//localhost:3306/jigsaw_test</span>
</span><span class='line'>    <span class="n">driver</span><span class="o">-</span><span class="n">class</span><span class="o">-</span><span class="nl">title:</span> <span class="n">com</span><span class="o">.</span><span class="na">mysql</span><span class="o">.</span><span class="na">jdbc</span><span class="o">.</span><span class="na">Driver</span>
</span><span class='line'>    <span class="nl">username:</span> <span class="n">root</span>
</span><span class='line'>    <span class="nl">password:</span> <span class="n">password</span>
</span></code></pre></td></tr></table></div></figure>


<p>组件测试会涉及到的组件包括：</p>

<ul>
<li>URL路由</li>
<li>序列化与反序列化</li>
<li>应用对领域层的访问</li>
<li>领域层对数据的访问</li>
<li>数据库访问层</li>
</ul>


<h5>前后端分离</h5>

<p>除了后端的测试之外，在目前的前后端分离场景下，前端的应用越来越复杂，在这种情况下，前端的组件测试也是一个测试的重点。</p>

<p>一个前端应用至少包括了这样一些组件：</p>

<ul>
<li>前端路由</li>
<li>模板</li>
<li>前端的MVVM</li>
<li>拦截器</li>
<li>事件的响应</li>
</ul>


<p>要确保这些组件组合起来还能如预期的执行，相关测试必不可少。<a href="http://icodeit.org/2015/06/whats-next-after-separate-frontend-and-backend/">这篇文章</a>详细讨论了前后端分离之后的测试及开发实践。</p>

<h4>契约测试</h4>

<p>在微服务场景中，服务之间会有很多依赖关系。根据<code>消费者驱动契约</code>，我们可以将服务分为消费者端和生产者端，通常消费者自己会定义需要的数据格式以及交互细节，并生成一个契约文件。然后生产者根据自己的契约来实现自己的逻辑，并在持续集成环境中持续验证。</p>

<p><a href="https://github.com/realestate-com-au/pact">Pact</a>已经基本上是<code>消费者驱动契约</code>（Consumer Driven Contract）的事实标准了。它已经有多种语言的实现，Java平台的可以使用<code>pact-jvm</code>及相应的<code>maven</code>/<code>gradle</code>插件进行开发。</p>

<ul>
<li><a href="https://github.com/realestate-com-au/pact">pact</a>/<a href="https://github.com/DiUS/pact-jvm">pact-jvm</a></li>
<li><a href="https://github.com/bethesque/pact_broker">pact-broker</a></li>
</ul>


<p><img src="/images/2016/10/pactExample-resized.png" alt="pact example" /></p>

<p>(图片来源：<a href="http://techblog.newsweaver.com/why-should-you-use-consumer-driven-contracts-for-microservices-integration-tests/">Why you should use Consumer-Driven Contracts for Microservice integration tests</a>)</p>

<p>通常在工程实践上，当消费者根据需要生成了契约之后，我们会将契约上传至一个公共可访问的地址，然后生产者在执行时会访问这个地址，并获得最新版本的契约，然后对着这些契约来执行相应的验证过程。</p>

<p>一个典型的契约的片段是这样的（使用pact）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="s2">&quot;interactions&quot;</span><span class="err">:</span> <span class="p">[</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Project Service&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="nt">&quot;request&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>            <span class="nt">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;GET&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="nt">&quot;path&quot;</span><span class="p">:</span> <span class="s2">&quot;/projects/11046&quot;</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="nt">&quot;response&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>            <span class="nt">&quot;status&quot;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
</span><span class='line'>            <span class="nt">&quot;headers&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                <span class="nt">&quot;Content-Type&quot;</span><span class="p">:</span> <span class="s2">&quot;application/json; charset=UTF-8&quot;</span>
</span><span class='line'>            <span class="p">},</span>
</span><span class='line'>            <span class="nt">&quot;body&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                <span class="nt">&quot;project-id&quot;</span><span class="p">:</span> <span class="s2">&quot;004c97&quot;</span>
</span><span class='line'>            <span class="p">},</span>
</span><span class='line'>            <span class="nt">&quot;matchingRules&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                <span class="nt">&quot;$.body.project-id&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>                    <span class="nt">&quot;match&quot;</span><span class="p">:</span> <span class="s2">&quot;type&quot;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="nt">&quot;providerState&quot;</span><span class="p">:</span> <span class="s2">&quot;project service&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>端到端测试</h4>

<p>端到端测试是整个微服务测试中最困难的，一个完整的环境的创建于维护可能需要花费很大的经历，特别是当有多个不同的团队在独立开发的场景下。</p>

<p>另一方面，从传统的测试金字塔来看，端到端测试应该覆盖那些业务价值最高的Happy Path。也就是说，端到端测试并不关注异常场景，甚至大部分的业务场景都不考虑。要做到这一点，需要在设计测试时，从最终用户的角度来考虑，通过<code>用户画像</code>和<code>User Journey</code>来确定测试场景。</p>

<p>在端到端测试中，最重要的反而不是测试本身，而是环境的自动化能力。比如可以通过一键就可以将整个环境<code>provision</code>出来：</p>

<ul>
<li>安装和配置相关依赖</li>
<li>自动将测试数据Feed到数据库</li>
<li>自动部署</li>
<li>服务的自动重启</li>
</ul>


<p>随着容器技术和容器的编排技术的成熟，这部分工作已经可以比较好的自动化，依赖的工具包括：</p>

<ul>
<li><a href="https://www.docker.com/">Docker</a></li>
<li><a href="http://rancher.com/">Rancher</a></li>
</ul>


<p>一个典型的流程是：</p>

<ol>
<li>搭建持续发布流水线</li>
<li>应用代码的每一次提交都可以构建出docker镜像</li>
<li>将docker镜像发布在内部的docker-hub上</li>
<li>触发部署任务，通过rancher的upgrade命令将新的镜像发布</li>
<li>执行端到端测试套件</li>
</ol>


<p>端到端测试还可以细分为两个不同的场景：</p>

<ul>
<li>没有用户交互的场景，如一系列的微服务组成了一个业务API</li>
<li>有用户交互的场景</li>
</ul>


<h5>UI测试</h5>

<p>最顶层的UI测试跟传统方式的UI测试并无二致。我们可以使用BDD与实例化需求（<a href="https://books.gojko.net/specification-by-example/">Specification By Example</a>）的概念，从用户使用的角度来描述需求，以及相关的验收条件。这里我们会使用WebDriver来驱动浏览器，并通过诸如<a href="https://github.com/jnicklas/capybara">Capybara</a>等工具来模拟用户的操作。</p>

<ul>
<li>BDD工具：<a href="https://cucumber.io/">Cucumber</a></li>
<li>Web应用验收测试工具：<a href="https://github.com/jnicklas/capybara">Capybara</a></li>
<li>Page Object的DSL工具：<a href="https://github.com/natritmeyer/site_prism">Site_prism</a></li>
</ul>


<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.infoq.com/cn/articles/QA-in-Production-practice">产品环境下的QA</a></li>
<li><a href="http://insights.thoughtworkers.org/bdd/">醒醒吧少年，只用Cucumber不能帮助你BDD</a></li>
<li><a href="http://martinfowler.com/articles/microservice-testing/">Testing Strategies in a Microservice Architecture</a></li>
<li><a href="http://icodeit.org/2015/01/page-object-with-site-prism/">编写体面的UI测试</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/09/what-should-qa-do-in-a-agile-team/">测试自动化后，我们还需要QA吗？</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-09-24T23:43:00+08:00" pubdate data-updated="true">Sep 24<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>QA的职责</h2>

<p>我们先讨论一下传统的瀑布模型下QA是如何工作的，其中最主要的问题是什么；然后作为对比，我们来看看在敏捷团队里QA又是如何工作的，工作重点又是什么；最后，我们详细看一看在新的职责下，QA应该如何做。</p>

<h3>瀑布开发模型</h3>

<p>即使在今天，在很多企业中，瀑布模型仍然是主流。每一个需求都需要经过分析，设计，开发，测试，上线部署，运维等阶段。虽然一些企业已经在实施<code>敏捷开发</code>，比如项目/产品以迭代的方式运作，也有诸如每日站会，代码检视等敏捷实践，但是如果仔细审视，你会发现其实<em>开发模式</em>骨子里还是瀑布：按照软件组件划分的部门结构（详见<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律</a>），按照职能划分的团队（开发和测试分属不同部门），过长的反馈周期，永远无法摆脱的集成难题等等。</p>

<p>随着软件变得越来越复杂，团队里没有任何一个人可以说出系统是如何运作的，也不知道最终用户是谁，以及最终用户会以何种方式来使用最终的软件。</p>

<p>更糟糕的是，按照职能划分的团队在物理上都是隔离的，比如独立的测试部门，独立的运维部门，整日忙碌而难以预约到档期的业务人员，当然还有经常疲于交付，无处吐槽的<em>苦逼</em>开发。由于这些隔离，信息的反馈周期会非常长，一个本来很容易修复的缺陷可能在4周之后才可能被另一个部门的测试发现，然后通过复杂的工作流（比如某种形式的缺陷追踪系统）流到开发那里，而开发可能还在拼命的完成早就应该交付的功能，从而形成恶性循环。</p>

<h3>瀑布模式中的QA</h3>

<p>在这样的环境中，QA们能做的事情非常有限。在需求开始时会他们参加需求澄清的会议，制定一些<code>测试计划</code>，然后进行测试用例的设计。有的企业会用诸如Excel之类的工具来记录这些用例。这些写在Excel里的，<code>死</code>的用例用处非常有限。而最大的问题在于：它们无法<code>自动化执行</code>。另外，在实际软件开发中，需求总是会经常发生变化，需求的优先级也会有调整，然后这些记录在Excel中的<code>死</code>的用例会很快过期，变得无人问津。</p>

<p>除此之外，QA中的有些成员会使用工具来录制一些UI测试的场景，然后在每个新版本出来之后进行回放即可。然而，当UI发生一点变化之后，这些自动化的用例就会失效：比如<code>HTML</code>片段中元素位置的调整，<code>JavaScript</code>的异步调用超时等等。</p>

<p>显然，这种单纯以黑盒的形式来<strong>检查功能点</strong>的测试方式是不工作的，要真正有效的提升软件质量，仅仅通过<strong>事后检查</strong>是远远不够的，软件的质量也应该内建于软件之中。QA的工作也应该是一个贯穿软件生命周期的活动，从商业想法，到真实上线，这其中的所有环节，都应该有QA的参与。</p>

<h3>系统思考</h3>

<p>如果不从一个系统的角度来思考软件质量，就无法真正构建出健壮的、让业务和团队都有信心的软件系统。<strong><em>质量从来都不只是QA的职责，而是整个团队的职责。</em></strong></p>

<p>关于软件质量，一个根深蒂固的误解是：缺陷在开发过程中被引入，然后在测试阶段被发现，最后在QA和开发的来来回回的撕扯中被解决（或者数量被大规模降低），最后在生产环境中，就只会有很少的，优先级很低的缺陷。</p>

<p>然而事实上，很多需求就没有仔细分析，业务价值不很确定，验收条件模糊，流入开发后又会引入一些代码级别的错误，以及业务规则上的缺陷，测试阶段会漏掉一些功能点，上线之后更是问题百出（网络故障，缓存失效，黑客攻击，操作系统补丁，甚至内存溢出，log文件将磁盘写满等等）。</p>

<p>在一个敏捷团队中，<strong>每个个人都应该对质量负责</strong>，而QA则以自己的丰富经验和独特视角来发掘系统中可能的质量隐患，并帮助团队将这些隐患消除。</p>

<p><img src="/images/2016/09/circle-resized.png" alt="测试职责" /></p>

<p>我在ThoughtWorks的同事<code>Anand Bagmar</code>在他的演讲<a href="http://www.slideshare.net/abagmar/what-is-agile-testing-how-does-automation-help">What is Agile testing- How does automation help?</a>中详细讨论过这部分内容。</p>

<h3>QA到底应该干什么？</h3>

<p>本质上来说，任何软件项目的目标都应该是：<strong>更快地将<code>高质量</code>的软件从想法变成产品</strong>。</p>

<p>将这个大目标细分一下，会得到这样几个子项，即企业需要：</p>

<ul>
<li>更多的商业回报（发掘业务价值）</li>
<li>更快的上线时间（做最简单，直接的版本）</li>
<li>更好的软件质量（质量内嵌）</li>
<li>更少的资源投入（减少浪费）</li>
</ul>


<p>其实就是传说中的<strong>多、快、好、省</strong>。如果说这是每一个软件项目的目标的话，那么团队里的每一个个人都应该向着这个目标而努力，任何其他形式的工作都可以归类为<code>浪费</code>。用Excel记录那些经常会失效，而且无法自动执行的测试用例是浪费，会因为页面布局变化而大面积失效的UI测试也是浪费，一个容易修复的缺陷要等到数周之后才被发现也是浪费。</p>

<p>在这个大前提下，我们再来思考QA在团队里应该做什么以及怎么做。</p>

<h3>QA的职责</h3>

<p>Lisa Crispin在<a href="https://book.douban.com/subject/5338399/">《敏捷软件测试》</a>中提到过一个很著名的模型：敏捷测试四象限。这个模型是QA制定测试策略时的一个重要参考：</p>

<p><img src="/images/2016/09/agile-testing-quadrants.png" alt="敏捷软件测试" /></p>

<p>如果按照纵向划分的话，图中的活动，越向上越面向业务；越向下越面向技术。横向划分的话，往左是支撑团队；往右是评价产品。</p>

<p>其实简化一下，QA在团队里的工作，可以分为两大类：</p>

<ul>
<li>确保我们在<code>正确的</code>交付产品</li>
<li>确保我们交付了<code>正确的</code>产品</li>
</ul>


<p>根据这个四象限的划分，大部分团队可能都会从Q2起步：QA会和BA，甚至UX一起，从需求分析入手，进行需求分析，业务场景梳理，这时候没有具体的可以被测试的软件代码。不过这并不妨碍<strong>测试</strong>活动，比如一些纸上原型的设计（感谢刘海生供图）：</p>

<p><img src="/images/2016/09/prototype-resized.png" alt="" /></p>

<p>通过这一阶段之后，我们已经有了用户故事，这时候QA需要和开发一起编写用户故事的自动化验收测试。当开发交付一部分功能之后，QA就可以做常规的用户故事测试，几个迭代之后，QA开始进行跨功能需求测试和探索性测试等。根据探索性测试的结果，QA可能会调整测试策略，调整测试优先级，完善测试用例等等。</p>

<p>根据项目的不同，团队可以从不同的象限开始测试策略的制定。事实上，Q1-Q4仅仅是一个编号，与时间、阶段并无关系，Lisa Crispin还专门<a href="http://lisacrispin.com/2011/11/08/using-the-agile-testing-quadrants/">撰文解释</a>过。</p>

<p>关于QA如何在软件分析的上游就介入，然后通过BDD的方式与业务分析师一起产出软件的各种规格描述，并通过实例的方式来帮助整个团队对需求的理解，ThoughtWorks的林冰玉有一篇文章很好的介绍了<a href="http://insights.thoughtworkers.org/when-we-talk-about-bdd/">BDD的正确做法</a>。如果将QA的外延扩展到在线的生产环境，制定合理的测量指标，调整测试策略，强烈推荐林冰玉写的另一篇文章<a href="http://www.jianshu.com/p/20b454a88bdb">产品环境中的QA</a>。</p>

<h4>其他职责</h4>

<p>事实上，软件生命周期中有很多的活动，有很多处于<code>灰色</code>地段。既可以说是应该开发做，又可以说应该QA做，甚至可以推给其他角色（比如OPs）。不过我们知道，一旦涉及角色，人们就再也不会按照<code>全局优化</code>的思路来应对问题了。这种<code>灰色</code>的活动包括：</p>

<ul>
<li>持续集成的搭建</li>
<li>测试环境的创建于维护</li>
<li>UAT上的数据准备</li>
<li>代码中的测试代码的维护</li>
<li>测试代码的重构</li>
</ul>


<p>在团队实践中，这些活动我们通常会让QA和开发或者OPs同事一起结对来完成。一方面避免知识孤岛的形成，另一方面在跨角色的工作中，也可以激发出更多不同的思路。</p>

<h3>万能的QA？</h3>

<p>虽然在这些活动中，QA都会参与，但是并不是说团队里只要有一个QA就可以了。QA在参与这些活动时，侧重点还是有很大不同的。</p>

<p>比如需求分析阶段，如果有QA的加入，一些从QA角度可以发现的有明显缺陷的场景，则可以在分析阶段就得到很好的处理。另一方面，尽早介入可以设计出更合理的测试计划（比如哪些功能的优先级比较高，用户更会频繁使用，那么对应的测试比重也会更高）。在Story分析与书写阶段，QA可以帮助写出更加合理的验收条件，既满足业务需求，又可以很好的指导开发。</p>

<p>在和开发一起编写澄清需求时，主要是编写自动化验收测试，而不是实际编写业务逻辑的实现（虽然QA应该参与<code>Code Reivew</code>环节，学习并分享自己的观点）；甚至在上线运维阶段，QA还需要和OPs一起来设计用户数据的采集指标（比如用户访问的关键路径，浏览器版本，地区的区分等），从而制定出新的测试策略。</p>

<h3>扩展阅读</h3>

<ul>
<li><a href="http://www.slideshare.net/abagmar/what-is-agile-testing-how-does-automation-help">What is Agile testing - How does automation help?</a></li>
<li><a href="http://insights.thoughtworkers.org/agile-showcase-se7en/">敏捷实践Showcase的七宗罪</a></li>
<li><a href="http://www.jianshu.com/p/20b454a88bdb">产品环境下的QA</a></li>
<li><a href="https://book.douban.com/subject/5338399/">《敏捷软件测试》</a></li>
</ul>


<p>P.S. 感谢林冰玉对本文的<code>Review</code>和指导。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/09/how-to-design-a-training/">如何设计一次培训</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-09-10T13:35:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>培训元模式</h2>

<p>最近在帮客户设计一个<code>微服务进阶版培训</code>的材料，整理的过程中我意识到这类事情我已经做过好多次了。比如在ThoughtWorks的<code>P2能力建设</code>项目，<a href="http://icodeit.org/3p3w/">3周3页面</a>工作坊等等，我觉得应该将<code>设计课程/设计培训</code>中的模式、原则和实践都提取一下，形成一个元模式（即关于培训的培训）。</p>

<p>一个培训中的活动，按照时间顺序可以分为三个步骤：</p>

<ol>
<li>设计培训内容</li>
<li>培训前期准备</li>
<li>培训中的一些实践</li>
</ol>


<h3>设计培训内容</h3>

<p>根据经验，只有那些正好处于瓶颈阶段，需要别人给予一些具体指导的人，培训是最有效的。比如我最近在学习iOS开发，那么<code>用Swift开发一个Todo List应用</code>就特别合适，而另一个<code>基于Objective-C的自动化测试</code>则对我来说一点用也没有（即使这个可能更高级，讲师更牛）。</p>

<p>在任何一个培训可能的设计之前，首先需要回答几个问题：</p>

<ol>
<li>培训目的是什么？</li>
<li>参与者对主题的了解程度如何？</li>
<li>参与者的组成比例（比如junior占比，senior占比等）</li>
<li>结果如何检验？</li>
</ol>


<h4>一个例子</h4>

<p>例子是人类的好朋友，这里我们来看一个例子：</p>

<blockquote><p>客户要为负责开发的同事做一次培训，培训的目的是要帮助他们建立<code>微服务架构</code>下的常见实践的知识框架。从结果的长期效果来看，这次培训要能指导实际的开发工作。参与者对<code>微服务</code>的一些概念有初步了解，也做过小的练习，但是诸如如何划分服务边界，如何拆分微服务等，都不了解，也比较迫切的想要了解。</p></blockquote>

<p>根据这个上下文，客户希望在培训中可以传递这样一些内容：</p>

<ul>
<li>如何拆分微服务</li>
<li>常见的微服务设计原则</li>
<li>拆分微服务的时机</li>
<li>如何做微服务的测试</li>
</ul>


<p>为了确保信息传递的准确性，我问了一遍上边都提到的列表，并且得到了答案：</p>

<ul>
<li>听众是开发经验相对丰富的开发（3-5年）</li>
<li>学习拆分为了将大的应用拆分，以方便维护</li>
<li>自动化测试能力和意识都较为薄弱</li>
<li>听众自己的期望是可以有一些切实可以指导实际开发的收获</li>
</ul>


<p>在有了这些输入的情况下，我做出了这样一些调整：</p>

<ul>
<li>不专门讲拆分微服务</li>
<li>主要精力讲<a href="https://github.com/abruzzi/jigsaw-ddd">DDD</a>（Domain Driven Design）</li>
<li>设计迭代式的，逐步变得复杂的场景来练习DDD</li>
<li>讲解和练习<a href="https://github.com/abruzzi/cdc-demo">自动化测试</a>（Consumer Driven Contract）</li>
<li>Session+Workshop+讨论的形式</li>
</ul>


<p>看了这个计划之后，客户开始觉得挺困惑，说这个怎么跟我们梳理的课程诉求不一致？对于这个疑惑，我的建议是这样的：</p>

<ul>
<li>之前的例子不能落地（找不到足够复杂的，又适合在培训中拆分的场景）</li>
<li>微服务的核心不是基础设施，而是设计原则，或者说如何在开发中找出边界</li>
<li>有了DDD的指导，划分本身并非难事儿</li>
<li>自动化测试（集成测试和契约测试）的能力和认识必须建立</li>
</ul>


<p>然后我把整理好的课件，实例分解，课程安排给客户讲了一遍之后，他觉得很满意。客户自己也是懂技术的，在分析了现状之后，后来又专门要求给部门内做一些<code>DDD</code>培训（而不是微服务本身）。</p>

<h3>培训方式</h3>

<p>同样，方式上也需要一些问题的解答才能有效进行：</p>

<ol>
<li>培训总时长</li>
<li>更偏重练习还是偏重讲解（工作坊还是Session，以及各自的占比）</li>
<li>参与者如何投入（比如是工作时间，还是晚上等）</li>
</ol>


<p>根据经验来看，不论是TWU还是对<code>客户</code>的培训，工作坊和Session结合的方式效果最好。
Workshop至少需要包含这样几部分：</p>

<ul>
<li>明确要做的练习（多长时间，达到什么目的等）</li>
<li>Showcase（参与感，如果有多轮的话，要保证每个人都有Show的机会，而不是每次同一个人）</li>
<li>讨论环节（点评，这个时机可以做一些小结，将要传递的信息润物细无声的传递出去）</li>
</ul>


<p><img src="/images/2016/09/workshop-resized.png" alt="workshop" /></p>

<p>应该避免的做法是:</p>

<ul>
<li>一个无法完成的任务</li>
<li>过长的时间</li>
<li>没有讨论，没有点评（特别是在中国文化中，Trainer有指出对错的<code>义务</code>）</li>
</ul>


<p>而<code>Session</code>则简单一些，交互比较少，需要讲师之前做足功课</p>

<ul>
<li>有清晰的Agenda（时长，要传递的大致内容）</li>
<li>如果是讲方法论（DDD，BDD等等），最好结合实践</li>
<li>不要讲代码（没有人能看清你的编辑器，也没有人有耐心看超过1行的代码）</li>
<li>一次不要传递太多信息（只讲三点）</li>
</ul>


<p>两者穿插起来，可以收到很好的效果，既不至于让人觉得没有内容，也不会感觉只说不练。</p>

<h4>预演（Dry Run）</h4>

<p>在进行实际的实施之前，可以从参与者中找出一些典型的人进行交流，<code>dry run</code>一两次。不过交流也需要平衡一些事实：</p>

<ol>
<li>侧重点（做对的事情），比如从设计的层面来讲，DDD，重构等方法的掌握比服务的可用性要重要很多</li>
<li>参与者想要听的和主题的相关性（比如培训目的是Story拆分，那么测试驱动开发的需求就要果断放弃）</li>
</ol>


<p>持续建立关注点，引导发散，归纳问题，归类并给出见解和可能的方案。</p>

<h4>如何回答问题</h4>

<p>有两种教学方式：苏格拉底式和填鸭式。苏格拉底式讲究只问不答，通过讲师不断提问的方式让学员自己思考，琢磨，并期望领悟；填鸭式则恰恰相反，假设学员没有任何能动性，讲师纯粹将自己知道的全部告诉学员。</p>

<p>这其实两者在时间中都不合适。有一个度可以把握的是：</p>

<blockquote><p>善待问者如撞钟，叩之以小者则小鸣，叩之以大者则大鸣，待其从容，然后尽其声。</p></blockquote>

<p>即根据提问的深度来反馈，比如<code>JavaScript</code>培训，学生问如何声明一个数组，讲师讲词法作用域，则费劲而没有效果。经过一段时间的练习和积累之后，学生会问出更深入的问题，这时候再逐步提高答案的深度。</p>

<h3>实践</h3>

<h4>Energize</h4>

<p>如果培训在白天的话，在午饭后，人们自然会感到困倦，这时候需要一些<code>提神</code>的小游戏帮助人们清醒。适度的紧张（比如简单的7Up游戏）或者肢体动作（做几个广播体操的动作）都会帮助人们振奋精神。</p>

<ul>
<li>围成一个圈的丢球自我介绍</li>
<li>A和B向对方互相介绍自己，然后A反过来向整个Group介绍B，B向整个Group介绍A</li>
<li>7Up</li>
<li>丢空气球</li>
</ul>


<h4>工作坊基本准则</h4>

<ol>
<li>按时参加</li>
<li>保持One convensition</li>
<li>手机静音</li>
</ol>


<h4>分组进行</h4>

<p>分组讨论是一个很好的实践，既可以避免<code>只说不练</code>的现象，又可以让参与者有充分的参与感，还可以让培训的时间长度更灵活，更容易控制。</p>

<p>分组可以用报数的方法，通常人们习惯和自己熟悉的人坐在一起。这会促进他们交头接耳的几率，分组时可以通过报数的方式，比如目标是分为3组，就依次报数1、2、3，然后所有报1的人为1组，报2的人为2组，以此类推。</p>

<p>一个我自己常用的伎俩是自由调整时间。比如在一个练习开始前，你告诉参与者他们有10分钟来完成一个Task，然后在5分钟后，你发现大家都基本已经做完了，这时候可以直接说：时间到！（相信我，没有人真正看表的，他们通常会被手头的任务搞得焦头烂额）。反过来，你可以说：再延长5分钟！以督促那些比较慢的小组动作更快一些，而事实上他们还没有用完限定的10分钟。</p>

<p><img src="/images/2016/09/grouping-resized.png" alt="grouping" /></p>

<h4>Parking lot</h4>

<p>培训当然需要参与者和trainer的积极互动，但是有时候参与者提出的问题不太适合在课堂上展开：</p>

<ul>
<li>与培训主题关联并不太大</li>
<li>比较个例的问题</li>
<li>争议较大，难以在短时间内讨论清楚的</li>
</ul>


<p>这些问题可以记录下来，在正式课程时间结束后单点讨论，或者作为下一次备课的关键点，加入到课件中。</p>

<h4>Retro</h4>

<p>和我们倡导的一切活动一样，培训也需要有始有终。我们需要收集参与者的反馈，包括positive的和constructive的，这样经过几轮迭代之后，培训会成熟而具有一定的可复制性。</p>

<p>可以分成三类：<code>做得好的/有待提高的/一些疑问/建议</code></p>

<p>将问题分组讨论之后，分为三组，然后讨论出一些解决方法。</p>

<p><img src="/images/2016/09/retro-resized.png" alt="retro" /></p>

<h4>其他</h4>

<ul>
<li>二维码+金数据表单</li>
<li>白板+白板笔</li>
<li>Flipchart</li>
</ul>


<h3>总结</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/05/practise-in-programming/">无他，但手熟尔</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-05-26T22:56:00+08:00" pubdate data-updated="true">May 26<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>高效幻象</h2>

<p>通过对自己的行为观察，我发现在很多时候，我以为我掌握了的知识和技能其实并不牢靠。我引以为豪的<code>高效</code>其实犹如一个彩色的肥皂泡，轻轻一碰就会破碎，散落一地。</p>

<h3>你可能只是精通搜索</h3>

<p>我们现在所处的时代，信息爆炸，每个人每天都会接触，阅读很多的信息，快速消费，快速遗忘。那种每天早上起来如同皇帝批阅奏折的、虚假的误以为掌握知识的错觉，驱动我们进入一个恶性循环。</p>

<p>即使在我们真的打算解决问题，进行主动学习时，更多的也只是在熟练使用搜索引擎而已（在一个领域待久了，你所使用的关键字准确度自然要比新人高一些，仅此而已）。精通了高效率搜索之后，你会产生一种你<code>精通搜索到的知识本身</code>的<strong>错觉</strong>。</p>

<p><img src="/images/2016/05/stackoverflow-oreilly.png" alt="stack overflow" /></p>

<h4>如何写一个Shell脚本</h4>

<p>在写博客的时候，我通常会在文章中配图。图片一般会放在一个有固定格式的目录中，比如现在是2016年5月，我本地就会有一个名为<code>$BLOG_HOME/images/2016/05</code>的目录。由于使用的是<code>markdown</code>，在插入图片时我就不得不输入完整的图片路径，如：<code>/images/2016/05/stack-overflow.png</code>。但是我又不太记得路径中的<code>images</code>是单数(<code>image</code>)还是复数(<code>images</code>)，而且图片格式又可能是<code>jpg</code>,<code>jpeg</code>,<code>gif</code>或者<code>png</code>，我也经常会搞错，这会导致图片无法正确显示。另外，放入该目录的原始文件尺寸有可能比较大，我通常需要将其缩放成800像素宽（长度无所谓，因为文章总是要从上往下阅读）。</p>

<p>为了自动化这个步骤，我写了一个小的Shell脚本。当你输入一个文件名如：<code>stack-overflow.png</code>后，它会缩放这个文件到800像素宽，结果是一个新的图片文件，命名为<code>stack-overflow-resized.png</code>，另外它将符合<code>markdown</code>语法的文件路径拷贝到剪贴板里：<code>/images/2016/05/stack-overflow-resized.png</code>，这样我在文章正文中只需要用<code>Command+V</code>粘贴就可以了。</p>

<p>有了思路，写起来就很容易了。缩放图片的命令我是知道的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>convert -resize 800 stack-overflow.png stack-overflow-resized.png
</span></code></pre></td></tr></table></div></figure>


<p>但是要在文件明上加入<code>-resized</code>，需要分割文件名和文件扩展名，在<code>Bash</code>里如何做到这一点呢？Google一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">FULLFILE</span><span class="o">=</span><span class="nv">$1</span>
</span><span class='line'>
</span><span class='line'><span class="nv">FILENAME</span><span class="o">=</span><span class="k">$(</span>basename <span class="s2">&quot;$FULLFILE&quot;</span><span class="k">)</span>
</span><span class='line'><span class="nv">EXTENSION</span><span class="o">=</span><span class="s2">&quot;${FILENAME##*.}&quot;</span>
</span><span class='line'><span class="nv">FILENAME</span><span class="o">=</span><span class="s2">&quot;${FILENAME%.*}&quot;</span>
</span><span class='line'>
</span><span class='line'>convert -resize 800 <span class="nv">$FULLFILE</span> <span class="nv">$FILENAME</span>-resized.EXTENSION
</span></code></pre></td></tr></table></div></figure>


<p>难看是有点难看，不过还是可以工作的。接下来是按照当前日期生成完整路径，<code>date</code>命令我是知道的，而且我知道它的<code>format</code>格式很复杂，而且跟<code>JavaScript</code>里Date对象的<code>format</code>又不太一样（事实上，世界上有多少种日期工具，基本上就有多少种格式）。再Google一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>date +<span class="s2">&quot;/images/%Y/%m/&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后一步将路径拷贝到剪贴板也容易，Mac下的<code>pbcopy</code>我也会用：<code>echo</code>一下字符串变量，再管道到<code>pbcopy</code>即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">PREFIX</span><span class="o">=</span><span class="sb">`</span>date +<span class="s2">&quot;/images/%Y/%m/&quot;</span><span class="sb">`</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;$PREFIX$FILENAME-resized.EXTENSION&quot;</span> | pbcopy
</span></code></pre></td></tr></table></div></figure>


<p>但是将内容粘贴到<code>markdown</code>里之后，我发现这个脚本多了一个换行。我想这个应该是<code>echo</code>自己的行为吧，会给字符串自动加上一个换行符。Google一下，发现加上<code>-n</code>参数就可以解决这个问题。</p>

<p>好了，完整的脚本写好了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nv">FULLFILE</span><span class="o">=</span><span class="nv">$1</span>
</span><span class='line'>
</span><span class='line'><span class="nv">FILENAME</span><span class="o">=</span><span class="k">$(</span>basename <span class="s2">&quot;$FULLFILE&quot;</span><span class="k">)</span>
</span><span class='line'><span class="nv">EXTENSION</span><span class="o">=</span><span class="s2">&quot;${FILENAME##*.}&quot;</span>
</span><span class='line'><span class="nv">FILENAME</span><span class="o">=</span><span class="s2">&quot;${FILENAME%.*}&quot;</span>
</span><span class='line'>
</span><span class='line'>convert -resize 800 <span class="nv">$FULLFILE</span> <span class="nv">$FILENAME</span>-resized.EXTENSION
</span><span class='line'>
</span><span class='line'><span class="nv">PREFIX</span><span class="o">=</span><span class="sb">`</span>date +<span class="s2">&quot;/images/%Y/%m/&quot;</span><span class="sb">`</span>
</span><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;$PREFIX$FILENAME-resized.EXTENSION&quot;</span> | pbcopy
</span></code></pre></td></tr></table></div></figure>


<p>嗯，还不错，整个过程中就用了我十几分钟时间而已，以后我在写博客时插入图片就方便多了！</p>

<p>不过等等，好像有点不对劲儿，我回过头来看了看这段脚本：7行代码只有1行是我独立写的！没有<code>Google</code>的话，查看<code>man date</code>和<code>man echo</code>也可以解决其中一部分问题，不过文件扩展名部分估计又得花较长时间。</p>

<p>仔细分析一下，之前的成就感荡然无存。</p>

<h4>更多的例子</h4>

<p>我相信，过几周我再来写这样一个简单的脚本时，上面那一幕还是会出现。开发者的IDE的外延已经将<code>Google</code>和<code>Stack Overflow</code>集成了。很难想象没有这两个IDE的<code>插件</code>我要怎样工作。</p>

<p>其实除此之外，日常工作中这样的事情每时每刻都在发生：</p>

<ol>
<li>Ansible里如何创建一个给用户<code>robot</code>读写权限的目录？</li>
<li>Python 3中启动简单HTTPServer的命令是？</li>
<li>Spring Boot的Gradle String是？</li>
<li>Mongodb中如何为用户<code>robot</code>授权？</li>
<li>Gulp里一个Task依赖另一个Task怎么写？</li>
</ol>


<p>等等等等，这个列表可以根据你的技术栈，偏向前端/后端的不同而不同，但是相同的是在<code>Google</code>和<code>Stack Overflow</code>上搜索，阅读会浪费很多时间，而这些本来都是可以避免的。</p>

<h3>肌肉记忆</h3>

<p>大脑在对信息存储上有很高级的设计，如果某件事情不值得记忆，大脑会自动过滤掉（比如我们很容易获得的搜索结果）。而对于那些频繁发生，计算结果又不会变化的信息，大脑会将其下放到“更低级别”的神经去记忆。比如各种运动中的肌肉记忆，习武之人梦寐以求的“拳拳服膺”，“不期然而然，莫知之而至”。</p>

<p>这里也有两个小例子：</p>

<h4>一个C语言的小程序</h4>

<p>上周末我买了一个茶轴的机械键盘，打开包装之后我很兴奋，赶紧插在我的笔记本上，打开一个编辑器，心说敲一些代码体验一下。几秒钟后，我发现敲出来的是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp"># include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp"># include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Usage: %s ip port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;Connecting to %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在命令行里</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>gcc -o hello hello.c
</span><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Usage: ./hello ip port
</span><span class='line'>
</span><span class='line'><span class="nv">$ </span>./hello 10.180.1.1 9999
</span><span class='line'>Connecting to 10.180.1.1 9999
</span></code></pre></td></tr></table></div></figure>


<p>整个过程极为流畅，上一次开发C代码已经是4年多前了。也就是说，我的手指已经记下了所有的这些命令：</p>

<ol>
<li>Linux下<code>main</code>函数的convention</li>
<li><code>fprintf</code>的签名</li>
<li><code>stderr/stdout</code>用法的区分</li>
<li><code>main</code>函数不同场景的返回值</li>
<li><code>gcc</code>命令的用法</li>
</ol>


<p>另外一个小例子是<code>vim</code>编辑器。我使用<code>vim</code>已经有很多年了，现在在任何一个Linux服务器上，编辑那些<code>/etc/nginx/nginx.conf</code>之类的配置文件时，手指就会<code>自动</code>的找到快捷键，<code>自动</code>的完成搜索，替换，跳转等等操作。</p>

<h3>刻意练习</h3>

<p>对比这两个例子，一方面我惊讶于自己目前对搜索引擎、<code>Stack Overflow</code>的依赖；一方面惊讶于<code>肌肉记忆力</code>的深远和神奇。结合一下两者，我发现自己的开发效率有望得到很大的提升。</p>

<p>比如上面列出的那些略显尴尬的问题，如果我的手指可以<code>自动</code>的敲出这些答案，那么节省下的搜索、等待、阅读的时间就可以用来干别的事情，比如跑步啊，骑车啊，去驾校学车被教练骂啊等等，总之，去过自己的生活。</p>

<p>这方面的书籍，博客都已经有很多，比如我们在ThoughtWorks University里实践的<code>Code Kata</code>，<code>JavaScript Dojo</code>，<code>TDD Dojo</code>之类，都已经证明其有效性。</p>

<p>如果你打算做一些相关的练习，从<code>Kata</code>开始是一个不错的选择。每个<code>Kata</code>都包含一个简单的编程问题，你需要不断的去练习它（同一个题目做20遍，50遍等）。前几次你是在解决问题本身，慢慢就会变成在审视自己的编程习惯，发现并改进（比如快捷键的使用，语法的熟悉程度等等），这样在实际工作中你会以外的发现自己的速度变快了，而且对于重构的信心会变大很多。其实道理也很简单：如果你总是赶着deadline来完成任务，怎么会有时间来做优化呢？</p>

<p>这里有一些参考资料和<code>Kata</code>的题目，可供参考：</p>

<ul>
<li><a href="https://sites.google.com/site/steveyegge2/practicing-programming">Practicing Programming</a></li>
<li><a href="https://blog.codinghorror.com/the-ultimate-code-kata/">The Ultimate Code Kata</a></li>
<li><a href="http://codekata.com/">一些Kata的题目</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/05/design-for-failure/">为故障和失败做设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-05-17T22:34:00+08:00" pubdate data-updated="true">May 17<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>为故障和失败做设计</h2>

<p>先来看一个笑话：</p>

<blockquote><p>QA工程师走进酒吧，要了一杯啤酒，要了0杯啤酒，要了999999999杯啤酒，要了一只蜥蜴，要了-1杯啤酒，要了一个sfdeljknesv，酒保从容应对，QA工程师 很满意。接下来，一名顾客来到了同一个酒吧，问厕所在哪，酒吧顿时起了大火，然后整个建筑坍塌了。</p></blockquote>

<p>事实上，无论我们事先做多么详尽的计划，我们还是会失败。而且大多数时候，失败、故障都会从一个我们无法预期的角度发生，令人猝不及防。</p>

<p>如果没有办法避免失败（事先要考虑到这么多的异常情况不太现实，而且会投入过多的精力），那么就需要设计某种机制，使得当发生这种失败时系统可以将损失降低到最小。</p>

<p>另一方面，系统需要具备从灾难中回复的能力。如果由于某种原因，服务进程意外终止了，那么一个<code>watchdog</code>机制就会非常有用，比如supervisord就可以用来保证进程意外终止之后的自动启动。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[program:jigsaw]</span>
</span><span class='line'><span class="na">command</span><span class="o">=</span><span class="s">java -jar /app/jigsaw.jar</span>
</span><span class='line'><span class="na">startsecs</span><span class="o">=</span><span class="s">0</span>
</span><span class='line'><span class="na">stopwaitsecs</span><span class="o">=</span><span class="s">0</span>
</span><span class='line'><span class="na">autostart</span><span class="o">=</span><span class="s">true</span>
</span><span class='line'><span class="na">autorestart</span><span class="o">=</span><span class="s">true</span>
</span><span class='line'><span class="na">stdout_logfile</span><span class="o">=</span><span class="s">/var/log/jigsaw/app.log</span>
</span><span class='line'><span class="na">stderr_logfile</span><span class="o">=</span><span class="s">/var/log/jigsaw/app.err</span>
</span></code></pre></td></tr></table></div></figure>


<p>在现实世界中，设计一个无缺陷的系统显然是不可能的，但是通过努力，我们还是有可能设计出具有弹性，能够快速失败，从失败中恢复的系统来。</p>

<h3>错误无可避免</h3>

<h4>令人担心的错误处理</h4>

<p>我们先来看两个代码片段，两段代码都是在实现一个典型的Linux下的Socket服务器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">serversock</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">serversock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
</span><span class='line'>  <span class="n">setup_sockaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span><span class='line'>  <span class="n">bind</span><span class="p">(</span><span class="n">serversock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">));</span>
</span><span class='line'>  <span class="n">listen</span><span class="p">(</span><span class="n">serversock</span><span class="p">,</span> <span class="n">MAXPENDING</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果加上现实中可能出现的各种的处理，代码会变长一些：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">serversock</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;USAGE: server &lt;port&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">((</span><span class="n">serversock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to create socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">setup_sockaddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">serversock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span>
</span><span class='line'>                               <span class="k">sizeof</span><span class="p">(</span><span class="n">server</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to bind the server socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">serversock</span><span class="p">,</span> <span class="n">MAXPENDING</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to listen on server socket</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>早在上学的时候，我在编写程序时就非常害怕处理错误情况。一方面加入错误处理会导致代码变长、变难看，另一方面是担心有遗漏掉的点，更多的则是对复杂多变的现实环境中不确定性的担忧。</p>

<p>每当写这样的代码时，我都会陷入深深的焦虑：如果真的出错了怎么办？事实上我也经常会遇到错误，比如命令行参数没有写对，绑定一个
已经被占用的端口，磁盘空间不足等等。工作之后，这些烦人的问题其实也并不经常出现。偶尔出现时我们也有很好的日志来帮助定位，最后问题总会解决，不过那种对不确定性的担心仍然深藏心底。</p>

<h4>UDP协议</h4>

<p>早在大学网络课上，我就已经对不靠谱的<code>UDP</code>协议非常不满了：作为一个网络协议，竟然不能保证数据可靠的传送到网络的另一端，如果数据没有丢失，也无法保证次序。这种有点不负责任的协议我从来不用，甚至在做练习时都会将其自动过滤，不管那种编程语言，我都会优先考虑<code>TCP</code>。</p>

<p>不过在学习网络视频传输的时候，我发现很多时候人们都会采用<code>UDP</code>。另外很多场景下，比如最早的<code>QQ</code>也都使用了<code>UDP</code>来作为内网穿透等设计者可能都没有考虑到的功能。</p>

<p>事实上，这种看似不靠谱的协议在很多IM软件中都在采用（混合模式），比如Skype：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>lsof -i -n | grep -i skype | awk <span class="s1">&#39;{print $1, $8, $9}&#39;</span>
</span><span class='line'>Skype TCP 192.168.0.101:52093-&gt;91.190.219.39:12350
</span><span class='line'>Skype UDP 127.0.0.1:50511
</span><span class='line'>Skype TCP 192.168.0.101:53090-&gt;40.113.87.220:https
</span><span class='line'>Skype UDP *:*
</span><span class='line'>Skype TCP 192.168.0.101:52240-&gt;64.4.61.220:https
</span><span class='line'>Skype TCP 192.168.0.101:14214
</span><span class='line'>Skype UDP *:63639
</span><span class='line'>Skype UDP 192.168.0.101:14214
</span><span class='line'>Skype TCP 192.168.0.101:52544-&gt;168.63.205.106:https
</span><span class='line'>Skype TCP 192.168.0.101:52094-&gt;157.55.56.145:40032
</span><span class='line'>Skype TCP 192.168.0.101:52938-&gt;40.113.87.220:https
</span><span class='line'>Skype TCP 192.168.0.101:53091-&gt;40.113.87.220:https
</span><span class='line'>Skype TCP 192.168.0.101:53092-&gt;40.113.87.220:https
</span></code></pre></td></tr></table></div></figure>


<p>这种简单，不保证可靠性的协议有强大的适应性，在大部分网络环境都是适用的。在工程中，人们会将它和TCP混合适用，在诸如视频，语音的传输中，小规模的丢包，失序都是可以接受的，毕竟还有人类大脑这样的高级处理器负责纠正那些网络错误。</p>

<h3>处理失败的模式</h3>

<h4>超时机制</h4>

<p>对于网络上的第三方依赖，你无法预料它的响应延迟是什么样子的，它可能每秒钟可以处理10000次请求而游刃有余，也可能在处理100个并发时就会无限期阻塞，你需要为这种情况有所准备。</p>

<p><code>nginx</code>通常被用作一个网关，它总是处于请求的最前端，因此其中有很多关于超时的设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>location /api <span class="o">{</span>
</span><span class='line'>  proxy_pass http://api.backend;
</span><span class='line'>  proxy_connect_timeout 500s;
</span><span class='line'>  proxy_read_timeout 500s;
</span><span class='line'>  proxy_send_timeout 500s;
</span><span class='line'>
</span><span class='line'>  proxy_set_header        X-Real-IP <span class="nv">$remote_addr</span>;
</span><span class='line'>  proxy_set_header        X-Forwarded-For <span class="nv">$proxy_add_x_forwarded_for</span>;
</span><span class='line'>  proxy_set_header        Host <span class="nv">$http_host</span>;
</span><span class='line'> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如上面<code>/api</code>这个虚拟host中就有连接超时，读超时，后端写超时等设置。在实际环境中，<code>Fail Fast</code>是对无法预料错误的<strong>最好</strong>处理方法。缓慢的处理会阻塞其他请求，并很快堆积，然后耗尽系统资源。</p>

<p>系统超时配置只是一部分，在你自己的代码中也应该为所有网络依赖加上合适的超时机制：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Staff</span><span class="o">&gt;</span> <span class="n">fetchUserByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">JIGSAW_ENDPOINT</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Client</span> <span class="n">client</span> <span class="o">=</span> <span class="n">ClientBuilder</span><span class="o">.</span><span class="na">newClient</span><span class="o">(</span><span class="k">new</span> <span class="n">ClientConfig</span><span class="o">());</span>
</span><span class='line'>    <span class="n">client</span><span class="o">.</span><span class="na">property</span><span class="o">(</span><span class="n">ClientProperties</span><span class="o">.</span><span class="na">CONNECT_TIMEOUT</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
</span><span class='line'>    <span class="n">client</span><span class="o">.</span><span class="na">property</span><span class="o">(</span><span class="n">ClientProperties</span><span class="o">.</span><span class="na">READ_TIMEOUT</span><span class="o">,</span>    <span class="mi">10</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Invocation</span><span class="o">.</span><span class="na">Builder</span> <span class="n">request</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">target</span><span class="o">(</span><span class="n">url</span><span class="o">).</span><span class="na">request</span><span class="o">(</span><span class="n">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">Staff</span><span class="o">&gt;</span> <span class="n">staff</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">staff</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Staff</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">staff</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">staff</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>回退机制</h4>

<p>如果应用程序无法获得正常的响应，那么提供优雅的回退机制在大多数情况下是必须的，而且这样做通常也不会很复杂。以Netflix的<code>Hystrix</code>库为例，如果一个异步命令失败（比如网络异常，超时等），它提供<code>Fallback</code>机制来返回客户端一个默认实现（或者一份本地缓存中的数据）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@HystrixCommand</span><span class="o">(</span><span class="n">fallbackMethod</span> <span class="o">=</span> <span class="s">&quot;getDefaultStaffInfo&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Staff</span> <span class="nf">getStaffInfo</span><span class="o">(</span><span class="n">String</span> <span class="n">loginName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//fetch from remote server</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="n">Staff</span> <span class="nf">getDefaultStaffInfo</span><span class="o">(</span><span class="n">String</span> <span class="n">loginName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nf">Staff</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>熔断器</h4>

<p><img src="/images/2016/05/circuit_breaker.jpg" alt="Circuit Breaker" /></p>

<p>熔断器模式指当应用在依赖方响应过慢或者出现很多超时时，调用方主动熔断，这样可以防止对依赖方造成更严重的伤害。过一段时间之后，调用方会以较慢的速度开始重试，如果依赖方已经恢复，则逐步加大负载，直到恢复正常调用。如果依赖方还是没有就绪，那就延长等待时间，然后重试。这种模式使得系统在某种程度上显现出动态性和智能。</p>

<p>Netflix的Hystrix库已经提供了这种能力，事实上，如果你使用Spring Cloud Netfilx，这个功能是内置在系统中的，你只需要一些注解就可以让系统具备这样的能力：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@SpringBootApplication</span>
</span><span class='line'><span class="nd">@EnableCircuitBreaker</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">Application</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果5秒内连续失败了20次，Hystrix会进入<code>熔断</code>模式，后续的请求不会再发送。过一段时间之后，Hystrix又会逐步尝试恢复负载。</p>

<h3>后记</h3>

<p>扩展阅读：</p>

<ul>
<li><a href="https://book.douban.com/subject/26304417/">《发布！软件的设计与部署》</a></li>
<li><a href="https://book.douban.com/subject/24838618/">《反脆弱》</a></li>
</ul>


<p>技术文章：</p>

<ul>
<li><a href="http://www.kennybastani.com/2015/07/spring-cloud-docker-microservices.html">Spring Cloud &amp; Docker</a></li>
<li><a href="http://ryanjbaxter.com/2015/10/12/building-cloud-native-apps-with-spring-part-5/">Build Cloud Native Apps</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/05/about-session-and-security-api-2/">保护你的API（下）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-05-12T22:50:00+08:00" pubdate data-updated="true">May 12<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>前后端分离之后</h2>

<p>前后端分离之后，在部署上通过一个反向代理就可以实现动静态分离，跨域问题的解决等。但是一旦引入鉴权，则又会产生新的问题。通常来说，鉴权是对于后台API/API背后的资源的保护，即<strong>未经授权的用户不能访问受保护资源</strong>。</p>

<p>要实现这个功能有很多种方式，在应用程序之外设置完善的安全拦截器是最常见的方式。不过有点不够优雅的是，一些不太纯粹的、非功能性的代码和业务代码混在同一个代码库中。</p>

<p>另一方面，各个业务系统都可能需要某种机制的鉴权，所以很多企业都会搭建SSO机制，即<a href="https://en.wikipedia.org/wiki/Single_sign-on">Single Sign-On</a>。这样可以避免人们在多个系统创建不同账号，设置不同密码，不同的超时时间等等。如果SSO系统已经先于系统存在了很久，那么新开发的系统完全不需要自己再配置一套用户管理机制了（一般SSO只会完成<strong>鉴权</strong>中<strong>鉴别</strong>的部分，<strong>授权</strong>还是需要各个业务系统自行处理）。</p>

<p>本文中，我们使用基础设施（反向代理）的一些配置，来完成<strong>保护未授权资源</strong>的目的。在这个例子中，我们假设系统由这样几个服务器组成：</p>

<h3>系统组成</h3>

<p>这个实例中，我们的系统分为三部分</p>

<ol>
<li><code>kanban.com:8000</code>（业务系统前端）</li>
<li><code>api.kanban.com:9000</code>（业务系统后端API）</li>
<li><code>sso.kanban.com:8100</code> （单点登录系统，登陆界面）</li>
</ol>


<p>前端包含了HTML/JS/CSS等资源，是一个纯静态资源，所以本地磁盘即可。后端API则是一组需要被保护的API（比如查询工资详情，查询工作经历等）。最后，单点登录系统是一个简单的表单，用户填入用户名和密码后，如果登录成功，单点登录会将用户重定向到登录前的位置。</p>

<p>我们举一个具体场景的例子：</p>

<ol>
<li>未登录用户访问<code>http://kanba.com:8000/index.html</code></li>
<li>系统会重定向用户到<code>http://sso.kanban.com:8100/sso?return=http://kanba.com:8000/index.html</code></li>
<li>用户看到登录页面，输入用户名、密码登录</li>
<li>用户被重定向回<code>http://kanba.com:8000/index.html</code></li>
<li>此外，<code>index.htm</code>l页面上的<code>app.js</code>对<code>api.kanban.com:9000</code>的访问也得到了授权</li>
</ol>


<h4>环境设置</h4>

<p>简单起见，可以通过修改/etc/hosts文件来设置服务器环境：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>127.0.0.1 sso.kanban.com
</span><span class='line'>127.0.0.1 api.kanban.com
</span><span class='line'>127.0.0.1 kanban.com</span></code></pre></td></tr></table></div></figure>


<h3>nginx及auth_request</h3>

<p>反向代理nginx有一个auth_request的模块。在一个虚拟host中，每个请求会先发往一个内部<code>location</code>，这个内部的<code>location</code>可以指向一个可以做鉴权的Endpoint。如果这个请求得到的结果是200，那么nginx会返回用户本来请求的内容，如果返回401，则将用户重定向到一个预定义的地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>server {
</span><span class='line'>    listen 8000;
</span><span class='line'>    server_name kanban.com;
</span><span class='line'>
</span><span class='line'>    root /usr/local/var/www/kanban/;
</span><span class='line'>
</span><span class='line'>    error_page 401 = @error401;
</span><span class='line'>
</span><span class='line'>    location @error401 {
</span><span class='line'>        return 302 http://sso.kanban.com:8100/sso?return=$scheme://$http_host$request_uri;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    auth_request /api/auth;
</span><span class='line'>
</span><span class='line'>    location = /api/auth {
</span><span class='line'>        internal;
</span><span class='line'>
</span><span class='line'>        proxy_pass http://api.kanban.com:9000;
</span><span class='line'>
</span><span class='line'>        proxy_pass_request_body     off;
</span><span class='line'>
</span><span class='line'>        proxy_set_header Content-Length "";
</span><span class='line'>        proxy_set_header X-Original-URI $request_uri;
</span><span class='line'>        proxy_set_header Host $http_host;
</span><span class='line'>        proxy_set_header X-Real-IP $remote_addr;
</span><span class='line'>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
</span><span class='line'>        proxy_set_header X-Forwarded-Proto $scheme;
</span><span class='line'>
</span><span class='line'>        if ($http_cookie ~* "w3=(\w+)") {
</span><span class='line'>            set $token "$1";
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        proxy_set_header X-KANBAN-TOKEN $token;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>比如上面这个例子中，<code>auth_request</code>的URL为<code>/api/auth</code>，它是一个内部的location，外部无法访问。在这个<code>locaiton</code>中，请求会被转发到<code>http://api.kanban.com:9000</code>，根据nginx的正则语法，请求将会被转发到<code>http://api.kanban.com:9000/api/auth</code>（我们随后可以看到这个Endpoint的定义）。</p>

<p>我们设置了请求的原始头信息，并禁用了request_body，如果cookie中包含了<code>w3=(\w+)</code>字样，则将这个w3的值抽取出来，并赋值给一个<code>X-KANBAN-TOKEN</code>的HTTP头。</p>

<h4>权限Endpoint</h4>

<p>对应的<code>/api/auth</code>的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RestController</span>
</span><span class='line'><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&quot;/auth&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthController</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@RequestMapping</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">ResponseEntity</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">simpleAuth</span><span class="o">(</span><span class="nd">@RequestHeader</span><span class="o">(</span><span class="n">value</span><span class="o">=</span><span class="s">&quot;X-KANBAN-TOKEN&quot;</span><span class="o">,</span> <span class="n">defaultValue</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="n">String</span> <span class="n">token</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span><span class="o">(</span><span class="n">StringUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">token</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="s">&quot;Unauthorized&quot;</span><span class="o">,</span> <span class="n">HttpStatus</span><span class="o">.</span><span class="na">UNAUTHORIZED</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="s">&quot;Authorized&quot;</span><span class="o">,</span> <span class="n">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果HTTP头上有<code>X-KANBAN-TOKEN</code>且值不为空，则返回200，否则返回401。</p>

<p>当这个请求得到401之后，用户被重定向到<code>http://sso.kanban.com:8100/sso</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">error_page</span> <span class="mi">401</span> <span class="o">=</span> <span class="nd">@error401</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">location</span> <span class="nd">@error401</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">302</span> <span class="nl">http:</span><span class="c1">//sso.kanban.com:8100/sso?return=$scheme://$http_host$request_uri;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>SSO组件（简化版）</h3>

<p>这里用<code>sinatra</code>定义了一个简单的SSO服务器（去除了实际的校验部分）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;sinatra&#39;</span>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;uri&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">set</span> <span class="ss">:return_url</span><span class="p">,</span> <span class="s1">&#39;&#39;</span>
</span><span class='line'><span class="n">set</span> <span class="ss">:bind</span><span class="p">,</span> <span class="s1">&#39;0.0.0.0&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="n">get</span> <span class="s1">&#39;/sso&#39;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">settings</span><span class="o">.</span><span class="n">return_url</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="ss">:return</span><span class="o">]</span>
</span><span class='line'>    <span class="n">send_file</span> <span class="s1">&#39;public/index.html&#39;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">post</span> <span class="s1">&#39;/login&#39;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">credential</span> <span class="o">=</span> <span class="n">params</span><span class="o">[</span><span class="ss">:credential</span><span class="o">]</span>
</span><span class='line'>  <span class="c1"># check credential against database</span>
</span><span class='line'>  <span class="n">uri</span> <span class="o">=</span> <span class="no">URI</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">return_url</span><span class="p">)</span>
</span><span class='line'>  <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s2">&quot;w3&quot;</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>      <span class="ss">:domain</span> <span class="o">=&gt;</span> <span class="s2">&quot;.</span><span class="si">#{</span><span class="n">uri</span><span class="o">.</span><span class="n">host</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="ss">:expires</span> <span class="o">=&gt;</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="o">+</span> <span class="mi">2400</span><span class="p">,</span>
</span><span class='line'>      <span class="ss">:value</span> <span class="o">=&gt;</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">credential</span><span class="o">[</span><span class="s1">&#39;name&#39;</span><span class="o">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s1">&#39;/&#39;</span>
</span><span class='line'>      <span class="p">})</span>
</span><span class='line'>  <span class="n">redirect</span> <span class="n">settings</span><span class="o">.</span><span class="n">return_url</span><span class="p">,</span> <span class="mi">302</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>/sso</code>对应的Login Form是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;/login&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">name=</span><span class="s">&quot;credential[name]&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;password&quot;</span> <span class="na">name=</span><span class="s">&quot;credential[password]&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/form&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当用户提交表单之后，我们只是简单的设置了<code>cookie</code>，并重定向用户到跳转前的URL。</p>

<h3>前端页面</h3>

<p>这个应用的前端应用非常简单，我们只需要将这些静态文件放到<code>/usr/local/var/www/kanban</code>目录下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>$ tree /usr/local/var/www/kanban
</span><span class='line'>
</span><span class='line'>├── index.html
</span><span class='line'>└── scripts
</span><span class='line'>    ├── app.js
</span><span class='line'>    └── jquery.min.js
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>index.html</code>中引用的<code>app.js</code>会请求一个受保护的资源：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">$</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">$</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/api/protected/1&#39;</span><span class="p">).</span><span class="nx">done</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#message&#39;</span><span class="p">).</span><span class="nx">text</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">content</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>从下图中的网络请求可以看到重定向的流程：</p>

<p><img src="/images/2016/05/redirection-resized.png" alt="redirection" /></p>

<h3>总结</h3>

<p>本文我们通过配置反向代理，将多个Endpoint组织起来。这个过程可以在应用程序中通过代码实现，也可以在基础设施中通过配置实现，通常来讲，如果可以通过配置来实现的，就尽量将其与负责业务逻辑的代码隔离出来。这样可以保证各个组件的独立性，也可以使得优化和定位问题更加容易。</p>

<p>完整的代码可以在这里下载：</p>

<ul>
<li><a href="https://github.com/abruzzi/fake-sso">Fake SSO</a></li>
<li><a href="https://github.com/abruzzi/spring-security-demo">Spring Security Demo</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2016/05/about-session-and-security-api-1/">保护你的API（上）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2016-05-10T19:12:00+08:00" pubdate data-updated="true">May 10<span>th</span>, 2016</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>保护你的API</h2>

<p>在大部分时候，我们讨论API的设计时，会从功能的角度出发定义出完善的，易用的API。而很多时候，非功能需求如安全需求则会在很晚才加入考虑。而往往这部分会涉及很多额外的工作量，比如与外部的SSO集成，Token机制等等。</p>

<p>这篇文章会以一个简单的例子，从应用程序和部署架构上分别讨论几种常见的模型。这篇文章是这个系列的第一篇，会讨论两个简单的主题：</p>

<ul>
<li>基于Session的用户认证</li>
<li>基于Token的RESTful API（使用Spring Security）</li>
</ul>


<h3>使用Session</h3>

<p>由于HTTP协议本身是无状态的，服务器需要某种机制来区分每个请求。比如在返回给客户的响应中加入一些ID，客户端再次请求时带上这个ID，这样服务器就可以区分出来每个请求，并完成事务性的操作（完成订单的创建，更新，商品派送等等）。</p>

<p>在多数Web容器中，这种机制通过Session来实现。Web容器会为每个首次请求创建一个Session，并将Session的ID以浏览器Cookie的方式返回给客户端。客户端（常常是浏览器）在后续的请求中带上这个Session的ID来表明自己的身份。这种机制同样被用在了鉴权方面，用户登录系统之后，系统分配一个Session ID给他。</p>

<p>除非Session过期，或者用户从客户端的Cookie中主动删了Session ID，否则在服务器端来看，用户的信息会和这个Session绑定起来。后台系统也可以随时知道请求某个资源的真实用户是谁，并以此来判断该用户时候真的有权限这么做。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">HttpSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getSession</span><span class="o">();</span>
</span><span class='line'><span class="n">String</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="o">(</span><span class="n">user</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Session的问题</h4>

<p>这种做法在小规模应用中工作良好，随着用户的增多，企业往往需要部署多台服务器形成集群来对外提供服务。在集群模式下，当某个节点挂掉之后，由于Session默认是保存在部署Web容器中的，用户会被误判为未登录，后续的请求会被重定向到登陆页面，影响用户体验。</p>

<p>这种将应用程序状态内置的方法已经完全无法满足应用的扩展，因此在工程实践中，我们会采用将Session外置的方式来解决这个问题。即集群中的所有节点都将Session保存在一个公用的键值数据库中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@EnableRedisHttpSession</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HttpSessionConfig</span> <span class="o">{</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个例子是在Spring Boot中使用Redis来外置Session。Spring会拦截所有对HTTPSession对象的操作，后续的对Session的操作，Spring都会自动转换为与后台的Redis服务器的交互，从而避免节点挂掉之后Session丢失的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">redis</span><span class="o">.</span><span class="na">host</span><span class="o">=</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">99.100</span>
</span><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">redis</span><span class="o">.</span><span class="na">password</span><span class="o">=</span>
</span><span class='line'><span class="n">spring</span><span class="o">.</span><span class="na">redis</span><span class="o">.</span><span class="na">port</span><span class="o">=</span><span class="mi">6379</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你跟我一样懒的话，直接启动一个redis的docker container就可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>docker run --name redis-server -d redis
</span></code></pre></td></tr></table></div></figure>


<p>这样，多个应用共享这一个实例，任何一个节点的终止、异常都不会产生Session的问题。</p>

<h3>基于Token的安全机制</h3>

<p>上面说到的场景中，使用Session需要额外部署一个组件（或者引入更加复杂的Session同步机制），这会带来另外的问题，比如如何保证这个节点的高可用，除了Production环境之外，Staging和QA环境也需要这个组件的配置、测试和维护。</p>

<p>很多项目现在会采用另外一种更加简单的方式：基于Token的安全机制。即不使用Session，用户在登陆之后，会获得一个Token，这个Token会以HTTP Header的方式发送给客户，同样，客户再后续的资源请求中也需要带着这个Token。通常这个Token还会有过期时间的限制（比如只能使用1周，一周之后需要重新获取）。</p>

<p>基于Token的机制更加简单，和RESTful风格的API一起使用更加自然，相较于传统的Web应用，RESTful的消费者可能是人，也可能是Mobile App，也可能是系统中另外的Service。也就是说，并不是所有的消费者都可以处理一个登陆表单！</p>

<h4>Restful API</h4>

<p>我们通过一个实例来看使用Spring Security保护受限制访问资源的场景。</p>

<p>对于Controller：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RestController</span>
</span><span class='line'><span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&quot;/protected&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProtectedResourceController</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">&quot;/{id}&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Message</span> <span class="nf">getOne</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">)</span> <span class="n">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">Message</span><span class="o">(</span><span class="s">&quot;Protected resource &quot;</span><span class="o">+</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要所有请求上都带有一个<code>X-Auth-Token</code>的Header，简单起见，如果这个Header有值，我们就认为这个请求已经被授权了。我们在Spring Security中定义这样的一个配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">http</span><span class="o">.</span>
</span><span class='line'>            <span class="nf">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">().</span>
</span><span class='line'>            <span class="n">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="n">SessionCreationPolicy</span><span class="o">.</span><span class="na">STATELESS</span><span class="o">).</span>
</span><span class='line'>            <span class="n">and</span><span class="o">().</span>
</span><span class='line'>            <span class="n">authorizeRequests</span><span class="o">().</span>
</span><span class='line'>            <span class="n">anyRequest</span><span class="o">().</span>
</span><span class='line'>            <span class="n">authenticated</span><span class="o">().</span>
</span><span class='line'>            <span class="n">and</span><span class="o">().</span>
</span><span class='line'>            <span class="n">exceptionHandling</span><span class="o">().</span>
</span><span class='line'>            <span class="n">authenticationEntryPoint</span><span class="o">(</span><span class="k">new</span> <span class="n">RestAuthenticationEntryPoint</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们使用<code>SessionCreationPolicy.STATELESS</code>无状态的Session机制（即Spring不使用HTTPSession），对于所有的请求都做权限校验，这样Spring Security的拦截器会判断所有请求的Header上有没有&#8221;X-Auth-Token&#8221;。对于异常情况（即当Spring Security发现没有），Spring会启用一个认证入口：<code>new RestAuthenticationEntryPoint</code>。在我们这个场景下，这个入口只是简单的返回一个401即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Component</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RestAuthenticationEntryPoint</span> <span class="kd">implements</span> <span class="n">AuthenticationEntryPoint</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commence</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
</span><span class='line'>                         <span class="n">AuthenticationException</span> <span class="n">authException</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">response</span><span class="o">.</span><span class="na">sendError</span><span class="o">(</span> <span class="n">HttpServletResponse</span><span class="o">.</span><span class="na">SC_UNAUTHORIZED</span><span class="o">,</span> <span class="s">&quot;Unauthorized&quot;</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时候，如果我们请求这个受限制的资源：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>curl http://api.kanban.com:9000/api/protected/1 -s | jq .
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;timestamp&quot;</span>: 1462621552738,
</span><span class='line'>  <span class="s2">&quot;status&quot;</span>: 401,
</span><span class='line'>  <span class="s2">&quot;error&quot;</span>: <span class="s2">&quot;Unauthorized&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;message&quot;</span>: <span class="s2">&quot;Unauthorized&quot;</span>,
</span><span class='line'>  <span class="s2">&quot;path&quot;</span>: <span class="s2">&quot;/api/protected/1&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>过滤器（Filter）及预认证（PreAuthentication）</h4>

<p>为了让Spring Security可以处理用户登录的case，我们需要提供一个<code>Filter</code>。当然，Spring Security提供了丰富的<code>Filter</code>机制，我们这里使用一个预认证的<code>Filter</code>（即假设用户已经在别的外部系统如SSO中登录了）:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KanBanPreAuthenticationFilter</span> <span class="kd">extends</span> <span class="n">AbstractPreAuthenticatedProcessingFilter</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SSO_TOKEN</span> <span class="o">=</span> <span class="s">&quot;X-Auth-Token&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SSO_CREDENTIALS</span> <span class="o">=</span> <span class="s">&quot;N/A&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">KanBanPreAuthenticationFilter</span><span class="o">(</span><span class="n">AuthenticationManager</span> <span class="n">authenticationManager</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">setAuthenticationManager</span><span class="o">(</span><span class="n">authenticationManager</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">getPreAuthenticatedPrincipal</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="n">SSO_TOKEN</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">Object</span> <span class="nf">getPreAuthenticatedCredentials</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">SSO_CREDENTIALS</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>过滤器在获得Header中的Token后，Spring Security会尝试去认证用户：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">AuthenticationManagerBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">builder</span><span class="o">.</span><span class="na">authenticationProvider</span><span class="o">(</span><span class="n">preAuthenticationProvider</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">AuthenticationProvider</span> <span class="nf">preAuthenticationProvider</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">PreAuthenticatedAuthenticationProvider</span> <span class="n">provider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PreAuthenticatedAuthenticationProvider</span><span class="o">();</span>
</span><span class='line'>    <span class="n">provider</span><span class="o">.</span><span class="na">setPreAuthenticatedUserDetailsService</span><span class="o">(</span><span class="k">new</span> <span class="n">KanBanAuthenticationUserDetailsService</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">provider</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>KanBanAuthenticationUserDetailsService</code>是一个实现了Spring Security的UserDetailsService的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KanBanAuthenticationUserDetailsService</span>
</span><span class='line'>        <span class="kd">implements</span> <span class="n">AuthenticationUserDetailsService</span><span class="o">&lt;</span><span class="n">PreAuthenticatedAuthenticationToken</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">UserDetails</span> <span class="nf">loadUserDetails</span><span class="o">(</span><span class="n">PreAuthenticatedAuthenticationToken</span> <span class="n">token</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">UsernameNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">principal</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">token</span><span class="o">.</span><span class="na">getPrincipal</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="o">(!</span><span class="n">StringUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">principal</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nf">KanBanUserDetails</span><span class="o">(</span><span class="k">new</span> <span class="n">KanBanUser</span><span class="o">(</span><span class="n">principal</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个类的职责是，查看从<code>KanBanPreAuthenticationFilter</code>返回的<code>PreAuthenticatedAuthenticationToken</code>，如果不为空，则表示该用户在系统中存在，并正常加载用户。如果返回null，则表示该认证失败，这时根据配置，Spring Security会重定向到认证入口<code>RestAuthenticationEntryPoint</code>。</p>

<p>加上这个过滤器的配置之后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>    <span class="n">http</span><span class="o">.</span><span class="na">addFilter</span><span class="o">(</span><span class="n">headerAuthenticationFilter</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Bean</span>
</span><span class='line'><span class="kd">public</span> <span class="n">KanBanPreAuthenticationFilter</span> <span class="nf">headerAuthenticationFilter</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">KanBanPreAuthenticationFilter</span><span class="o">(</span><span class="n">authenticationManager</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，当我们在Header上加上<code>X-Auth-Token</code>之后，就会访问到受限的资源了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>curl -H <span class="s2">&quot;X-Auth-Token: juntao&quot;</span> http://api.kanban.com:9000/api/protected/1 -s | jq .
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;content&quot;</span>: <span class="s2">&quot;Protected resource for 1&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>下一篇文章会以另外一个方式来完成鉴权机制和系统的集成问题。我们会在反向代理中做一些配置，将多个Endpoint组织起来。要完成这样的功能，使用Spring Security也可以做到，不过可能会为应用程序本身引入额外的复杂性。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2018/06/real-time-data-visualization/">实时数据的可视化</a>
      </li>
    
      <li class="post">
        <a href="/2018/01/two-types-of-developer/">团队里的两类程序员</a>
      </li>
    
      <li class="post">
        <a href="/2018/01/feedback-saves-the-world/">反馈拯救世界</a>
      </li>
    
      <li class="post">
        <a href="/2017/08/from-sandwich-to-hexagon/">从三明治到六边形</a>
      </li>
    
      <li class="post">
        <a href="/2017/07/tips-for-newbies/">如何成为一名优秀的程序员？</a>
      </li>
    
  </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Qiu Juntao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'icodeit';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
